/* Generated by Frama-C */
typedef unsigned long size_t;
typedef unsigned long __uint64_t;
typedef unsigned long __ino_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef int __clockid_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef __builtin_va_list __gnuc_va_list;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[((unsigned long)15 * sizeof(int) - (unsigned long)4 * sizeof(void *)) - sizeof(size_t)] ;
};
typedef __gnuc_va_list va_list;
typedef __ssize_t ssize_t;
typedef __time_t time_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef long __fd_mask;
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int)sizeof(__fd_mask))] ;
};
typedef struct __anonstruct_fd_set_10 fd_set;
typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long uint64_t;
typedef unsigned char uint_fast8_t;
struct select_callback {
   int (*set_fd)(fd_set *fdr, fd_set *fdw) ;
   void (*handle_fd)(fd_set *fdr, fd_set *fdw) ;
};
typedef unsigned long clock_time_t;
typedef unsigned short lc_t;
struct pt {
   lc_t lc ;
};
typedef unsigned char process_event_t;
typedef void *process_data_t;
typedef unsigned char process_num_events_t;
struct process {
   struct process *next ;
   char const *name ;
   char (*thread)(struct pt *, process_event_t , process_data_t ) ;
   struct pt pt ;
   unsigned char state ;
   unsigned char needspoll ;
};
struct timer {
   clock_time_t start ;
   clock_time_t interval ;
};
struct etimer {
   struct timer timer ;
   struct etimer *next ;
   struct process *p ;
};
struct ctimer {
   struct ctimer *next ;
   struct etimer etimer ;
   struct process *p ;
   void (*f)(void *) ;
   void *ptr ;
};
typedef uint32_t rtimer_clock_t;
struct rtimer;
struct rtimer {
   rtimer_clock_t time ;
   void (*func)(struct rtimer *t, void *ptr) ;
   void *ptr ;
};
enum __anonenum_13 {
    RTIMER_OK = 0,
    RTIMER_ERR_FULL = 1,
    RTIMER_ERR_TIME = 2,
    RTIMER_ERR_ALREADY_SCHEDULED = 3
};
typedef int radio_value_t;
typedef unsigned int radio_param_t;
enum __anonenum_radio_result_t_17 {
    RADIO_RESULT_OK = 0,
    RADIO_RESULT_NOT_SUPPORTED = 1,
    RADIO_RESULT_INVALID_VALUE = 2,
    RADIO_RESULT_ERROR = 3
};
typedef enum __anonenum_radio_result_t_17 radio_result_t;
enum __anonenum_18 {
    RADIO_TX_OK = 0,
    RADIO_TX_ERR = 1,
    RADIO_TX_COLLISION = 2,
    RADIO_TX_NOACK = 3
};
struct radio_driver {
   int (*init)(void) ;
   int (*prepare)(void const *payload, unsigned short payload_len) ;
   int (*transmit)(unsigned short transmit_len) ;
   int (*send)(void const *payload, unsigned short payload_len) ;
   int (*read)(void *buf, unsigned short buf_len) ;
   int (*channel_clear)(void) ;
   int (*receiving_packet)(void) ;
   int (*pending_packet)(void) ;
   int (*on)(void) ;
   int (*off)(void) ;
   radio_result_t (*get_value)(radio_param_t param, radio_value_t *value) ;
   radio_result_t (*set_value)(radio_param_t param, radio_value_t value) ;
   radio_result_t (*get_object)(radio_param_t param, void *dest, size_t size) ;
   radio_result_t (*set_object)(radio_param_t param, void const *src,
                                size_t size) ;
};
struct mac_driver {
   char *name ;
   void (*init)(void) ;
   void (*send)(void (*sent_callback)(void *ptr, int status,
                                      int transmissions),
                void *ptr) ;
   void (*input)(void) ;
   int (*on)(void) ;
   int (*off)(void) ;
   int (*max_payload)(void) ;
};
enum __anonenum_19 {
    MAC_TX_OK = 0,
    MAC_TX_COLLISION = 1,
    MAC_TX_NOACK = 2,
    MAC_TX_DEFERRED = 3,
    MAC_TX_ERR = 4,
    MAC_TX_ERR_FATAL = 5
};
struct framer {
   int (*length)(void) ;
   int (*create)(void) ;
   int (*parse)(void) ;
};
union __anonunion_linkaddr_t_20 {
   unsigned char u8[8] ;
   uint16_t u16[8 / 2] ;
};
typedef union __anonunion_linkaddr_t_20 linkaddr_t;
struct network_driver {
   char *name ;
   void (*init)(void) ;
   void (*input)(void) ;
   uint8_t (*output)(linkaddr_t const *localdest) ;
};
enum netstack_ip_action {
    NETSTACK_IP_PROCESS = 0,
    NETSTACK_IP_DROP = 1
};
enum netstack_ip_callback_type {
    NETSTACK_IP_INPUT = 0,
    NETSTACK_IP_OUTPUT = 1
};
struct netstack_ip_packet_processor {
   struct netstack_ip_packet_processor *next ;
   enum netstack_ip_action (*process_input)(void) ;
   enum netstack_ip_action (*process_output)(linkaddr_t const *localdest) ;
};
struct netstack_sniffer {
   struct netstack_sniffer *next ;
   void (*input_callback)(void) ;
   void (*output_callback)(int mac_status) ;
};
typedef uint8_t gpio_hal_pin_t;
typedef uint8_t gpio_hal_port_t;
typedef uint32_t gpio_hal_pin_cfg_t;
typedef uint32_t gpio_hal_pin_mask_t;
struct gpio_hal_event_handler_s {
   struct gpio_hal_event_handler_s *next ;
   void (*handler)(gpio_hal_pin_mask_t pin_mask) ;
   gpio_hal_pin_mask_t pin_mask ;
};
typedef struct gpio_hal_event_handler_s gpio_hal_event_handler_t;
struct button_hal_button_s;
typedef struct button_hal_button_s button_hal_button_t;
struct button_hal_button_s {
   struct ctimer debounce_ctimer ;
   struct ctimer duration_ctimer ;
   char const *description ;
   _Bool const negative_logic ;
   gpio_hal_pin_t const pin ;
   gpio_hal_pin_cfg_t const pull ;
   uint8_t press_duration_seconds ;
   uint8_t const unique_id ;
};
typedef uint8_t leds_num_t;
typedef uint8_t leds_mask_t;
struct leds_s {
   gpio_hal_pin_t pin ;
   _Bool negative_logic ;
};
typedef struct leds_s leds_t;
struct uip_ip_hdr;
enum __anonenum_21 {
    UIPBUF_ATTR_LLSEC_LEVEL = 0,
    UIPBUF_ATTR_LLSEC_KEY_ID = 1,
    UIPBUF_ATTR_INTERFACE_ID = 2,
    UIPBUF_ATTR_PHYSICAL_NETWORK_ID = 3,
    UIPBUF_ATTR_MAX_MAC_TRANSMISSIONS = 4,
    UIPBUF_ATTR_FLAGS = 5,
    UIPBUF_ATTR_MAX = 6
};
union uip_ip4addr_t {
   uint8_t u8[4] ;
   uint16_t u16[2] ;
};
typedef union uip_ip4addr_t uip_ip4addr_t;
union uip_ip6addr_t {
   uint8_t u8[16] ;
   uint16_t u16[8] ;
};
typedef union uip_ip6addr_t uip_ip6addr_t;
typedef uip_ip6addr_t uip_ipaddr_t;
struct uip_802154_longaddr {
   uint8_t addr[8] ;
};
typedef struct uip_802154_longaddr uip_802154_longaddr;
typedef uip_802154_longaddr uip_lladdr_t;
struct uip_conn;
struct tcpip_uipstate {
   struct process *p ;
   void *state ;
};
typedef struct tcpip_uipstate uip_udp_appstate_t;
typedef struct tcpip_uipstate uip_tcp_appstate_t;
struct uip_udp_conn;
union __anonunion_uip_buf_t_22 {
   uint32_t u32[(1280 + 3) / 4] ;
   uint8_t u8[1280] ;
};
typedef union __anonunion_uip_buf_t_22 uip_buf_t;
struct uip_conn {
   uip_ipaddr_t ripaddr ;
   uint16_t lport ;
   uint16_t rport ;
   uint8_t rcv_nxt[4] ;
   uint8_t snd_nxt[4] ;
   uint16_t len ;
   uint16_t mss ;
   uint16_t initialmss ;
   uint8_t sa ;
   uint8_t sv ;
   uint8_t rto ;
   uint8_t tcpstateflags ;
   uint8_t timer ;
   uint8_t nrtx ;
   uip_tcp_appstate_t appstate ;
};
struct uip_udp_conn {
   uip_ipaddr_t ripaddr ;
   uint16_t lport ;
   uint16_t rport ;
   uint8_t ttl ;
   uip_udp_appstate_t appstate ;
};
struct uip_ip_hdr {
   uint8_t vtc ;
   uint8_t tcflow ;
   uint16_t flow ;
   uint8_t len[2] ;
   uint8_t proto ;
   uint8_t ttl ;
   uip_ip6addr_t srcipaddr ;
   uip_ip6addr_t destipaddr ;
};
struct uip_ext_hdr {
   uint8_t next ;
   uint8_t len ;
};
struct uip_hbho_hdr {
   uint8_t next ;
   uint8_t len ;
};
struct uip_routing_hdr {
   uint8_t next ;
   uint8_t len ;
   uint8_t routing_type ;
   uint8_t seg_left ;
};
struct uip_rpl_srh_hdr {
   uint8_t cmpr ;
   uint8_t pad ;
   uint8_t reserved[2] ;
};
struct uip_ext_hdr_opt {
   uint8_t type ;
   uint8_t len ;
};
struct uip_ext_hdr_opt_rpl {
   uint8_t opt_type ;
   uint8_t opt_len ;
   uint8_t flags ;
   uint8_t instance ;
   uint16_t senderrank ;
};
struct uip_tcp_hdr {
   uint16_t srcport ;
   uint16_t destport ;
   uint8_t seqno[4] ;
   uint8_t ackno[4] ;
   uint8_t tcpoffset ;
   uint8_t flags ;
   uint8_t wnd[2] ;
   uint16_t tcpchksum ;
   uint8_t urgp[2] ;
   uint8_t optdata[4] ;
};
struct uip_icmp_hdr {
   uint8_t type ;
   uint8_t icode ;
   uint16_t icmpchksum ;
};
struct uip_udp_hdr {
   uint16_t srcport ;
   uint16_t destport ;
   uint16_t udplen ;
   uint16_t udpchksum ;
};
struct __anonstruct_frame802154_fcf_t_27 {
   uint8_t frame_type ;
   uint8_t security_enabled ;
   uint8_t frame_pending ;
   uint8_t ack_required ;
   uint8_t panid_compression ;
   uint8_t sequence_number_suppression ;
   uint8_t ie_list_present ;
   uint8_t dest_addr_mode ;
   uint8_t frame_version ;
   uint8_t src_addr_mode ;
};
typedef struct __anonstruct_frame802154_fcf_t_27 frame802154_fcf_t;
struct __anonstruct_frame802154_scf_t_28 {
   uint8_t security_level ;
   uint8_t key_id_mode ;
   uint8_t frame_counter_suppression ;
   uint8_t frame_counter_size ;
   uint8_t reserved ;
};
typedef struct __anonstruct_frame802154_scf_t_28 frame802154_scf_t;
union __anonunion_frame802154_frame_counter_t_29 {
   uint32_t u32 ;
   uint16_t u16[2] ;
   uint8_t u8[4] ;
};
typedef union __anonunion_frame802154_frame_counter_t_29 frame802154_frame_counter_t;
union __anonunion_frame802154_key_source_t_30 {
   uint16_t u16[4] ;
   uint8_t u8[8] ;
};
typedef union __anonunion_frame802154_key_source_t_30 frame802154_key_source_t;
struct __anonstruct_frame802154_aux_hdr_t_31 {
   frame802154_scf_t security_control ;
   frame802154_frame_counter_t frame_counter ;
   frame802154_key_source_t key_source ;
   uint8_t key_index ;
};
typedef struct __anonstruct_frame802154_aux_hdr_t_31 frame802154_aux_hdr_t;
struct __anonstruct_frame802154_t_32 {
   uint8_t dest_addr[8] ;
   uint8_t src_addr[8] ;
   frame802154_fcf_t fcf ;
   uint8_t seq ;
   uint16_t dest_pid ;
   uint16_t src_pid ;
   frame802154_aux_hdr_t aux_hdr ;
   uint8_t *payload ;
   int payload_len ;
};
typedef struct __anonstruct_frame802154_t_32 frame802154_t;
typedef uint16_t packetbuf_attr_t;
struct packetbuf_attr {
   packetbuf_attr_t val ;
};
struct packetbuf_addr {
   linkaddr_t addr ;
};
enum __anonenum_33 {
    PACKETBUF_ATTR_NONE = 0,
    PACKETBUF_ATTR_CHANNEL = 1,
    PACKETBUF_ATTR_NETWORK_ID = 2,
    PACKETBUF_ATTR_LINK_QUALITY = 3,
    PACKETBUF_ATTR_RSSI = 4,
    PACKETBUF_ATTR_TIMESTAMP = 5,
    PACKETBUF_ATTR_MAX_MAC_TRANSMISSIONS = 6,
    PACKETBUF_ATTR_MAC_SEQNO = 7,
    PACKETBUF_ATTR_MAC_ACK = 8,
    PACKETBUF_ATTR_MAC_METADATA = 9,
    PACKETBUF_ATTR_MAC_NO_SRC_ADDR = 10,
    PACKETBUF_ATTR_MAC_NO_DEST_ADDR = 11,
    PACKETBUF_ATTR_FRAME_TYPE = 12,
    PACKETBUF_ADDR_SENDER = 13,
    PACKETBUF_ADDR_RECEIVER = 14,
    PACKETBUF_ATTR_MAX = 15
};
struct stimer {
   unsigned long start ;
   unsigned long interval ;
};
struct uip_nd6_ns {
   uint32_t reserved ;
   uip_ipaddr_t tgtipaddr ;
};
typedef struct uip_nd6_ns uip_nd6_ns;
struct uip_nd6_na {
   uint8_t flagsreserved ;
   uint8_t reserved[3] ;
   uip_ipaddr_t tgtipaddr ;
};
typedef struct uip_nd6_na uip_nd6_na;
struct uip_nd6_opt_hdr {
   uint8_t type ;
   uint8_t len ;
};
typedef struct uip_nd6_opt_hdr uip_nd6_opt_hdr;
typedef void nbr_table_item_t;
typedef void nbr_table_callback(nbr_table_item_t *item);
struct nbr_table {
   int index ;
   int item_size ;
   nbr_table_callback *callback ;
   nbr_table_item_t *data ;
};
typedef struct nbr_table nbr_table_t;
enum __anonenum_nbr_table_reason_t_34 {
    NBR_TABLE_REASON_UNDEFINED = 0,
    NBR_TABLE_REASON_RPL_DIO = 1,
    NBR_TABLE_REASON_RPL_DAO = 2,
    NBR_TABLE_REASON_RPL_DIS = 3,
    NBR_TABLE_REASON_ROUTE = 4,
    NBR_TABLE_REASON_IPV6_ND = 5,
    NBR_TABLE_REASON_IPV6_ND_AUTOFILL = 6,
    NBR_TABLE_REASON_MAC = 7,
    NBR_TABLE_REASON_LLSEC = 8,
    NBR_TABLE_REASON_LINK_STATS = 9,
    NBR_TABLE_REASON_SIXTOP = 10
};
typedef enum __anonenum_nbr_table_reason_t_34 nbr_table_reason_t;
struct uip_packetqueue_handle;
struct uip_ds6_queued_packet;
struct uip_packetqueue_packet {
   struct uip_ds6_queued_packet *next ;
   uint8_t queue_buf[1280] ;
   uint16_t queue_buf_len ;
   struct ctimer lifetimer ;
   struct uip_packetqueue_handle *handle ;
};
struct uip_packetqueue_handle {
   struct uip_packetqueue_packet *packet ;
};
struct uip_ds6_nbr {
   uip_ipaddr_t ipaddr ;
   uint8_t isrouter ;
   uint8_t state ;
   struct uip_packetqueue_handle packethandle ;
};
typedef struct uip_ds6_nbr uip_ds6_nbr_t;
typedef void **list_t;
struct rpl_route_entry {
   uint32_t lifetime ;
   struct rpl_dag *dag ;
   uint8_t dao_seqno_out ;
   uint8_t dao_seqno_in ;
   uint8_t state_flags ;
};
typedef struct rpl_route_entry rpl_route_entry_t;
struct uip_ds6_route_neighbor_routes {
   void *route_list_list ;
   list_t route_list ;
};
struct uip_ds6_route {
   struct uip_ds6_route *next ;
   struct uip_ds6_route_neighbor_routes *neighbor_routes ;
   uip_ipaddr_t ipaddr ;
   rpl_route_entry_t state ;
   uint8_t length ;
};
typedef struct uip_ds6_route uip_ds6_route_t;
struct uip_ds6_defrt {
   struct uip_ds6_defrt *next ;
   uip_ipaddr_t ipaddr ;
   struct stimer lifetime ;
   uint8_t isinfinite ;
};
typedef struct uip_ds6_defrt uip_ds6_defrt_t;
struct uip_ds6_prefix {
   uint8_t isused ;
   uip_ipaddr_t ipaddr ;
   uint8_t length ;
   uint8_t advertise ;
   uint32_t vlifetime ;
   uint32_t plifetime ;
   uint8_t l_a_reserved ;
};
typedef struct uip_ds6_prefix uip_ds6_prefix_t;
struct uip_ds6_addr {
   uint8_t isused ;
   uip_ipaddr_t ipaddr ;
   uint8_t state ;
   uint8_t type ;
   uint8_t isinfinite ;
   struct stimer vlifetime ;
};
typedef struct uip_ds6_addr uip_ds6_addr_t;
struct uip_ds6_aaddr {
   uint8_t isused ;
   uip_ipaddr_t ipaddr ;
};
typedef struct uip_ds6_aaddr uip_ds6_aaddr_t;
struct uip_ds6_maddr {
   uint8_t isused ;
   uip_ipaddr_t ipaddr ;
};
typedef struct uip_ds6_maddr uip_ds6_maddr_t;
struct uip_ds6_netif {
   uint32_t link_mtu ;
   uint8_t cur_hop_limit ;
   uint32_t base_reachable_time ;
   uint32_t reachable_time ;
   uint32_t retrans_timer ;
   uint8_t maxdadns ;
   uip_ds6_addr_t addr_list[1 + 2] ;
   uip_ds6_aaddr_t aaddr_list[((1 + 2) - 1) + 0] ;
   uip_ds6_maddr_t maddr_list[((2 + 1) + 2) + 0] ;
};
typedef struct uip_ds6_netif uip_ds6_netif_t;
struct uip_ds6_element {
   uint8_t isused ;
   uip_ipaddr_t ipaddr ;
};
typedef struct uip_ds6_element uip_ds6_element_t;
struct log_module {
   char const *name ;
   int *curr_log_level ;
   int max_log_level ;
};
typedef __clockid_t clockid_t;
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
};
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
typedef int __itimer_which_t;
struct clock_timespec_s {
   time_t tv_sec ;
   long tv_nsec ;
};
typedef struct clock_timespec_s clock_timespec_t;
typedef int cfs_offset_t;
struct cfs_dir {
   char state[32] ;
};
struct cfs_dirent {
   char name[32] ;
   cfs_offset_t size ;
};
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream;
typedef struct __dirstream DIR;
struct cfs_posix_dir {
   DIR *dirp ;
};
typedef void (*__sighandler_t)(int );
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct __anonstruct_sync_serial_settings_74 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
typedef struct __anonstruct_sync_serial_settings_74 sync_serial_settings;
struct __anonstruct_te1_settings_75 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
typedef struct __anonstruct_te1_settings_75 te1_settings;
struct __anonstruct_raw_hdlc_proto_76 {
   unsigned short encoding ;
   unsigned short parity ;
};
typedef struct __anonstruct_raw_hdlc_proto_76 raw_hdlc_proto;
struct __anonstruct_fr_proto_77 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
typedef struct __anonstruct_fr_proto_77 fr_proto;
struct __anonstruct_fr_proto_pvc_78 {
   unsigned int dlci ;
};
typedef struct __anonstruct_fr_proto_pvc_78 fr_proto_pvc;
struct __anonstruct_fr_proto_pvc_info_79 {
   unsigned int dlci ;
   char master[16] ;
};
typedef struct __anonstruct_fr_proto_pvc_info_79 fr_proto_pvc_info;
struct __anonstruct_cisco_proto_80 {
   unsigned int interval ;
   unsigned int timeout ;
};
typedef struct __anonstruct_cisco_proto_80 cisco_proto;
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
union __anonunion_ifs_ifsu_83 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_83 ifs_ifsu ;
};
union __anonunion_ifr_ifrn_84 {
   char ifrn_name[16] ;
};
union __anonunion_ifr_ifru_85 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
struct ifreq {
   union __anonunion_ifr_ifrn_84 ifr_ifrn ;
   union __anonunion_ifr_ifru_85 ifr_ifru ;
};
typedef unsigned short eeprom_addr_t;
typedef uint32_t int_master_status_t;
struct simple_udp_connection;
struct simple_udp_connection {
   struct simple_udp_connection *next ;
   uip_ipaddr_t remote_addr ;
   uint16_t remote_port ;
   uint16_t local_port ;
   void (*receive_callback)(struct simple_udp_connection *c,
                            uip_ipaddr_t const *source_addr,
                            uint16_t source_port,
                            uip_ipaddr_t const *dest_addr,
                            uint16_t dest_port, uint8_t const *data,
                            uint16_t datalen) ;
   struct uip_udp_conn *udp_conn ;
   struct process *client_process ;
};
struct uip_sr_node {
   struct uip_sr_node *next ;
   uint32_t lifetime ;
   void *graph ;
   unsigned char link_identifier[8] ;
   struct uip_sr_node *parent ;
};
typedef struct uip_sr_node uip_sr_node_t;
struct routing_driver {
   char *name ;
   void (*init)(void) ;
   void (*root_set_prefix)(uip_ipaddr_t *prefix, uip_ipaddr_t *iid) ;
   int (*root_start)(void) ;
   int (*node_is_root)(void) ;
   int (*get_root_ipaddr)(uip_ipaddr_t *ipaddr) ;
   int (*get_sr_node_ipaddr)(uip_ipaddr_t *addr, uip_sr_node_t const *node) ;
   void (*leave_network)(void) ;
   int (*node_has_joined)(void) ;
   int (*node_is_reachable)(void) ;
   void (*global_repair)(char const *str) ;
   void (*local_repair)(char const *str) ;
   _Bool (*ext_header_remove)(void) ;
   int (*ext_header_update)(void) ;
   int (*ext_header_hbh_update)(uint8_t *ext_buf, int opt_offset) ;
   int (*ext_header_srh_update)(void) ;
   int (*ext_header_srh_get_next_hop)(uip_ipaddr_t *ipaddr) ;
   void (*link_callback)(linkaddr_t const *addr, int status, int numtx) ;
   void (*neighbor_state_changed)(uip_ds6_nbr_t *nbr) ;
   void (*drop_route)(uip_ds6_route_t *route) ;
};
struct uip_icmp6_error {
   uint32_t param ;
};
struct uip_icmp6_echo_reply_notification {
   struct uip_icmp6_echo_reply_notification *next ;
   void (*callback)(uip_ipaddr_t *source, uint8_t ttl, uint8_t *data,
                    uint16_t datalen) ;
};
struct uip_icmp6_input_handler {
   struct uip_icmp6_input_handler *next ;
   uint8_t type ;
   uint8_t icode ;
   void (*handler)(void) ;
};
typedef struct uip_icmp6_input_handler uip_icmp6_input_handler_t;
enum __anonenum_1 {
    RESOLV_STATUS_CACHED = 0,
    RESOLV_STATUS_UNCACHED = 1,
    RESOLV_STATUS_EXPIRED = 2,
    RESOLV_STATUS_NOT_FOUND = 3,
    RESOLV_STATUS_RESOLVING = 4,
    RESOLV_STATUS_ERROR = 5
};
typedef uint8_t resolv_status_t;
struct memb {
   unsigned short size ;
   unsigned short num ;
   char *count ;
   void *mem ;
};
struct psock_buf {
   uint8_t *ptr ;
   unsigned short left ;
};
struct psock {
   struct pt pt ;
   struct pt psockpt ;
   uint8_t const *sendptr ;
   uint8_t *readptr ;
   uint8_t *bufptr ;
   uint16_t sendlen ;
   uint16_t readlen ;
   struct psock_buf buf ;
   unsigned int bufsize ;
   unsigned char state ;
};
struct udp_socket;
struct udp_socket {
   void (*input_callback)(struct udp_socket *c, void *ptr,
                          uip_ipaddr_t const *source_addr,
                          uint16_t source_port,
                          uip_ipaddr_t const *dest_addr, uint16_t dest_port,
                          uint8_t const *data, uint16_t datalen) ;
   void *ptr ;
   struct process *p ;
   struct uip_udp_conn *udp_conn ;
};
enum energest_type {
    ENERGEST_TYPE_CPU = 0,
    ENERGEST_TYPE_LPM = 1,
    ENERGEST_TYPE_DEEP_LPM = 2,
    ENERGEST_TYPE_TRANSMIT = 3,
    ENERGEST_TYPE_LISTEN = 4,
    ENERGEST_TYPE_MAX = 5
};
typedef enum energest_type energest_type_t;
struct tsch_asn_t {
   uint32_t ls4b ;
   uint8_t ms1b ;
};
struct ringbufindex {
   uint8_t mask ;
   uint8_t put_ptr ;
   uint8_t get_ptr ;
};
struct tsch_packet {
   struct queuebuf *qb ;
   void (*sent)(void *ptr, int status, int transmissions) ;
   void *ptr ;
   uint8_t transmissions ;
   uint8_t max_transmissions ;
   uint8_t ret ;
   uint8_t header_len ;
   uint8_t tsch_sync_ie_offset ;
};
struct tsch_neighbor {
   struct tsch_neighbor *next ;
   linkaddr_t addr ;
   uint8_t is_broadcast ;
   uint8_t is_time_source ;
   uint8_t backoff_exponent ;
   uint8_t backoff_window ;
   uint8_t last_backoff_window ;
   uint8_t tx_links_count ;
   uint8_t dedicated_tx_links_count ;
   struct tsch_packet *tx_array[64] ;
   struct ringbufindex tx_ringbuf ;
};
enum tsch_timeslot_timing_elements {
    tsch_ts_cca_offset = 0,
    tsch_ts_cca = 1,
    tsch_ts_tx_offset = 2,
    tsch_ts_rx_offset = 3,
    tsch_ts_rx_ack_delay = 4,
    tsch_ts_tx_ack_delay = 5,
    tsch_ts_rx_wait = 6,
    tsch_ts_ack_wait = 7,
    tsch_ts_rx_tx = 8,
    tsch_ts_max_ack = 9,
    tsch_ts_max_tx = 10,
    tsch_ts_timeslot_length = 11,
    tsch_ts_elements_count = 12
};
struct tsch_slotframe_and_links_link {
   uint16_t timeslot ;
   uint16_t channel_offset ;
   uint8_t link_options ;
};
struct tsch_slotframe_and_links {
   uint8_t num_slotframes ;
   uint8_t slotframe_handle ;
   uint16_t slotframe_size ;
   uint8_t num_links ;
   struct tsch_slotframe_and_links_link links[4] ;
};
static uint8_t __constr_expr_0[4];

struct ieee802154_ies {
   int16_t ie_time_correction ;
   uint8_t ie_is_nack ;
   uint8_t ie_payload_ie_offset ;
   uint16_t ie_mlme_len ;
   uint8_t ie_tsch_synchronization_offset ;
   struct tsch_asn_t ie_asn ;
   uint8_t ie_join_priority ;
   uint8_t ie_tsch_timeslot_id ;
   uint16_t ie_tsch_timeslot[tsch_ts_elements_count] ;
   struct tsch_slotframe_and_links ie_tsch_slotframe_and_link ;
   uint8_t ie_channel_hopping_sequence_id ;
   uint16_t ie_hopping_sequence_len ;
   uint8_t ie_hopping_sequence_list[sizeof(__constr_expr_0)] ;
};
typedef uint16_t rpl_rank_t;
typedef uint16_t rpl_ocp_t;
struct rpl_metric_object_energy {
   uint8_t flags ;
   uint8_t energy_est ;
};
union metric_object {
   struct rpl_metric_object_energy energy ;
   uint16_t etx ;
};
struct rpl_metric_container {
   uint8_t type ;
   uint8_t flags ;
   uint8_t aggr ;
   uint8_t prec ;
   uint8_t length ;
   union metric_object obj ;
};
typedef struct rpl_metric_container rpl_metric_container_t;
struct rpl_prefix {
   uip_ipaddr_t prefix ;
   uint32_t lifetime ;
   uint8_t length ;
   uint8_t flags ;
};
typedef struct rpl_prefix rpl_prefix_t;
struct rpl_nbr {
   clock_time_t better_parent_since ;
   rpl_rank_t rank ;
   uint8_t dtsn ;
};
typedef struct rpl_nbr rpl_nbr_t;
struct rpl_of {
   void (*reset)(void) ;
   uint16_t (*nbr_link_metric)(rpl_nbr_t *) ;
   int (*nbr_has_usable_link)(rpl_nbr_t *) ;
   int (*nbr_is_acceptable_parent)(rpl_nbr_t *) ;
   uint16_t (*nbr_path_cost)(rpl_nbr_t *) ;
   rpl_rank_t (*rank_via_nbr)(rpl_nbr_t *) ;
   rpl_nbr_t *(*best_parent)(rpl_nbr_t *, rpl_nbr_t *) ;
   void (*update_metric_container)(void) ;
   rpl_ocp_t ocp ;
};
typedef struct rpl_of rpl_of_t;
enum rpl_dag_state {
    DAG_INITIALIZED = 0,
    DAG_JOINED = 1,
    DAG_REACHABLE = 2,
    DAG_POISONING = 3
};
struct rpl_dag {
   uip_ipaddr_t dag_id ;
   rpl_prefix_t prefix_info ;
   rpl_nbr_t *preferred_parent ;
   rpl_rank_t lowest_rank ;
   rpl_rank_t rank ;
   rpl_rank_t last_advertised_rank ;
   uint32_t lifetime ;
   uint8_t version ;
   uint8_t grounded ;
   uint8_t preference ;
   uint8_t dio_intcurrent ;
   uint8_t dio_send ;
   uint8_t dio_counter ;
   uint8_t dao_last_seqno ;
   uint8_t dao_last_acked_seqno ;
   uint8_t dao_transmissions ;
   enum rpl_dag_state state ;
   clock_time_t dio_next_delay ;
   struct ctimer state_update ;
   struct ctimer leave ;
   struct ctimer dio_timer ;
   struct ctimer unicast_dio_timer ;
   struct ctimer dao_timer ;
   rpl_nbr_t *unicast_dio_target ;
   struct ctimer probing_timer ;
   rpl_nbr_t *urgent_probing_target ;
   uip_ipaddr_t dao_ack_target ;
   uint16_t dao_ack_sequence ;
   struct ctimer dao_ack_timer ;
};
typedef struct rpl_dag rpl_dag_t;
struct rpl_instance {
   rpl_metric_container_t mc ;
   rpl_of_t *of ;
   uint8_t used ;
   uint8_t instance_id ;
   uint8_t mop ;
   uint8_t dtsn_out ;
   uint8_t dio_intdoubl ;
   uint8_t dio_intmin ;
   uint8_t dio_redundancy ;
   rpl_rank_t max_rankinc ;
   rpl_rank_t min_hoprankinc ;
   uint8_t default_lifetime ;
   uint16_t lifetime_unit ;
   rpl_dag_t dag ;
};
typedef struct rpl_instance rpl_instance_t;
struct rpl_dio {
   uip_ipaddr_t dag_id ;
   rpl_ocp_t ocp ;
   rpl_rank_t rank ;
   uint8_t grounded ;
   uint8_t mop ;
   uint8_t preference ;
   uint8_t version ;
   uint8_t instance_id ;
   uint8_t dtsn ;
   uint8_t dag_intdoubl ;
   uint8_t dag_intmin ;
   uint8_t dag_redund ;
   uint8_t default_lifetime ;
   uint16_t lifetime_unit ;
   rpl_rank_t dag_max_rankinc ;
   rpl_rank_t dag_min_hoprankinc ;
   rpl_prefix_t destination_prefix ;
   rpl_prefix_t prefix_info ;
   struct rpl_metric_container mc ;
};
typedef struct rpl_dio rpl_dio_t;
struct rpl_dao {
   uip_ipaddr_t parent_addr ;
   uip_ipaddr_t prefix ;
   uint16_t sequence ;
   uint8_t instance_id ;
   uint8_t lifetime ;
   uint8_t prefixlen ;
   uint8_t flags ;
};
typedef struct rpl_dao rpl_dao_t;
struct orchestra_rule {
   void (*init)(uint16_t slotframe_handle) ;
   void (*new_time_source)(struct tsch_neighbor const *old,
                           struct tsch_neighbor const *new) ;
   int (*select_packet)(uint16_t *slotframe, uint16_t *timeslot) ;
   void (*child_added)(linkaddr_t const *addr) ;
   void (*child_removed)(linkaddr_t const *addr) ;
};
typedef uint_fast8_t mutex_t;
struct compower_activity {
   uint64_t listen ;
   uint64_t transmit ;
};
struct event_data {
   process_event_t ev ;
   process_data_t data ;
   struct process *p ;
};
struct ringbuf {
   uint8_t *data ;
   uint8_t mask ;
   uint8_t put_ptr ;
   uint8_t get_ptr ;
};
typedef void **dbl_circ_list_t;
struct dblcl {
   struct dblcl *next ;
   struct dblcl *previous ;
};
struct ccm_star_driver {
   void (*set_key)(uint8_t const *key) ;
   void (*aead)(uint8_t const *nonce, uint8_t *m, uint8_t m_len,
                uint8_t const *a, uint8_t a_len, uint8_t *result,
                uint8_t mic_len, int forward) ;
};
struct aes_128_driver {
   void (*set_key)(uint8_t const *key) ;
   void (*encrypt)(uint8_t *plaintext_and_result) ;
};
typedef void **dbl_list_t;
struct dll {
   struct dll *next ;
   struct dll *previous ;
};
struct list {
   struct list *next ;
};
typedef void **circular_list_t;
struct cl {
   struct cl *next ;
};
struct trickle_timer {
   clock_time_t i_min ;
   clock_time_t i_cur ;
   clock_time_t i_start ;
   clock_time_t i_max_abs ;
   struct ctimer ct ;
   void (*cb)(void *ptr, uint8_t suppress) ;
   void *cb_arg ;
   uint8_t i_max ;
   uint8_t k ;
   uint8_t c ;
};
struct heapmem_stats {
   size_t allocated ;
   size_t overhead ;
   size_t available ;
   size_t footprint ;
   size_t chunks ;
};
typedef struct heapmem_stats heapmem_stats_t;
struct chunk {
   struct chunk *prev ;
   struct chunk *next ;
   size_t size ;
   uint8_t flags ;
};
typedef struct chunk chunk_t;
struct queuebuf_data;
struct queuebuf {
   struct queuebuf_data *ram_ptr ;
};
struct queuebuf_data {
   uint8_t data[128] ;
   uint16_t len ;
   struct packetbuf_attr attrs[PACKETBUF_ATTR_MAX - 2] ;
   struct packetbuf_addr addrs[2] ;
};
struct nbr_table_key {
   struct nbr_table_key *next ;
   linkaddr_t lladdr ;
};
typedef struct nbr_table_key nbr_table_key_t;
struct link_stats {
   clock_time_t last_tx_time ;
   uint16_t etx ;
   int16_t rssi ;
   uint8_t freshness ;
};
struct seqno {
   linkaddr_t sender ;
   clock_time_t timestamp ;
   uint8_t seqno ;
};
enum ieee802154e_header_ie_id {
    HEADER_IE_LE_CSL = 0x1a,
    HEADER_IE_LE_RIT = 27,
    HEADER_IE_DSME_PAN_DESCRIPTOR = 28,
    HEADER_IE_RZ_TIME = 29,
    HEADER_IE_ACK_NACK_TIME_CORRECTION = 30,
    HEADER_IE_GACK = 31,
    HEADER_IE_LOW_LATENCY_NETWORK_INFO = 32,
    HEADER_IE_LIST_TERMINATION_1 = 0x7e,
    HEADER_IE_LIST_TERMINATION_2 = 0x7f
};
enum ieee802154e_payload_ie_id {
    PAYLOAD_IE_ESDU = 0,
    PAYLOAD_IE_MLME = 1,
    PAYLOAD_IE_IETF = 0x5,
    PAYLOAD_IE_LIST_TERMINATION = 0xf
};
enum ieee802154e_mlme_short_subie_id {
    MLME_SHORT_IE_TSCH_SYNCHRONIZATION = 0x1a,
    MLME_SHORT_IE_TSCH_SLOFTRAME_AND_LINK = 27,
    MLME_SHORT_IE_TSCH_TIMESLOT = 28,
    MLME_SHORT_IE_TSCH_HOPPING_TIMING = 29,
    MLME_SHORT_IE_TSCH_EB_FILTER = 30,
    MLME_SHORT_IE_TSCH_MAC_METRICS_1 = 31,
    MLME_SHORT_IE_TSCH_MAC_METRICS_2 = 32
};
enum ieee802154e_mlme_long_subie_id {
    MLME_LONG_IE_TSCH_CHANNEL_HOPPING_SEQUENCE = 0x9
};
enum __anonenum_parsing_state_38 {
    PARSING_HEADER_IE = 0,
    PARSING_PAYLOAD_IE = 1,
    PARSING_MLME_SUBIE = 2
};
struct __anonstruct_field_length_t_20 {
   uint8_t seqno_len ;
   uint8_t dest_pid_len ;
   uint8_t dest_addr_len ;
   uint8_t src_pid_len ;
   uint8_t src_addr_len ;
   uint8_t aux_sec_len ;
};
typedef struct __anonstruct_field_length_t_20 field_length_t;
enum __anonenum_28 {
    TCP_POLL = 0,
    UDP_POLL = 1,
    PACKET_INPUT = 2
};
struct dns_hdr {
   uint16_t id ;
   uint8_t flags1 ;
   uint8_t flags2 ;
   uint16_t numquestions ;
   uint16_t numanswers ;
   uint16_t numauthrr ;
   uint16_t numextrarr ;
};
struct dns_answer {
   uint16_t type ;
   uint16_t class ;
   uint16_t ttl[2] ;
   uint16_t len ;
   uint8_t ipaddr[16] ;
};
struct namemap {
   uint8_t state ;
   uint8_t tmr ;
   uint16_t id ;
   uint8_t retries ;
   uint8_t seqno ;
   unsigned long expiration ;
   uip_ipaddr_t ipaddr ;
   uint8_t err ;
   uint8_t server ;
   int is_mdns : 1 ;
   int is_probe : 1 ;
   char name[32 + 1] ;
};
struct dns_question {
   uint16_t type ;
   uint16_t class ;
};
enum __anonenum_2 {
    MDNS_STATE_WAIT_BEFORE_PROBE = 0,
    MDNS_STATE_PROBING = 1,
    MDNS_STATE_READY = 2
};
struct __anonstruct_nsec_record_27 {
   uint16_t type ;
   uint16_t class ;
   uint16_t ttl[2] ;
   uint16_t len ;
   uint8_t data[8] ;
};
struct sicslowpan_addr_context {
   uint8_t used ;
   uint8_t number ;
   uint8_t prefix[8] ;
};
struct sicslowpan_frag_info {
   linkaddr_t sender ;
   linkaddr_t receiver ;
   uint16_t tag ;
   uint16_t len ;
   uint16_t reassembled_len ;
   struct timer reass_timer ;
   uint16_t first_frag_len ;
   uint8_t first_frag[((127 - 2) - 15) + 38] ;
};
struct sicslowpan_frag_buf {
   uint8_t index ;
   uint8_t offset ;
   uint8_t len ;
   uint8_t data[(127 - 2) - 15] ;
};
/* compiler builtin: 
   unsigned int __builtin_bswap32(unsigned int);   */
/* compiler builtin: 
   unsigned long __builtin_bswap64(unsigned long);   */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list);   */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list);   */
extern struct _IO_FILE *stdout;

extern struct _IO_FILE *stderr;

extern  __attribute__((__nothrow__)) int remove(char const *__filename) __attribute__((
__leaf__));

extern FILE *tmpfile(void);

extern int fflush(FILE *__stream);

extern FILE *fopen(char const * __restrict __filename,
                   char const * __restrict __modes);

extern  __attribute__((__nothrow__)) int setvbuf(FILE * __restrict __stream,
                                                 char * __restrict __buf,
                                                 int __modes, size_t __n) __attribute__((
__leaf__));

extern int fprintf(FILE * __restrict __stream,
                   char const * __restrict __format , ...);

extern int printf(char const * __restrict __format , ...);

extern  __attribute__((__nothrow__)) int ( /* format attribute */ snprintf)(
char * __restrict __s, size_t __maxlen, char const * __restrict __format
, ...);

extern  __attribute__((__nothrow__)) int ( /* format attribute */ vsnprintf)(
char * __restrict __s, size_t __maxlen, char const * __restrict __format,
__gnuc_va_list __arg);

extern int fputc(int __c, FILE *__stream);

extern size_t fread(void * __restrict __ptr, size_t __size, size_t __n,
                    FILE * __restrict __stream);

extern size_t fwrite(void const * __restrict __ptr, size_t __size,
                     size_t __n, FILE * __restrict __s);

extern int fseek(FILE *__stream, long __off, int __whence);

extern long ftell(FILE *__stream);

extern void perror(char const *__s);

extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict __dest,
                                                  void const * __restrict __src,
                                                  size_t __n) __attribute__((
__nonnull__(1,2), __leaf__));

extern  __attribute__((__nothrow__)) void *memmove(void *__dest,
                                                   void const *__src,
                                                   size_t __n) __attribute__((
__nonnull__(1,2), __leaf__));

extern  __attribute__((__nothrow__)) void *memset(void *__s, int __c,
                                                  size_t __n) __attribute__((
__nonnull__(1), __leaf__));

extern  __attribute__((__nothrow__)) int memcmp(void const *__s1,
                                                void const *__s2, size_t __n) __attribute__((
__pure__, __nonnull__(1,2), __leaf__));

extern  __attribute__((__nothrow__)) char *strncpy(char * __restrict __dest,
                                                   char const * __restrict __src,
                                                   size_t __n) __attribute__((
__nonnull__(1,2), __leaf__));

extern  __attribute__((__nothrow__)) char *strncat(char * __restrict __dest,
                                                   char const * __restrict __src,
                                                   size_t __n) __attribute__((
__nonnull__(1,2), __leaf__));

extern  __attribute__((__nothrow__)) int strcmp(char const *__s1,
                                                char const *__s2) __attribute__((
__pure__, __nonnull__(1,2), __leaf__));

extern  __attribute__((__nothrow__)) size_t strlen(char const *__s) __attribute__((
__pure__, __nonnull__(1), __leaf__));

extern  __attribute__((__nothrow__)) int strcasecmp(char const *__s1,
                                                    char const *__s2) __attribute__((
__pure__, __nonnull__(1,2), __leaf__));

extern  __attribute__((__nothrow__)) int strncasecmp(char const *__s1,
                                                     char const *__s2,
                                                     size_t __n) __attribute__((
__pure__, __nonnull__(1,2), __leaf__));

extern  __attribute__((__nothrow__)) __off_t lseek(int __fd,
                                                   __off_t __offset,
                                                   int __whence) __attribute__((
__leaf__));

extern int close(int __fd);

extern ssize_t read(int __fd, void *__buf, size_t __nbytes);

extern ssize_t write(int __fd, void const *__buf, size_t __n);

extern int select(int __nfds, fd_set * __restrict __readfds,
                  fd_set * __restrict __writefds,
                  fd_set * __restrict __exceptfds,
                  struct timeval * __restrict __timeout);

extern  __attribute__((__nothrow__)) int *__errno_location(void) __attribute__((
__leaf__, __const__));

int select_set_callback(int fd, struct select_callback const *callback_0);

__inline static unsigned int __bswap_32(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

extern  __attribute__((__nothrow__)) int tolower(int __c) __attribute__((
__leaf__));

void process_start(struct process *p, process_data_t data);

int process_post(struct process *p, process_event_t ev, process_data_t data);

void process_post_synch(struct process *p, process_event_t ev,
                        process_data_t data);

void process_exit(struct process *p);

struct process *process_current;

process_event_t process_alloc_event(void);

void process_poll(struct process *p);

void process_init(void);

int process_run(void);

int process_is_running(struct process *p);

int process_nevents(void);

struct process *process_list;

struct process * const autostart_processes[2];

void autostart_start(struct process * const *processes);

void autostart_exit(struct process * const *processes);

void clock_init(void);

clock_time_t clock_time(void);

unsigned long clock_seconds(void);

void clock_delay(unsigned int d);

void timer_set(struct timer *t, clock_time_t interval);

void timer_reset(struct timer *t);

void timer_restart(struct timer *t);

int timer_expired(struct timer *t);

clock_time_t timer_remaining(struct timer *t);

void etimer_set(struct etimer *et, clock_time_t interval);

void etimer_reset(struct etimer *et);

void etimer_reset_with_new_interval(struct etimer *et, clock_time_t interval);

void etimer_restart(struct etimer *et);

void etimer_adjust(struct etimer *et, int timediff);

clock_time_t etimer_expiration_time(struct etimer *et);

clock_time_t etimer_start_time(struct etimer *et);

int etimer_expired(struct etimer *et);

void etimer_stop(struct etimer *et);

void etimer_request_poll(void);

int etimer_pending(void);

clock_time_t etimer_next_expiration_time(void);

struct process etimer_process;

void ctimer_reset(struct ctimer *c);

void ctimer_restart(struct ctimer *c);

void ctimer_set(struct ctimer *c, clock_time_t t, void (*f)(void *),
                void *ptr);

void ctimer_set_with_process(struct ctimer *c, clock_time_t t,
                             void (*f)(void *), void *ptr, struct process *p);

void ctimer_stop(struct ctimer *c);

int ctimer_expired(struct ctimer *c);

void ctimer_init(void);

void watchdog_init(void);

void watchdog_start(void);

void watchdog_periodic(void);

void watchdog_stop(void);

void watchdog_reboot(void);

void rtimer_init(void);

int rtimer_set(struct rtimer *rtimer, rtimer_clock_t time_0,
               rtimer_clock_t duration,
               void (*func)(struct rtimer *t, void *ptr), void *ptr);

void rtimer_run_next(void);

void rtimer_arch_init(void);

void rtimer_arch_schedule(rtimer_clock_t t);

void mac_call_sent_callback(void (*sent)(void *ptr, int status,
                                         int transmissions),
                            void *ptr, int status, int num_tx);

void linkaddr_copy(linkaddr_t *dest, linkaddr_t const *src);

int linkaddr_cmp(linkaddr_t const *addr1, linkaddr_t const *addr2);

void linkaddr_set_node_addr(linkaddr_t *t);

linkaddr_t linkaddr_node_addr;

linkaddr_t const linkaddr_null;

struct routing_driver const rpl_lite_driver;

struct network_driver const tun6_net_driver;

struct mac_driver const nullmac_driver;

struct radio_driver const nullradio_driver;

struct framer const framer_802154;

void netstack_init(void);

enum netstack_ip_action netstack_process_ip_callback(uint8_t type,
                                                     linkaddr_t const *localdest);

void netstack_ip_packet_processor_add(struct netstack_ip_packet_processor *p);

void netstack_sniffer_add(struct netstack_sniffer *s);

void netstack_sniffer_remove(struct netstack_sniffer *s);

process_event_t serial_line_event_message;

int serial_line_input_byte(unsigned char c);

void serial_line_init(void);

struct process serial_line_process;

void gpio_hal_init(void);

void gpio_hal_register_handler(gpio_hal_event_handler_t *handler);

void gpio_hal_event_handler(gpio_hal_pin_mask_t pins);

void gpio_hal_arch_init(void);

void gpio_hal_arch_no_port_interrupt_enable(gpio_hal_pin_t pin);

void gpio_hal_arch_no_port_interrupt_disable(gpio_hal_pin_t pin);

void gpio_hal_arch_no_port_pin_cfg_set(gpio_hal_pin_t pin,
                                       gpio_hal_pin_cfg_t cfg);

gpio_hal_pin_cfg_t gpio_hal_arch_no_port_pin_cfg_get(gpio_hal_pin_t pin);

void gpio_hal_arch_no_port_pin_set_input(gpio_hal_pin_t pin);

void gpio_hal_arch_no_port_pin_set_output(gpio_hal_pin_t pin);

void gpio_hal_arch_no_port_set_pin(gpio_hal_pin_t pin);

void gpio_hal_arch_no_port_clear_pin(gpio_hal_pin_t pin);

void gpio_hal_arch_port_toggle_pin(gpio_hal_port_t port, gpio_hal_pin_t pin);

void gpio_hal_arch_no_port_toggle_pin(gpio_hal_pin_t pin);

uint8_t gpio_hal_arch_no_port_read_pin(gpio_hal_pin_t pin);

void gpio_hal_arch_no_port_write_pin(gpio_hal_pin_t pin, uint8_t value);

void gpio_hal_arch_no_port_set_pins(gpio_hal_pin_mask_t pins);

void gpio_hal_arch_no_port_clear_pins(gpio_hal_pin_mask_t pins);

void gpio_hal_arch_port_toggle_pins(gpio_hal_port_t port,
                                    gpio_hal_pin_mask_t pins);

void gpio_hal_arch_no_port_toggle_pins(gpio_hal_pin_mask_t pins);

gpio_hal_pin_mask_t gpio_hal_arch_no_port_read_pins(gpio_hal_pin_mask_t pins);

void gpio_hal_arch_no_port_write_pins(gpio_hal_pin_mask_t pins,
                                      gpio_hal_pin_mask_t value);

uint8_t const button_hal_button_count;

process_event_t button_hal_press_event;

process_event_t button_hal_release_event;

process_event_t button_hal_periodic_event;

void button_hal_init(void);

button_hal_button_t *button_hal_get_by_id(uint8_t unique_id);

button_hal_button_t *button_hal_get_by_index(uint8_t index_0);

uint8_t button_hal_get_state(button_hal_button_t *button);

void leds_init(void);

void leds_single_on(leds_num_t led);

void leds_single_off(leds_num_t led);

void leds_single_toggle(leds_num_t led);

void leds_on(leds_mask_t leds);

void leds_off(leds_mask_t leds);

void leds_toggle(leds_mask_t leds);

void leds_set(leds_mask_t leds);

leds_mask_t leds_get(void);

void uip_log(char *m);

void uipbuf_clear(void);

_Bool uipbuf_add_ext_hdr(int16_t len);

_Bool uipbuf_set_len(uint16_t len);

void uipbuf_set_len_field(struct uip_ip_hdr *hdr, uint16_t len);

uint16_t uipbuf_get_len_field(struct uip_ip_hdr *hdr);

uint8_t *uipbuf_get_next_header(uint8_t *buffer, uint16_t size,
                                uint8_t *protocol, _Bool start);

uint8_t *uipbuf_get_last_header(uint8_t *buffer, uint16_t size,
                                uint8_t *protocol);

uint8_t *uipbuf_search_header(uint8_t *buffer, uint16_t size,
                              uint8_t protocol);

uint16_t uipbuf_get_attr(uint8_t type);

int uipbuf_set_attr(uint8_t type, uint16_t value);

int uipbuf_set_default_attr(uint8_t type, uint16_t value);

void uipbuf_set_attr_flag(uint16_t flag);

void uipbuf_clr_attr_flag(uint16_t flag);

uint16_t uipbuf_is_attr_flag(uint16_t flag);

void uipbuf_clear_attr(void);

void uipbuf_init(void);

void tcpip_uipcall(void);

void udp_attach(struct uip_udp_conn *conn, void *appstate);

struct uip_udp_conn *udp_new(uip_ipaddr_t const *ripaddr, uint16_t port,
                             void *appstate);

struct uip_udp_conn *udp_broadcast_new(uint16_t port, void *appstate);

void tcpip_poll_udp(struct uip_udp_conn *conn);

process_event_t tcpip_event;

void tcpip_input(void);

uint8_t tcpip_output(uip_lladdr_t const *a);

void tcpip_ipv6_output(void);

struct process tcpip_process;

void uip_init(void);

uip_buf_t uip_aligned_buf;

void uip_send(void const *data, int len);

struct uip_udp_conn *uip_udp_new(uip_ipaddr_t const *ripaddr, uint16_t rport);

uint16_t uip_htons(uint16_t val);

uint32_t uip_htonl(uint32_t val);

void *uip_appdata;

uint16_t uip_len;

uint16_t uip_ext_len;

uint8_t uip_last_proto;

struct uip_conn *uip_conn;

struct uip_udp_conn *uip_udp_conn;

struct uip_udp_conn uip_udp_conns[8];

uint8_t uip_flags;

void uip_process(uint8_t flag);

uip_lladdr_t uip_lladdr;

uint16_t uip_chksum(uint16_t *data, uint16_t len);

uint16_t uip_udpchksum(void);

uint16_t uip_icmp6chksum(void);

_Bool uip_remove_ext_hdr(void);

void net_debug_lladdr_print(uip_lladdr_t const *addr_0);

int uiplib_ip4addrconv(char const *addrstr, uip_ip4addr_t *ipaddr);

int uiplib_ip6addrconv(char const *addrstr, uip_ip6addr_t *ipaddr);

void uiplib_ipaddr_print(uip_ipaddr_t const *addr_0);

int uiplib_ipaddr_snprint(char *buf_0, size_t size,
                          uip_ipaddr_t const *addr_0);

__inline static void uip_debug_ipaddr_print(uip_ipaddr_t const *addr_0)
{
  uiplib_ipaddr_print(addr_0);
  return;
}

int frame802154_hdrlen(frame802154_t *p);

void frame802154_create_fcf(frame802154_fcf_t *fcf, uint8_t *buf_0);

int frame802154_create(frame802154_t *p, uint8_t *buf_0);

int frame802154_parse(uint8_t *data, int len, frame802154_t *pf);

void frame802154_parse_fcf(uint8_t *data, frame802154_fcf_t *pfcf);

uint16_t frame802154_get_pan_id(void);

void frame802154_set_pan_id(uint16_t pan_id);

void frame802154_has_panid(frame802154_fcf_t *fcf, int *has_src_pan_id,
                           int *has_dest_pan_id);

int frame802154_check_dest_panid(frame802154_t *frame);

int frame802154_is_broadcast_addr(uint8_t mode, uint8_t *addr_0);

int frame802154_extract_linkaddr(frame802154_t *frame,
                                 linkaddr_t *source_address,
                                 linkaddr_t *dest_address);

void packetbuf_clear(void);

void *packetbuf_dataptr(void);

void *packetbuf_hdrptr(void);

uint8_t packetbuf_hdrlen(void);

uint16_t packetbuf_datalen(void);

uint16_t packetbuf_totlen(void);

uint16_t packetbuf_remaininglen(void);

void packetbuf_set_datalen(uint16_t len);

int packetbuf_copyfrom(void const *from, uint16_t len);

int packetbuf_copyto(void *to);

int packetbuf_hdralloc(int size);

int packetbuf_hdrreduce(int size);

int packetbuf_set_attr(uint8_t type, packetbuf_attr_t const val);

packetbuf_attr_t packetbuf_attr(uint8_t type);

int packetbuf_set_addr(uint8_t type, linkaddr_t const *addr_0);

linkaddr_t const *packetbuf_addr(uint8_t type);

int packetbuf_holds_broadcast(void);

void packetbuf_attr_clear(void);

void packetbuf_attr_copyto(struct packetbuf_attr *attrs,
                           struct packetbuf_addr *addrs);

void packetbuf_attr_copyfrom(struct packetbuf_attr *attrs,
                             struct packetbuf_addr *addrs);

void queuebuf_init(void);

struct queuebuf *queuebuf_new_from_packetbuf(void);

void queuebuf_update_attr_from_packetbuf(struct queuebuf *buf_0);

void queuebuf_update_from_packetbuf(struct queuebuf *buf_0);

void queuebuf_to_packetbuf(struct queuebuf *b);

void queuebuf_free(struct queuebuf *buf_0);

void *queuebuf_dataptr(struct queuebuf *b);

int queuebuf_datalen(struct queuebuf *b);

linkaddr_t *queuebuf_addr(struct queuebuf *b, uint8_t type);

packetbuf_attr_t queuebuf_attr(struct queuebuf *b, uint8_t type);

void queuebuf_debug_print(void);

int queuebuf_numfree(void);

void stimer_set(struct stimer *t, unsigned long interval);

void stimer_reset(struct stimer *t);

void stimer_restart(struct stimer *t);

int stimer_expired(struct stimer *t);

unsigned long stimer_remaining(struct stimer *t);

unsigned long stimer_elapsed(struct stimer *t);

void uip_nd6_init(void);

int nbr_table_register(nbr_table_t *table, nbr_table_callback *callback_0);

int nbr_table_is_registered(nbr_table_t *table);

nbr_table_item_t *nbr_table_head(nbr_table_t *table);

nbr_table_item_t *nbr_table_next(nbr_table_t *table, nbr_table_item_t *item);

nbr_table_item_t *nbr_table_add_lladdr(nbr_table_t *table,
                                       linkaddr_t const *lladdr,
                                       nbr_table_reason_t reason, void *data);

void *nbr_table_get_from_lladdr(nbr_table_t *table, linkaddr_t const *lladdr);

int nbr_table_remove(nbr_table_t *table, void *item);

int nbr_table_lock(nbr_table_t *table, void *item);

int nbr_table_unlock(nbr_table_t *table, void *item);

linkaddr_t *nbr_table_get_lladdr(nbr_table_t *table, void const *item);

void uip_packetqueue_new(struct uip_packetqueue_handle *handle);

struct uip_packetqueue_packet *uip_packetqueue_alloc(struct uip_packetqueue_handle *handle,
                                                     clock_time_t lifetime);

void uip_packetqueue_free(struct uip_packetqueue_handle *handle);

uint8_t *uip_packetqueue_buf(struct uip_packetqueue_handle *h);

uint16_t uip_packetqueue_buflen(struct uip_packetqueue_handle *h);

void uip_packetqueue_set_buflen(struct uip_packetqueue_handle *h,
                                uint16_t len);

void uip_ds6_neighbors_init(void);

uip_ds6_nbr_t *uip_ds6_nbr_add(uip_ipaddr_t const *ipaddr,
                               uip_lladdr_t const *lladdr, uint8_t isrouter,
                               uint8_t state, nbr_table_reason_t reason,
                               void *data);

int uip_ds6_nbr_rm(uip_ds6_nbr_t *nbr_0);

uip_lladdr_t const *uip_ds6_nbr_get_ll(uip_ds6_nbr_t const *nbr_0);

uip_lladdr_t const *uip_ds6_nbr_lladdr_from_ipaddr(uip_ipaddr_t const *ipaddr);

int uip_ds6_nbr_update_ll(uip_ds6_nbr_t **nbr_pp,
                          uip_lladdr_t const *new_ll_addr);

uip_ipaddr_t const *uip_ds6_nbr_get_ipaddr(uip_ds6_nbr_t const *nbr_0);

uip_ipaddr_t *uip_ds6_nbr_ipaddr_from_lladdr(uip_lladdr_t const *lladdr);

uip_ds6_nbr_t *uip_ds6_nbr_lookup(uip_ipaddr_t const *ipaddr);

uip_ds6_nbr_t *uip_ds6_nbr_ll_lookup(uip_lladdr_t const *lladdr);

int uip_ds6_nbr_num(void);

uip_ds6_nbr_t *uip_ds6_nbr_head(void);

uip_ds6_nbr_t *uip_ds6_nbr_next(uip_ds6_nbr_t *nbr_0);

void uip_ds6_link_callback(int status, int numtx);

void list_init(list_t list);

void *list_head(list_t list);

void *list_tail(list_t list);

void *list_pop(list_t list);

void list_push(list_t list, void *item);

void *list_chop(list_t list);

void list_add(list_t list, void *item);

void list_remove(list_t list, void *item);

int list_length(list_t list);

void list_copy(list_t dest, list_t src);

void list_insert(list_t list, void *previtem, void *newitem);

void *list_item_next(void *item);

_Bool list_contains(list_t list, void *item);

void uip_ds6_route_init(void);

uip_ds6_defrt_t *uip_ds6_defrt_head(void);

uip_ds6_defrt_t *uip_ds6_defrt_add(uip_ipaddr_t const *ipaddr,
                                   unsigned long interval);

void uip_ds6_defrt_rm(uip_ds6_defrt_t *defrt);

uip_ds6_defrt_t *uip_ds6_defrt_lookup(uip_ipaddr_t const *ipaddr);

uip_ipaddr_t const *uip_ds6_defrt_choose(void);

void uip_ds6_defrt_periodic(void);

uip_ds6_route_t *uip_ds6_route_lookup(uip_ipaddr_t const *addr_0);

uip_ds6_route_t *uip_ds6_route_add(uip_ipaddr_t const *ipaddr,
                                   uint8_t length,
                                   uip_ipaddr_t const *nexthop);

void uip_ds6_route_rm(uip_ds6_route_t *route);

void uip_ds6_route_rm_by_nexthop(uip_ipaddr_t const *nexthop);

uip_ipaddr_t const *uip_ds6_route_nexthop(uip_ds6_route_t *route);

int uip_ds6_route_num_routes(void);

uip_ds6_route_t *uip_ds6_route_head(void);

uip_ds6_route_t *uip_ds6_route_next(uip_ds6_route_t *r);

int uip_ds6_route_is_nexthop(uip_ipaddr_t const *ipaddr);

uip_ds6_netif_t uip_ds6_if;

struct etimer uip_ds6_timer_periodic;

uip_ds6_prefix_t uip_ds6_prefix_list[1 + 2];

void uip_ds6_init(void);

void uip_ds6_periodic(void);

uint8_t uip_ds6_list_loop(uip_ds6_element_t *list, uint8_t size,
                          uint16_t elementsize, uip_ipaddr_t *ipaddr,
                          uint8_t ipaddrlen, uip_ds6_element_t **out_element);

uip_ds6_prefix_t *uip_ds6_prefix_add(uip_ipaddr_t *ipaddr, uint8_t ipaddrlen,
                                     uint8_t advertise, uint8_t flags,
                                     unsigned long vtime, unsigned long ptime);

void uip_ds6_prefix_rm(uip_ds6_prefix_t *prefix);

uip_ds6_prefix_t *uip_ds6_prefix_lookup(uip_ipaddr_t *ipaddr,
                                        uint8_t ipaddrlen);

uint8_t uip_ds6_is_addr_onlink(uip_ipaddr_t *ipaddr);

uip_ip6addr_t const *uip_ds6_default_prefix(void);

void uip_ds6_set_default_prefix(uip_ip6addr_t const *prefix);

uip_ds6_addr_t *uip_ds6_addr_add(uip_ipaddr_t *ipaddr,
                                 unsigned long vlifetime, uint8_t type);

void uip_ds6_addr_rm(uip_ds6_addr_t *addr_0);

uip_ds6_addr_t *uip_ds6_addr_lookup(uip_ipaddr_t *ipaddr);

uip_ds6_addr_t *uip_ds6_get_link_local(int8_t state);

uip_ds6_addr_t *uip_ds6_get_global(int8_t state);

uip_ds6_maddr_t *uip_ds6_maddr_add(uip_ipaddr_t const *ipaddr);

void uip_ds6_maddr_rm(uip_ds6_maddr_t *maddr);

uip_ds6_maddr_t *uip_ds6_maddr_lookup(uip_ipaddr_t const *ipaddr);

uip_ds6_aaddr_t *uip_ds6_aaddr_add(uip_ipaddr_t *ipaddr);

void uip_ds6_aaddr_rm(uip_ds6_aaddr_t *aaddr);

uip_ds6_aaddr_t *uip_ds6_aaddr_lookup(uip_ipaddr_t *ipaddr);

void uip_ds6_set_addr_iid(uip_ipaddr_t *ipaddr, uip_lladdr_t *lladdr);

void uip_ds6_set_lladdr_from_iid(uip_lladdr_t *lladdr,
                                 uip_ipaddr_t const *ipaddr);

uint8_t get_match_length(uip_ipaddr_t *src, uip_ipaddr_t *dst);

void uip_ds6_select_src(uip_ipaddr_t *src, uip_ipaddr_t *dst);

uint32_t uip_ds6_compute_reachable_time(void);

int curr_log_level_rpl;

int curr_log_level_tcpip;

int curr_log_level_ipv6;

int curr_log_level_6lowpan;

int curr_log_level_nullnet;

int curr_log_level_mac;

int curr_log_level_framer;

int curr_log_level_6top;

int curr_log_level_coap;

int curr_log_level_lwm2m;

int curr_log_level_main;

struct log_module all_modules[12];

void log_6addr(uip_ipaddr_t const *ipaddr);

void log_6addr_compact(uip_ipaddr_t const *ipaddr);

int log_6addr_compact_snprint(char *buf_0, size_t size,
                              uip_ipaddr_t const *ipaddr);

void log_lladdr(linkaddr_t const *lladdr);

void log_lladdr_compact(linkaddr_t const *lladdr);

void log_set_level(char const *module, int level);

int log_get_level(char const *module);

char const *log_level_to_str(int level);

static struct select_callback const *select_callback[8];
static int select_max = 0;
static uint8_t mac_addr[8] =
  {(unsigned char)0x01,
   (unsigned char)0x02,
   (unsigned char)0x03,
   (unsigned char)0x04,
   (unsigned char)0x05,
   (unsigned char)0x06,
   (unsigned char)0x07,
   (unsigned char)0x08};
int select_set_callback(int fd, struct select_callback const *callback_0)
{
  int __retres;
  int i;
  if (fd >= 0) 
    if (fd < 8) {
      if (callback_0 != (struct select_callback const *)0) 
        if (callback_0->set_fd == (int (*)(fd_set *fdr, fd_set *fdw))0) 
          goto _LOR;
        else 
          if (callback_0->handle_fd == (void (*)(fd_set *fdr, fd_set *fdw))0) 
            _LOR:
            callback_0 = (struct select_callback const *)0;
      select_callback[fd] = callback_0;
      if (callback_0 != (struct select_callback const *)0) {
        if (fd > select_max) select_max = fd;
      }
      else {
        select_max = 0;
        i = 8 - 1;
        while (i > 0) {
          if (select_callback[i] != (struct select_callback const *)0) {
            select_max = i;
            break;
          }
          i --;
        }
      }
      __retres = 1;
      goto return_label;
    }
  __retres = 0;
  return_label: return __retres;
}

static int (*input_handler)(unsigned char c);

static void stdin_handle_fd(fd_set *rset, fd_set *wset)
{
  char c;
  if ((rset->__fds_bits[0] & (long)(1UL) != (long)0)) {
    ssize_t tmp;
    tmp = read(0,(void *)(& c),(unsigned long)1);
    if (tmp > (ssize_t)0) (*input_handler)((unsigned char)c);
  }
  return;
}


static int stdin_set_fd(fd_set *rset, fd_set *wset)
{
  int __retres;
  rset->__fds_bits[0 / (8 * (int)sizeof(__fd_mask))] |= (long)(1UL << 
                                                               0 % (8 * (int)sizeof(__fd_mask)));
  __retres = 1;
  return __retres;
}


void native_uart_set_input(int (*input_1)(unsigned char c))
{
  input_handler = input_1;
  return;
}


static struct select_callback const stdin_fd =
  {.set_fd = & stdin_set_fd, .handle_fd = & stdin_handle_fd};
static void set_lladdr(void)
{
  linkaddr_t addr_0;
  memset((void *)(& addr_0),0,sizeof(linkaddr_t));
  memcpy((void *)(addr_0.u8),(void const *)(mac_addr),sizeof(addr_0.u8));
  linkaddr_set_node_addr(& addr_0);
  return;
}

static void set_global_address(void)
{
  uip_ipaddr_t ipaddr;
  uip_ipaddr_t const *default_prefix_0 = uip_ds6_default_prefix();
  ipaddr = *((uip_ip6addr_t *)default_prefix_0);
  uip_ds6_set_addr_iid(& ipaddr,& uip_lladdr);
  uip_ds6_addr_add(& ipaddr,(unsigned long)0,(unsigned char)1);
  {
    int tmp_0;
    if (3 < curr_log_level_main) tmp_0 = 3; else tmp_0 = curr_log_level_main;
    if (3 <= tmp_0) {
      printf("[%-4s: %-10s] ","INFO","Native");
      printf("Added global IPv6 address ");
    }
  }
  {
    int tmp_1;
    if (3 < curr_log_level_main) tmp_1 = 3; else tmp_1 = curr_log_level_main;
    if (3 <= tmp_1) log_6addr((uip_ipaddr_t const *)(& ipaddr));
  }
  {
    int tmp_2;
    if (3 < curr_log_level_main) tmp_2 = 3; else tmp_2 = curr_log_level_main;
    if (3 <= tmp_2) printf("\n");
  }
  ipaddr = *((uip_ip6addr_t *)default_prefix_0);
  ipaddr.u8[15] = (unsigned char)1;
  uip_ds6_defrt_add((uip_ipaddr_t const *)(& ipaddr),(unsigned long)0);
  return;
}

int contiki_argc = 0;
char **contiki_argv;
void platform_process_args(int argc, char **argv)
{
  contiki_argc = argc;
  contiki_argv = argv;
  return;
}

void platform_init_stage_one(void)
{
  gpio_hal_init();
  button_hal_init();
  leds_init();
  return;
}

void platform_init_stage_two(void)
{
  set_lladdr();
  serial_line_init();
  if ((int (*)(unsigned char c))0 == input_handler) native_uart_set_input
                                                    (& serial_line_input_byte);
  return;
}

void platform_init_stage_three(void)
{
  set_global_address();
  setvbuf(stdout,(char *)0,2,(unsigned long)0);
  return;
}

void platform_main_loop(void)
{
  select_set_callback(0,& stdin_fd);
  while (1) {
    {
      fd_set fdr;
      fd_set fdw;
      int maxfd;
      int i;
      int retval;
      struct timeval tv;
      retval = process_run();
      tv.tv_sec = (long)0;
      if (retval) tv.tv_usec = (long)1; else tv.tv_usec = (long)1000;
      {
        unsigned int __i;
        fd_set *__arr = & fdr;
        __i = (unsigned int)0;
        while ((unsigned long)__i < sizeof(fd_set) / sizeof(__fd_mask)) {
          __arr->__fds_bits[__i] = (long)0;
          __i ++;
        }
      }
      {
        unsigned int __i_0;
        fd_set *__arr_0 = & fdw;
        __i_0 = (unsigned int)0;
        while ((unsigned long)__i_0 < sizeof(fd_set) / sizeof(__fd_mask)) {
          __arr_0->__fds_bits[__i_0] = (long)0;
          __i_0 ++;
        }
      }
      maxfd = 0;
      i = 0;
      while (i <= select_max) {
        if (select_callback[i] != (struct select_callback const *)0) {
          int tmp;
          tmp = (*((select_callback[i])->set_fd))(& fdr,& fdw);
          if (tmp) maxfd = i;
        }
        i ++;
      }
      retval = select(maxfd + 1,& fdr,& fdw,(fd_set *)0,& tv);
      if (retval < 0) {
        int *tmp_0;
        tmp_0 = __errno_location();
        ;
        if (*tmp_0 != 4) perror("select");
      }
      else 
        if (retval > 0) {
          i = 0;
          while (i <= maxfd) {
            if (select_callback[i] != (struct select_callback const *)0) 
              (*((select_callback[i])->handle_fd))(& fdr,& fdw);
            i ++;
          }
        }
      etimer_request_poll();
    }
  }
  return;
}

void log_message(char *m1, char *m2)
{
  fprintf(stderr,"%s%s\n",m1,m2);
  return;
}

void uip_log(char *m)
{
  fprintf(stderr,"%s\n",m);
  return;
}

__inline static unsigned int __bswap_32_0(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_0(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id,
                                                       struct timespec *__tp) __attribute__((
__leaf__));

extern  __attribute__((__nothrow__)) int setitimer(__itimer_which_t __which,
                                                   struct itimerval const * __restrict __new,
                                                   struct itimerval * __restrict __old) __attribute__((
__leaf__));

static void get_time(clock_timespec_t *spec)
{
  struct timespec ts;
  clock_gettime(1,& ts);
  spec->tv_sec = ts.tv_sec;
  spec->tv_nsec = ts.tv_nsec;
  return;
}

clock_time_t clock_time(void)
{
  clock_time_t __retres;
  clock_timespec_t ts;
  get_time(& ts);
  __retres = (unsigned long)(ts.tv_sec * (time_t)1000 + ts.tv_nsec / (long)(
                                                        1000000000 / 1000));
  return __retres;
}

unsigned long clock_seconds(void)
{
  unsigned long __retres;
  clock_timespec_t ts;
  get_time(& ts);
  __retres = (unsigned long)ts.tv_sec;
  return __retres;
}

void clock_delay(unsigned int d)
{
  return;
}

void clock_init(void)
{
  return;
}

__inline static unsigned int __bswap_32_1(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_1(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void xmem_init(void);

int xmem_pread(void *buf_0, int size, unsigned long offset);

int xmem_pwrite(void const *buf_0, int size, unsigned long offset);

int xmem_erase(long nbytes, unsigned long offset);

extern int open(char const *__file, int __oflag , ...) __attribute__((
__nonnull__(1)));

static unsigned char xmem[1024 * 1024];
int xmem_pwrite(void const *buf_0, int size, unsigned long offset)
{
  memcpy((void *)(& xmem[offset]),buf_0,(unsigned long)size);
  return size;
}

int xmem_pread(void *buf_0, int size, unsigned long offset)
{
  memcpy(buf_0,(void const *)(& xmem[offset]),(unsigned long)size);
  return size;
}

int xmem_erase(long nbytes, unsigned long offset)
{
  int __retres;
  memset((void *)(& xmem[offset]),0,(unsigned long)nbytes);
  __retres = (int)nbytes;
  return __retres;
}

void xmem_init(void)
{
  return;
}

__inline static unsigned int __bswap_32_2(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_2(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

int cfs_open(char const *n, int f);

void cfs_close(int f);

int cfs_read(int f, void *b, unsigned int l);

int cfs_write(int f, void const *b, unsigned int l);

cfs_offset_t cfs_seek(int f, cfs_offset_t o, int w);

int cfs_remove(char const *name);

int cfs_opendir(struct cfs_dir *p, char const *n);

int cfs_readdir(struct cfs_dir *p, struct cfs_dirent *e);

void cfs_closedir(struct cfs_dir *p);

int cfs_open(char const *n, int f)
{
  int __retres;
  int s = 0;
  if (f == 1) {
    int tmp;
    tmp = open(n,00);
    __retres = tmp;
    goto return_label;
  }
  else 
    if (f & 2) {
      int tmp_0;
      s = 0100;
      if (f & 1) s |= 02; else s |= 01;
      if (f & 4) s |= 02000; else s |= 01000;
      tmp_0 = open(n,s,0600);
      __retres = tmp_0;
      goto return_label;
    }
  __retres = -1;
  return_label: return __retres;
}

void cfs_close(int f)
{
  close(f);
  return;
}

int cfs_read(int f, void *b, unsigned int l)
{
  int __retres;
  ssize_t tmp;
  tmp = read(f,b,(unsigned long)l);
  __retres = (int)tmp;
  return __retres;
}

int cfs_write(int f, void const *b, unsigned int l)
{
  int __retres;
  ssize_t tmp;
  tmp = write(f,b,(unsigned long)l);
  __retres = (int)tmp;
  return __retres;
}

cfs_offset_t cfs_seek(int f, cfs_offset_t o, int w)
{
  cfs_offset_t __retres;
  __off_t tmp;
  if (w == 0) w = 0;
  else 
    if (w == 1) w = 1;
    else 
      if (w == 2) w = 2;
      else {
        __retres = -1;
        goto return_label;
      }
  tmp = lseek(f,(long)o,w);
  __retres = (int)tmp;
  return_label: return __retres;
}

int cfs_remove(char const *name)
{
  int tmp;
  tmp = remove(name);
  return tmp;
}

extern DIR *opendir(char const *__name) __attribute__((__nonnull__(1)));

extern int closedir(DIR *__dirp) __attribute__((__nonnull__(1)));

extern struct dirent *readdir(DIR *__dirp) __attribute__((__nonnull__(1)));

__inline static unsigned int __bswap_32_3(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_3(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

int cfs_opendir(struct cfs_dir *p, char const *n)
{
  int __retres;
  struct cfs_posix_dir *dir = (struct cfs_posix_dir *)p;
  dir->dirp = opendir(n);
  __retres = dir->dirp == (DIR *)0;
  return __retres;
}

int cfs_readdir(struct cfs_dir *p, struct cfs_dirent *e)
{
  int __retres;
  struct dirent *res;
  struct cfs_posix_dir *dir = (struct cfs_posix_dir *)p;
  if (dir->dirp == (DIR *)0) {
    __retres = -1;
    goto return_label;
  }
  res = readdir(dir->dirp);
  if (res == (struct dirent *)0) {
    __retres = -1;
    goto return_label;
  }
  strncpy(e->name,(char const *)(res->d_name),sizeof(e->name));
  e->name[sizeof(e->name) - (unsigned long)1] = (char)'\000';
  e->size = 0;
  __retres = 0;
  return_label: return __retres;
}

void cfs_closedir(struct cfs_dir *p)
{
  struct cfs_posix_dir *dir = (struct cfs_posix_dir *)p;
  if (dir->dirp != (DIR *)0) closedir(dir->dirp);
  return;
}

__inline static unsigned int __bswap_32_4(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_4(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

button_hal_button_t *button_hal_buttons[1] = {(button_hal_button_t *)0};
uint8_t const button_hal_button_count = (unsigned char)0;
__inline static unsigned int __bswap_32_5(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_5(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

extern  __attribute__((__nothrow__)) int rand(void) __attribute__((__leaf__));

extern  __attribute__((__nothrow__)) void srand(unsigned int __seed) __attribute__((
__leaf__));

extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) __attribute__((
__leaf__));

extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void)) __attribute__((
__nonnull__(1), __leaf__));

extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status) __attribute__((
__leaf__));

extern  __attribute__((__nothrow__)) char *getenv(char const *__name) __attribute__((
__nonnull__(1), __leaf__));

extern int system(char const *__command);

extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig,
                                                           void (*__handler)(
                                                           int )) __attribute__((
__leaf__));

extern  __attribute__((__nothrow__)) int ioctl(int __fd,
                                               unsigned long __request , ...) __attribute__((
__leaf__));

extern  __attribute__((__noreturn__)) void ( /* format attribute */ err)(
int __status, char const *__format , ...);

static char const *config_ipaddr = "fd00::1/64";
static char config_tundev[64] =
  {(char)'t', (char)'u', (char)'n', (char)'0', (char)'\000'};
static int tunfd = -1;
static int set_fd(fd_set *rset, fd_set *wset);

static void handle_fd(fd_set *rset, fd_set *wset);

static struct select_callback const tun_select_callback =
  {.set_fd = & set_fd, .handle_fd = & handle_fd};
static int ( /* format attribute */ ssystem)(char const *fmt , ...);

static int ( /* format attribute */ ssystem)(char const *fmt , ...)
{
  char cmd[128];
  va_list ap;
  int tmp;
  __builtin_va_start(ap,fmt);
  vsnprintf(cmd,sizeof(cmd),fmt,ap);
  __builtin_va_end(ap);
  if (3 <= 2) {
    printf("[%-4s: %-10s] ","INFO","Tun6");
    printf("%s\n",cmd);
  }
  fflush(stdout);
  tmp = system((char const *)(cmd));
  return tmp;
}

static void cleanup(void)
{
  ssystem("ifconfig %s down",config_tundev);
  ssystem("netstat -nr | awk \'{ if ($2 == \"%s\") print \"route delete -net \"$1; }\' | sh",
          config_tundev);
  return;
}

static void sigcleanup(int signo)
{
  fprintf(stderr,"signal %d\n",signo);
  exit(0);
  return;
}

static void ifconf(char const *tundev, char const *ipaddr)
{
  ssystem("ifconfig %s inet `hostname` up",tundev);
  ssystem("ifconfig %s add %s",tundev,ipaddr);
  ssystem("ifconfig %s\n",tundev);
  return;
}

static int tun_alloc(char *dev)
{
  int __retres;
  struct ifreq ifr;
  int fd;
  int err_0;
  size_t tmp;
  if (3 <= 2) {
    printf("[%-4s: %-10s] ","INFO","Tun6");
    printf("Opening: %s\n",dev);
  }
  fd = open("/dev/net/tun",02);
  if (fd < 0) {
    __retres = -1;
    goto return_label;
  }
  memset((void *)(& ifr),0,sizeof(ifr));
  ifr.ifr_ifru.ifru_flags = (short)(0x0001 | 0x1000);
  if ((int)*dev != 0) {
    strncpy(ifr.ifr_ifrn.ifrn_name,(char const *)dev,(unsigned long)16);
    ifr.ifr_ifrn.ifrn_name[16 - 1] = (char)'\000';
  }
  err_0 = ioctl(fd,
                (unsigned long)(((1U << (((0 + 8) + 8) + 14)) | (unsigned int)(
                                 'T' << (0 + 8))) | (unsigned int)(202 << 0)) | (
                sizeof(int) << ((0 + 8) + 8)),(void *)(& ifr));
  if (err_0 < 0) {
    close(fd);
    __retres = err_0;
    goto return_label;
  }
  if (3 <= 2) {
    printf("[%-4s: %-10s] ","INFO","Tun6");
    printf("Using \'%s\' vs \'%s\'\n",dev,ifr.ifr_ifrn.ifrn_name);
  }
  tmp = strlen((char const *)dev);
  ;
  ;
  strncpy(dev,(char const *)(ifr.ifr_ifrn.ifrn_name),tmp);
  if (3 <= 2) {
    printf("[%-4s: %-10s] ","INFO","Tun6");
    printf("Using %s\n",dev);
  }
  __retres = fd;
  return_label: return __retres;
}

static void tun_init(void)
{
  setvbuf(stdout,(char *)0,1,(unsigned long)0);
  if (3 <= 2) {
    printf("[%-4s: %-10s] ","INFO","Tun6");
    printf("Initializing tun interface\n");
  }
  tunfd = tun_alloc(config_tundev);
  if (tunfd == -1) {
    if (2 <= 2) {
      printf("[%-4s: %-10s] ","WARN","Tun6");
      printf("Failed to open tun device (you may be lacking permission). Running without network.\n");
    }
    goto return_label;
  }
  if (3 <= 2) {
    printf("[%-4s: %-10s] ","INFO","Tun6");
    printf("Tun open:%d\n",tunfd);
  }
  select_set_callback(tunfd,& tun_select_callback);
  fprintf(stderr,"opened %s device ``/dev/%s\'\'\n","tun",config_tundev);
  atexit(& cleanup);
  signal(1,& sigcleanup);
  signal(15,& sigcleanup);
  signal(2,& sigcleanup);
  ifconf((char const *)(config_tundev),config_ipaddr);
  return_label: return;
}

static int tun_output(uint8_t *data, int len)
{
  int __retres;
  if (tunfd != -1) {
    ssize_t tmp;
    tmp = write(tunfd,(void const *)data,(unsigned long)len);
    ;
    if (tmp != (ssize_t)len) {
      err(1,"serial_to_tun: write");
      __retres = -1;
      goto return_label;
    }
  }
  __retres = 0;
  return_label: return __retres;
}

static int tun_input(unsigned char *data, int maxlen)
{
  int __retres;
  int size;
  ssize_t tmp;
  if (tunfd == -1) {
    __retres = 0;
    goto return_label;
  }
  tmp = read(tunfd,(void *)data,(unsigned long)maxlen);
  size = (int)tmp;
  if (size == -1) err(1,"tun_input: read");
  __retres = size;
  return_label: return __retres;
}

static uint8_t output(linkaddr_t const *localdest)
{
  uint8_t __retres;
  if (4 <= 2) {
    printf("[%-4s: %-10s] ","DBG","Tun6");
    printf("SUT: %u\n",(int)uip_len);
  }
  if ((int)uip_len > 0) {
    int tmp;
    tmp = tun_output(uip_aligned_buf.u8,(int)uip_len);
    __retres = (unsigned char)tmp;
    goto return_label;
  }
  __retres = (unsigned char)0;
  return_label: return __retres;
}

static int set_fd(fd_set *rset, fd_set *wset)
{
  int __retres;
  if (tunfd == -1) {
    __retres = 0;
    goto return_label;
  }
  rset->__fds_bits[tunfd / (8 * (int)sizeof(__fd_mask))] |= (long)(1UL << 
                                                                   tunfd % (
                                                                   8 * (int)sizeof(__fd_mask)));
  __retres = 1;
  return_label: return __retres;
}

static void handle_fd(fd_set *rset, fd_set *wset)
{
  int size;
  if (tunfd == -1) goto return_label;
  if (3 <= 2) {
    printf("[%-4s: %-10s] ","INFO","Tun6");
    printf("Tun6-handle FD\n");
  }
  if ((rset->__fds_bits[tunfd / (8 * (int)sizeof(__fd_mask))] & (long)(
       1UL << tunfd % (8 * (int)sizeof(__fd_mask)))) != (long)0) {
    size = tun_input(uip_aligned_buf.u8,(int)sizeof(uip_aligned_buf.u8));
    if (4 <= 2) {
      printf("[%-4s: %-10s] ","DBG","Tun6");
      printf("TUN data incoming read:%d\n",size);
    }
    uip_len = (unsigned short)size;
    tcpip_input();
  }
  return_label: return;
}

static void input(void)
{
  if (4 <= 2) {
    printf("[%-4s: %-10s] ","DBG","Tun6");
    printf("Tun6 - input\n");
  }
  return;
}

struct network_driver const tun6_net_driver =
  {.name = (char *)"tun6",
   .init = & tun_init,
   .input = & input,
   .output = & output};
__inline static unsigned int __bswap_32_6(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_6(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static void interrupt(int sig)
{
  signal(sig,& interrupt);
  rtimer_run_next();
  return;
}

void rtimer_arch_init(void)
{
  signal(14,& interrupt);
  return;
}

void rtimer_arch_schedule(rtimer_clock_t t)
{
  struct itimerval val;
  rtimer_clock_t c;
  clock_time_t tmp;
  tmp = clock_time();
  c = t - (rtimer_clock_t)((unsigned short)tmp);
  val.it_value.tv_sec = (long)(c / (rtimer_clock_t)1000);
  val.it_value.tv_usec = (long)((c % (unsigned int)1000) * (unsigned int)1000);
  val.it_interval.tv_usec = (long)0;
  val.it_interval.tv_sec = val.it_interval.tv_usec;
  setitimer(ITIMER_REAL,(struct itimerval const *)(& val),
            (struct itimerval *)0);
  return;
}

__inline static unsigned int __bswap_32_7(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_7(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void watchdog_init(void)
{
  return;
}

void watchdog_start(void)
{
  return;
}

void watchdog_periodic(void)
{
  return;
}

void watchdog_stop(void)
{
  return;
}

void watchdog_reboot(void)
{
  exit(-1);
  return;
}

__inline static unsigned int __bswap_32_8(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_8(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void eeprom_write(eeprom_addr_t addr_0, unsigned char *buf_0, int size);

void eeprom_read(eeprom_addr_t addr_0, unsigned char *buf_0, int size);

void eeprom_init(void);

static FILE *eeprom_file;
static void eeprom_fill(eeprom_addr_t addr_0, unsigned char value, int size)
{
  if ((int)addr_0 > 1024 - 1) goto _LOR;
  else 
    if ((int)addr_0 + size > (1024 - 1) + 1) goto _LOR;
    else 
      if (size < 0) {
        _LOR:
        {
          fprintf(stderr,
                  "eeprom_fill: Bad address and/or size (addr = %04x, size = %d)\n",
                  (int)addr_0,size);
          abort();
        }
      }
  if (! eeprom_file) eeprom_init();
  fseek(eeprom_file,(long)addr_0,0);
  while (1) {
    int tmp_0;
    tmp_0 = size;
    size --;
    ;
    if (! tmp_0) break;
    {
      int tmp;
      tmp = fputc((int)value,eeprom_file);
      ;
      if (tmp != (int)value) {
        perror("fputc() failed");
        exit(1);
      }
    }
  }
  return;
}

void eeprom_init(void)
{
  long length;
  char *eeprom_filename = getenv("CONTIKI_EEPROM");
  if (eeprom_filename) {
    eeprom_file = fopen((char const *)eeprom_filename,"r+");
    if (! eeprom_file) {
      eeprom_file = fopen((char const *)eeprom_filename,"w+");
      if (! eeprom_file) {
        perror("Unable to create EEPROM file");
        exit(1);
      }
    }
    fprintf(stderr,"eeprom_init: Using \"%s\".\n",eeprom_filename);
  }
  else {
    eeprom_file = tmpfile();
    if (! eeprom_file) {
      perror("Unable to create temporary EEPROM file");
      exit(1);
    }
  }
  fseek(eeprom_file,(long)0,2);
  length = ftell(eeprom_file);
  if (length < (long)0) {
    perror("ftell failed");
    exit(1);
  }
  if (length < (long)(1024 - 1)) eeprom_fill((unsigned short)length,
                                             (unsigned char)0xFF,
                                             (int)((long)1024 - length));
  return;
}

void eeprom_write(eeprom_addr_t addr_0, unsigned char *buf_0, int size)
{
  size_t tmp;
  if ((int)addr_0 > 1024 - 1) goto _LOR;
  else 
    if ((int)addr_0 + size > (1024 - 1) + 1) goto _LOR;
    else 
      if (size < 0) {
        _LOR:
        {
          fprintf(stderr,
                  "eeprom_write: Bad address and/or size (addr = %04x, size = %d)\n",
                  (int)addr_0,size);
          abort();
        }
      }
  if (! eeprom_file) eeprom_init();
  fseek(eeprom_file,(long)addr_0,0);
  tmp = fwrite((void const *)buf_0,(unsigned long)1,(unsigned long)size,
               eeprom_file);
  ;
  if (tmp != (size_t)size) {
    perror("fwrite() failed");
    exit(1);
  }
  return;
}

void eeprom_read(eeprom_addr_t addr_0, unsigned char *buf_0, int size)
{
  size_t tmp;
  if ((int)addr_0 > 1024 - 1) goto _LOR;
  else 
    if ((int)addr_0 + size > (1024 - 1) + 1) goto _LOR;
    else 
      if (size < 0) {
        _LOR:
        {
          fprintf(stderr,
                  "eeprom_read: Bad address and/or size (addr = %04x, size = %d)\n",
                  (int)addr_0,size);
          abort();
        }
      }
  if (! eeprom_file) eeprom_init();
  fseek(eeprom_file,(long)addr_0,0);
  tmp = fread((void *)buf_0,(unsigned long)1,(unsigned long)size,eeprom_file);
  ;
  if (tmp != (size_t)size) {
    perror("fread() failed");
    exit(1);
  }
  return;
}

__inline static unsigned int __bswap_32_9(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_9(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void int_master_enable(void);

int_master_status_t int_master_read_and_disable(void);

void int_master_status_set(int_master_status_t status);

_Bool int_master_is_enabled(void);

static int_master_status_t stat = (unsigned int)0;
void int_master_enable(void)
{
  stat = (unsigned int)1;
  return;
}

int_master_status_t int_master_read_and_disable(void)
{
  int_master_status_t rv = stat;
  stat = (unsigned int)0;
  return rv;
}

void int_master_status_set(int_master_status_t status)
{
  stat = status;
  return;
}

_Bool int_master_is_enabled(void)
{
  _Bool __retres;
  int tmp;
  if (stat == (int_master_status_t)0) tmp = 0; else tmp = 1;
  __retres = (_Bool)(tmp != 0);
  return __retres;
}

__inline static unsigned int __bswap_32_10(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_10(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static gpio_hal_pin_cfg_t pin_cfg[32];
static uint8_t pin_state[32];
void gpio_hal_arch_init(void)
{
  return;
}

void gpio_hal_arch_no_port_interrupt_enable(gpio_hal_pin_t pin)
{
  if ((int)pin >= 32) {
    if (1 <= 0) {
      printf("[%-4s: %-10s] ","ERR","GPIO arch");
      printf("Pin %u out of bounds\n",(int)pin);
    }
    goto return_label;
  }
  if (4 <= 0) {
    printf("[%-4s: %-10s] ","DBG","GPIO arch");
    printf("Pin %u: Enabled interrupt\n",(int)pin);
  }
  return_label: return;
}

void gpio_hal_arch_no_port_interrupt_disable(gpio_hal_pin_t pin)
{
  if ((int)pin >= 32) {
    if (1 <= 0) {
      printf("[%-4s: %-10s] ","ERR","GPIO arch");
      printf("Pin %u out of bounds\n",(int)pin);
    }
    goto return_label;
  }
  if (4 <= 0) {
    printf("[%-4s: %-10s] ","DBG","GPIO arch");
    printf("Pin %u: Disabled interrupt\n",(int)pin);
  }
  return_label: return;
}

void gpio_hal_arch_no_port_pin_cfg_set(gpio_hal_pin_t pin,
                                       gpio_hal_pin_cfg_t cfg)
{
  if ((int)pin >= 32) {
    if (1 <= 0) {
      printf("[%-4s: %-10s] ","ERR","GPIO arch");
      printf("Pin %u out of bounds\n",(int)pin);
    }
    goto return_label;
  }
  pin_cfg[pin] = cfg;
  if (4 <= 0) {
    printf("[%-4s: %-10s] ","DBG","GPIO arch");
    printf("Pin %u: Set config=0x%02x\n",(int)pin,pin_cfg[pin]);
  }
  return_label: return;
}

gpio_hal_pin_cfg_t gpio_hal_arch_no_port_pin_cfg_get(gpio_hal_pin_t pin)
{
  gpio_hal_pin_cfg_t __retres;
  if ((int)pin >= 32) {
    if (1 <= 0) {
      printf("[%-4s: %-10s] ","ERR","GPIO arch");
      printf("Pin %u out of bounds\n",(int)pin);
    }
    __retres = (unsigned int)0;
    goto return_label;
  }
  if (4 <= 0) {
    printf("[%-4s: %-10s] ","DBG","GPIO arch");
    printf("Pin %u: Config=0x%02x\n",(int)pin,pin_cfg[pin]);
  }
  __retres = pin_cfg[pin];
  return_label: return __retres;
}

void gpio_hal_arch_no_port_pin_set_input(gpio_hal_pin_t pin)
{
  if ((int)pin >= 32) {
    if (1 <= 0) {
      printf("[%-4s: %-10s] ","ERR","GPIO arch");
      printf("Pin %u out of bounds\n",(int)pin);
    }
    goto return_label;
  }
  if (4 <= 0) {
    printf("[%-4s: %-10s] ","DBG","GPIO arch");
    printf("Pin %u: Set input\n",(int)pin);
  }
  return_label: return;
}

void gpio_hal_arch_no_port_pin_set_output(gpio_hal_pin_t pin)
{
  if ((int)pin >= 32) {
    if (1 <= 0) {
      printf("[%-4s: %-10s] ","ERR","GPIO arch");
      printf("Pin %u out of bounds\n",(int)pin);
    }
    goto return_label;
  }
  if (4 <= 0) {
    printf("[%-4s: %-10s] ","DBG","GPIO arch");
    printf("Pin %u: Set output\n",(int)pin);
  }
  return_label: return;
}

void gpio_hal_arch_no_port_set_pin(gpio_hal_pin_t pin)
{
  if ((int)pin >= 32) {
    if (1 <= 0) {
      printf("[%-4s: %-10s] ","ERR","GPIO arch");
      printf("Pin %u out of bounds\n",(int)pin);
    }
    goto return_label;
  }
  pin_state[pin] = (unsigned char)1;
  if (4 <= 0) {
    printf("[%-4s: %-10s] ","DBG","GPIO arch");
    printf("Pin %u: Set\n",(int)pin);
  }
  return_label: return;
}

void gpio_hal_arch_no_port_clear_pin(gpio_hal_pin_t pin)
{
  if ((int)pin >= 32) {
    if (1 <= 0) {
      printf("[%-4s: %-10s] ","ERR","GPIO arch");
      printf("Pin %u out of bounds\n",(int)pin);
    }
    goto return_label;
  }
  pin_state[pin] = (unsigned char)0;
  if (4 <= 0) {
    printf("[%-4s: %-10s] ","DBG","GPIO arch");
    printf("Pin %u: Clear\n",(int)pin);
  }
  return_label: return;
}

uint8_t gpio_hal_arch_no_port_read_pin(gpio_hal_pin_t pin)
{
  uint8_t __retres;
  if ((int)pin >= 32) {
    if (1 <= 0) {
      printf("[%-4s: %-10s] ","ERR","GPIO arch");
      printf("Pin %u out of bounds\n",(int)pin);
    }
    __retres = (unsigned char)0;
    goto return_label;
  }
  if (4 <= 0) {
    printf("[%-4s: %-10s] ","DBG","GPIO arch");
    printf("Pin %u: Read=%u\n",(int)pin,(int)pin_state[pin]);
  }
  __retres = pin_state[pin];
  return_label: return __retres;
}

void gpio_hal_arch_no_port_write_pin(gpio_hal_pin_t pin, uint8_t value)
{
  if ((int)pin >= 32) {
    if (1 <= 0) {
      printf("[%-4s: %-10s] ","ERR","GPIO arch");
      printf("Pin %u out of bounds\n",(int)pin);
    }
    goto return_label;
  }
  pin_state[pin] = value;
  if (4 <= 0) {
    printf("[%-4s: %-10s] ","DBG","GPIO arch");
    printf("Pin %u: Write=%u\n",(int)pin,(int)pin_state[pin]);
  }
  return_label: return;
}

void gpio_hal_arch_no_port_set_pins(gpio_hal_pin_mask_t pins)
{
  gpio_hal_pin_t pin;
  pin = (unsigned char)0;
  while ((int)pin < 32) {
    if (pins & (unsigned int)(1 << (int)pin)) pin_state[pin] = (unsigned char)1;
    pin = (gpio_hal_pin_t)((int)pin + 1);
  }
  if (4 <= 0) {
    printf("[%-4s: %-10s] ","DBG","GPIO arch");
    printf("Set pins 0x%08x\n",pins);
  }
  return;
}

void gpio_hal_arch_no_port_clear_pins(gpio_hal_pin_mask_t pins)
{
  gpio_hal_pin_t pin;
  pin = (unsigned char)0;
  while ((int)pin < 32) {
    if (pins & (unsigned int)(1 << (int)pin)) pin_state[pin] = (unsigned char)0;
    pin = (gpio_hal_pin_t)((int)pin + 1);
  }
  if (4 <= 0) {
    printf("[%-4s: %-10s] ","DBG","GPIO arch");
    printf("Clear pins 0x%08x\n",pins);
  }
  return;
}

gpio_hal_pin_mask_t gpio_hal_arch_no_port_read_pins(gpio_hal_pin_mask_t pins)
{
  gpio_hal_pin_t pin;
  gpio_hal_pin_mask_t state = (unsigned int)0;
  pin = (unsigned char)0;
  while ((int)pin < 32) {
    state |= (unsigned int)((int)pin_state[pin] << (int)pin);
    pin = (gpio_hal_pin_t)((int)pin + 1);
  }
  if (4 <= 0) {
    printf("[%-4s: %-10s] ","DBG","GPIO arch");
    printf("Read pins 0x%08x\n",state);
  }
  return state;
}

void gpio_hal_arch_no_port_write_pins(gpio_hal_pin_mask_t pins,
                                      gpio_hal_pin_mask_t value)
{
  gpio_hal_pin_t pin;
  pin = (unsigned char)0;
  while ((int)pin < 32) {
    if (pins & (unsigned int)(1 << (int)pin)) 
      if ((value & (unsigned int)(1 << (int)pin)) == (unsigned int)0) 
        pin_state[pin] = (unsigned char)0;
      else pin_state[pin] = (unsigned char)1;
    pin = (gpio_hal_pin_t)((int)pin + 1);
  }
  if (4 <= 0) {
    printf("[%-4s: %-10s] ","DBG","GPIO arch");
    printf("Write pins 0x%08x->0x%08x\n",pins,value);
  }
  return;
}

__inline static unsigned int __bswap_32_11(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_11(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void uip_udp_packet_send(struct uip_udp_conn *c, void const *data, int len);

void uip_udp_packet_sendto(struct uip_udp_conn *c, void const *data, int len,
                           uip_ipaddr_t const *toaddr, uint16_t toport);

int simple_udp_register(struct simple_udp_connection *c, uint16_t local_port,
                        uip_ipaddr_t *remote_addr, uint16_t remote_port,
                        void (*receive_callback)(struct simple_udp_connection *c,
                                                 uip_ipaddr_t const *source_addr,
                                                 uint16_t source_port,
                                                 uip_ipaddr_t const *dest_addr,
                                                 uint16_t dest_port,
                                                 uint8_t const *data,
                                                 uint16_t datalen));

int simple_udp_send(struct simple_udp_connection *c, void const *data,
                    uint16_t datalen);

int simple_udp_sendto(struct simple_udp_connection *c, void const *data,
                      uint16_t datalen, uip_ipaddr_t const *to);

int simple_udp_sendto_port(struct simple_udp_connection *c, void const *data,
                           uint16_t datalen, uip_ipaddr_t const *to,
                           uint16_t port);

void uip_nameserver_update(uip_ipaddr_t const *nameserver, uint32_t lifetime);

uip_ipaddr_t *uip_nameserver_get(uint8_t num);

uint32_t uip_nameserver_next_expiration(void);

uint16_t uip_nameserver_count(void);

int uip_sr_num_nodes(void);

void uip_sr_expire_parent(void *graph, uip_ipaddr_t const *child,
                          uip_ipaddr_t const *parent);

uip_sr_node_t *uip_sr_update_node(void *graph, uip_ipaddr_t const *child,
                                  uip_ipaddr_t const *parent,
                                  uint32_t lifetime);

uip_sr_node_t *uip_sr_node_head(void);

uip_sr_node_t *uip_sr_node_next(uip_sr_node_t *item);

uip_sr_node_t *uip_sr_get_node(void *graph, uip_ipaddr_t const *addr_0);

int uip_sr_is_addr_reachable(void *graph, uip_ipaddr_t const *addr_0);

void uip_sr_periodic(unsigned int seconds);

void uip_sr_init(void);

void uip_sr_free_all(void);

int uip_sr_link_snprint(char *buf_0, int buflen_0, uip_sr_node_t *link_0);

void uip_icmp6_error_output(uint8_t type, uint8_t code, uint32_t param);

void uip_icmp6_send(uip_ipaddr_t const *dest, int type, int code,
                    int payload_len);

void uip_icmp6_echo_reply_callback_add(struct uip_icmp6_echo_reply_notification *n,
                                       void (*c)(uip_ipaddr_t *source,
                                                 uint8_t ttl, uint8_t *data,
                                                 uint16_t datalen));

void uip_icmp6_echo_reply_callback_rm(struct uip_icmp6_echo_reply_notification *n);

uint8_t uip_icmp6_input(uint8_t type, uint8_t icode);

void uip_icmp6_register_input_handler(uip_icmp6_input_handler_t *handler);

void uip_icmp6_init(void);

process_event_t resolv_event_found;

resolv_status_t resolv_lookup(char const *name, uip_ipaddr_t **ipaddr);

void resolv_query(char const *name);

void resolv_set_hostname(char const *hostname);

char const *resolv_get_hostname(void);

struct process resolv_process;

void memb_init(struct memb *m);

void *memb_alloc(struct memb *m);

char memb_free(struct memb *m, void *ptr);

int memb_inmemb(struct memb *m, void *ptr);

int memb_numfree(struct memb *m);

void random_init(unsigned short seed);

unsigned short random_rand(void);

void psock_init(struct psock *psock, uint8_t *buffer, unsigned int buffersize);

char psock_send(struct psock *s, uint8_t const *buf_0, unsigned int len);

char psock_generator_send(struct psock *s,
                          unsigned short (*generate)(void *), void *arg);

char psock_readbuf_len(struct psock *psock, uint16_t len);

char psock_readto(struct psock *psock, unsigned char c);

uint16_t psock_datalen(struct psock *psock);

char psock_newdata(struct psock *s);

int udp_socket_register(struct udp_socket *c, void *ptr,
                        void (*input_callback)(struct udp_socket *c,
                                               void *ptr,
                                               uip_ipaddr_t const *source_addr,
                                               uint16_t source_port,
                                               uip_ipaddr_t const *dest_addr,
                                               uint16_t dest_port,
                                               uint8_t const *data,
                                               uint16_t datalen));

int udp_socket_bind(struct udp_socket *c, uint16_t local_port);

int udp_socket_connect(struct udp_socket *c, uip_ipaddr_t *remote_addr,
                       uint16_t remote_port);

int udp_socket_send(struct udp_socket *c, void const *data, uint16_t datalen);

int udp_socket_sendto(struct udp_socket *c, void const *data,
                      uint16_t datalen, uip_ipaddr_t const *to, uint16_t port);

int udp_socket_close(struct udp_socket *c);

uint16_t node_id;

void node_id_init(void);

void energest_init(void);

void energest_flush(void);

uint64_t energest_get_total_time(void);

__inline static uint64_t energest_type_time(energest_type_t type)
{
  uint64_t __retres;
  __retres = (unsigned long)0;
  return __retres;
}

__inline static void energest_type_set(energest_type_t type, uint64_t time_0)
{
  return;
}

__inline static void energest_on(energest_type_t type)
{
  return;
}

__inline static void energest_off(energest_type_t type)
{
  return;
}

__inline static void energest_switch(energest_type_t type_off,
                                     energest_type_t type_on)
{
  return;
}

void ringbufindex_init(struct ringbufindex *r, uint8_t size);

int ringbufindex_put(struct ringbufindex *r);

int ringbufindex_peek_put(struct ringbufindex const *r);

int ringbufindex_get(struct ringbufindex *r);

int ringbufindex_peek_get(struct ringbufindex const *r);

int ringbufindex_size(struct ringbufindex const *r);

int ringbufindex_elements(struct ringbufindex const *r);

int ringbufindex_full(struct ringbufindex const *r);

int ringbufindex_empty(struct ringbufindex const *r);

static uint8_t __constr_expr_0[4] =
  {(unsigned char)15, (unsigned char)25, (unsigned char)26, (unsigned char)20};
int frame80215e_create_ie_header_ack_nack_time_correction(uint8_t *buf_0,
                                                          int len,
                                                          struct ieee802154_ies *ies);

int frame80215e_create_ie_header_list_termination_1(uint8_t *buf_0, int len,
                                                    struct ieee802154_ies *ies);

int frame80215e_create_ie_header_list_termination_2(uint8_t *buf_0, int len,
                                                    struct ieee802154_ies *ies);

int frame80215e_create_ie_payload_list_termination(uint8_t *buf_0, int len,
                                                   struct ieee802154_ies *ies);

int frame80215e_create_ie_mlme(uint8_t *buf_0, int len,
                               struct ieee802154_ies *ies);

int frame80215e_create_ie_tsch_synchronization(uint8_t *buf_0, int len,
                                               struct ieee802154_ies *ies);

int frame80215e_create_ie_tsch_slotframe_and_link(uint8_t *buf_0, int len,
                                                  struct ieee802154_ies *ies);

int frame80215e_create_ie_tsch_timeslot(uint8_t *buf_0, int len,
                                        struct ieee802154_ies *ies);

int frame80215e_create_ie_tsch_channel_hopping_sequence(uint8_t *buf_0,
                                                        int len,
                                                        struct ieee802154_ies *ies);

int frame802154e_parse_information_elements(uint8_t const *buf_0,
                                            uint8_t buf_size,
                                            struct ieee802154_ies *ies);

__inline static uint8_t tsch_stats_channel_to_index(uint8_t channel)
{
  uint8_t __retres;
  __retres = (unsigned char)((int)channel - 11);
  return __retres;
}

__inline static uint8_t tsch_stats_index_to_channel(uint8_t channel_index)
{
  uint8_t __retres;
  __retres = (unsigned char)((int)channel_index + 11);
  return __retres;
}

uip_ds6_nbr_t *rpl_icmp6_update_nbr_table(uip_ipaddr_t *from,
                                          nbr_table_reason_t reason,
                                          void *data);

void rpl_icmp6_dis_output(uip_ipaddr_t *addr_0);

void rpl_icmp6_dio_output(uip_ipaddr_t *uc_addr);

void rpl_icmp6_dao_output(uint8_t lifetime);

void rpl_icmp6_dao_ack_output(uip_ipaddr_t *dest, uint8_t sequence,
                              uint8_t status);

void rpl_icmp6_init(void);

char const *rpl_dag_state_to_str(enum rpl_dag_state state);

int rpl_dag_get_root_ipaddr(uip_ipaddr_t *ipaddr);

void rpl_dag_poison_and_leave(void);

void rpl_dag_leave(void);

void rpl_dag_periodic(unsigned int seconds);

void rpl_global_repair(char const *str);

void rpl_local_repair(char const *str);

int rpl_is_addr_in_our_dag(uip_ipaddr_t const *addr_0);

void rpl_dag_init_root(uint8_t instance_id, uip_ipaddr_t *dag_id,
                       uip_ipaddr_t *prefix, unsigned int prefix_len,
                       uint8_t prefix_flags);

rpl_instance_t *rpl_get_default_instance(void);

rpl_dag_t *rpl_get_any_dag(void);

int rpl_process_hbh(rpl_nbr_t *sender, uint16_t sender_rank,
                    int loop_detected, int rank_error_signaled);

void rpl_process_dis(uip_ipaddr_t *from, int is_multicast);

void rpl_process_dio(uip_ipaddr_t *from, rpl_dio_t *dio);

void rpl_process_dao(uip_ipaddr_t *from, rpl_dao_t *dao);

void rpl_process_dao_ack(uint8_t sequence, uint8_t status);

int rpl_dag_ready_to_advertise(void);

void rpl_dag_update_state(void);

void rpl_dag_init(void);

void rpl_dag_root_set_prefix(uip_ipaddr_t *prefix, uip_ipaddr_t *iid);

int rpl_dag_root_start(void);

int rpl_dag_root_is_root(void);

void rpl_dag_root_print_links(char const *str);

nbr_table_t *rpl_neighbors;

void rpl_neighbor_init(void);

int rpl_neighbor_is_parent(rpl_nbr_t *nbr_0);

void rpl_neighbor_set_preferred_parent(rpl_nbr_t *nbr_0);

int rpl_neighbor_is_fresh(rpl_nbr_t *nbr_0);

int rpl_neighbor_is_reachable(rpl_nbr_t *nbr_0);

int rpl_neighbor_is_acceptable_parent(rpl_nbr_t *nbr_0);

uint16_t rpl_neighbor_get_link_metric(rpl_nbr_t *nbr_0);

rpl_rank_t rpl_neighbor_rank_via_nbr(rpl_nbr_t *nbr_0);

linkaddr_t const *rpl_neighbor_get_lladdr(rpl_nbr_t *nbr_0);

struct link_stats const *rpl_neighbor_get_link_stats(rpl_nbr_t *nbr_0);

uip_ipaddr_t *rpl_neighbor_get_ipaddr(rpl_nbr_t *nbr_0);

rpl_nbr_t *rpl_neighbor_get_from_lladdr(uip_lladdr_t *addr_0);

rpl_nbr_t *rpl_neighbor_get_from_ipaddr(uip_ipaddr_t *addr_0);

int rpl_neighbor_count(void);

void rpl_neighbor_print_list(char const *str);

void rpl_neighbor_remove_all(void);

rpl_nbr_t *rpl_neighbor_select_best(void);

int rpl_neighbor_snprint(char *buf_0, int buflen_0, rpl_nbr_t *nbr_0);

int rpl_ext_header_srh_get_next_hop(uip_ipaddr_t *ipaddr);

int rpl_ext_header_srh_update(void);

int rpl_ext_header_hbh_update(uint8_t *ext_buf, int opt_offset);

int rpl_ext_header_update(void);

_Bool rpl_ext_header_remove(void);

void rpl_timers_schedule_periodic_dis(void);

void rpl_timers_unschedule_leaving(void);

void rpl_timers_schedule_leaving(void);

void rpl_timers_init(void);

void rpl_timers_stop_dag_timers(void);

void rpl_timers_dio_reset(char const *str);

void rpl_timers_schedule_unicast_dio(rpl_nbr_t *target);

void rpl_timers_schedule_dao(void);

void rpl_timers_schedule_dao_ack(uip_ipaddr_t *target, uint16_t sequence);

void rpl_timers_notify_dao_ack(void);

void rpl_schedule_probing(void);

void rpl_schedule_probing_now(void);

void rpl_timers_schedule_state_update(void);

void rpl_timers_unschedule_state_update(void);

rpl_instance_t curr_instance;

uip_ipaddr_t rpl_multicast_addr;

void rpl_link_callback(linkaddr_t const *addr_0, int status, int numtx);

int rpl_set_prefix(rpl_prefix_t *prefix);

int rpl_set_prefix_from_addr(uip_ipaddr_t *addr_0, unsigned int len,
                             uint8_t flags);

void rpl_reset_prefix(rpl_prefix_t *last_prefix);

uip_ipaddr_t const *rpl_get_global_address(void);

int rpl_is_reachable(void);

int rpl_lollipop_greater_than(int a, int b);

void rpl_refresh_routes(char const *str);

void rpl_set_leaf_only(uint8_t value);

uint8_t rpl_get_leaf_only(void);

struct orchestra_rule eb_per_time_source;
struct orchestra_rule unicast_per_neighbor_rpl_storing;
struct orchestra_rule unicast_per_neighbor_rpl_ns;
struct orchestra_rule default_common;
int main(int argc, char **argv)
{
  int __retres;
  platform_process_args(argc,argv);
  platform_init_stage_one();
  clock_init();
  rtimer_init();
  process_init();
  process_start(& etimer_process,(void *)0);
  ctimer_init();
  watchdog_init();
  energest_init();
  platform_init_stage_two();
  queuebuf_init();
  netstack_init();
  node_id_init();
  {
    int tmp;
    if (3 < curr_log_level_main) tmp = 3; else tmp = curr_log_level_main;
    if (3 <= tmp) {
      printf("[%-4s: %-10s] ","INFO","Main");
      printf("- Routing: %s\n",rpl_lite_driver.name);
    }
  }
  {
    int tmp_0;
    if (3 < curr_log_level_main) tmp_0 = 3; else tmp_0 = curr_log_level_main;
    if (3 <= tmp_0) {
      printf("[%-4s: %-10s] ","INFO","Main");
      printf("- Net: %s\n",tun6_net_driver.name);
    }
  }
  {
    int tmp_1;
    if (3 < curr_log_level_main) tmp_1 = 3; else tmp_1 = curr_log_level_main;
    if (3 <= tmp_1) {
      printf("[%-4s: %-10s] ","INFO","Main");
      printf("- MAC: %s\n",nullmac_driver.name);
    }
  }
  {
    int tmp_2;
    if (3 < curr_log_level_main) tmp_2 = 3; else tmp_2 = curr_log_level_main;
    if (3 <= tmp_2) {
      printf("[%-4s: %-10s] ","INFO","Main");
      printf("- 802.15.4 PANID: 0x%04x\n",0xabcd);
    }
  }
  {
    int tmp_3;
    if (3 < curr_log_level_main) tmp_3 = 3; else tmp_3 = curr_log_level_main;
    if (3 <= tmp_3) {
      printf("[%-4s: %-10s] ","INFO","Main");
      printf("- 802.15.4 Default channel: %u\n",26);
    }
  }
  {
    int tmp_4;
    if (3 < curr_log_level_main) tmp_4 = 3; else tmp_4 = curr_log_level_main;
    if (3 <= tmp_4) {
      printf("[%-4s: %-10s] ","INFO","Main");
      printf("Node ID: %u\n",(int)node_id);
    }
  }
  {
    int tmp_5;
    if (3 < curr_log_level_main) tmp_5 = 3; else tmp_5 = curr_log_level_main;
    if (3 <= tmp_5) {
      printf("[%-4s: %-10s] ","INFO","Main");
      printf("Link-layer address: ");
    }
  }
  {
    int tmp_6;
    if (3 < curr_log_level_main) tmp_6 = 3; else tmp_6 = curr_log_level_main;
    if (3 <= tmp_6) log_lladdr((linkaddr_t const *)(& linkaddr_node_addr));
  }
  {
    int tmp_7;
    if (3 < curr_log_level_main) tmp_7 = 3; else tmp_7 = curr_log_level_main;
    if (3 <= tmp_7) printf("\n");
  }
  {
    uip_ds6_addr_t *lladdr;
    memcpy((void *)(& uip_lladdr.addr),(void const *)(& linkaddr_node_addr),
           sizeof(uip_lladdr.addr));
    process_start(& tcpip_process,(void *)0);
    lladdr = uip_ds6_get_link_local((signed char)(-1));
    {
      int tmp_8;
      if (3 < curr_log_level_main) tmp_8 = 3;
      else tmp_8 = curr_log_level_main;
      if (3 <= tmp_8) {
        printf("[%-4s: %-10s] ","INFO","Main");
        printf("Tentative link-local IPv6 address: ");
      }
    }
    {
      int tmp_11;
      if (3 < curr_log_level_main) tmp_11 = 3;
      else tmp_11 = curr_log_level_main;
      if (3 <= tmp_11) {
        uip_ipaddr_t *tmp_10;
        if (lladdr != (uip_ds6_addr_t *)0) tmp_10 = & lladdr->ipaddr;
        else tmp_10 = (uip_ipaddr_t *)0;
        log_6addr((uip_ipaddr_t const *)tmp_10);
      }
    }
    {
      int tmp_12;
      if (3 < curr_log_level_main) tmp_12 = 3;
      else tmp_12 = curr_log_level_main;
      if (3 <= tmp_12) printf("\n");
    }
  }
  platform_init_stage_three();
  autostart_start(autostart_processes);
  watchdog_start();
  platform_main_loop();
  __retres = 0;
  return __retres;
}

__inline static unsigned int __bswap_32_12(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_12(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void autostart_start(struct process * const *processes)
{
  int i;
  i = 0;
  while (*(processes + i) != (struct process *)0) {
    process_start(*(processes + i),(void *)0);
    i ++;
  }
  return;
}

void autostart_exit(struct process * const *processes)
{
  int i;
  i = 0;
  while (*(processes + i) != (struct process *)0) {
    process_exit(*(processes + i));
    i ++;
  }
  return;
}

__inline static unsigned int __bswap_32_13(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_13(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void stimer_set(struct stimer *t, unsigned long interval)
{
  t->interval = interval;
  t->start = clock_seconds();
  return;
}

void stimer_reset(struct stimer *t)
{
  int tmp;
  tmp = stimer_expired(t);
  if (tmp) t->start += t->interval;
  return;
}

void stimer_restart(struct stimer *t)
{
  t->start = clock_seconds();
  return;
}

int stimer_expired(struct stimer *t)
{
  int __retres;
  unsigned long tmp;
  tmp = clock_seconds();
  ;
  __retres = tmp - (t->start + t->interval) < ~ ((unsigned long)0) >> 1;
  return __retres;
}

unsigned long stimer_remaining(struct stimer *t)
{
  unsigned long __retres;
  unsigned long tmp;
  tmp = clock_seconds();
  ;
  __retres = (t->start + t->interval) - tmp;
  return __retres;
}

unsigned long stimer_elapsed(struct stimer *t)
{
  unsigned long __retres;
  unsigned long tmp;
  tmp = clock_seconds();
  ;
  __retres = tmp - t->start;
  return __retres;
}

__inline static unsigned int __bswap_32_14(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_14(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void ip64_addr_copy4(uip_ip4addr_t *dest, uip_ip4addr_t const *src);

void ip64_addr_copy6(uip_ip6addr_t *dest, uip_ip6addr_t const *src);

int ip64_addr_6to4(uip_ip6addr_t const *ipv6addr, uip_ip4addr_t *ipv4addr);

int ip64_addr_4to6(uip_ip4addr_t const *ipv4addr, uip_ip6addr_t *ipv6addr);

int ip64_addr_is_ip64(uip_ip6addr_t const *ipv6addr);

void ip64_addr_set_prefix(uip_ip6addr_t const *prefix, uint8_t prefix_len);

int curr_log_level_rpl = 0;
int curr_log_level_tcpip = 0;
int curr_log_level_ipv6 = 0;
int curr_log_level_6lowpan = 0;
int curr_log_level_nullnet = 0;
int curr_log_level_mac = 0;
int curr_log_level_framer = 0;
int curr_log_level_6top = 0;
int curr_log_level_coap = 0;
int curr_log_level_lwm2m = 0;
int curr_log_level_main = 3;
struct log_module all_modules[12] =
  {{.name = "rpl", .curr_log_level = & curr_log_level_rpl, .max_log_level = 0},
   {.name = "tcpip",
    .curr_log_level = & curr_log_level_tcpip,
    .max_log_level = 0},
   {.name = "ipv6",
    .curr_log_level = & curr_log_level_ipv6,
    .max_log_level = 0},
   {.name = "6lowpan",
    .curr_log_level = & curr_log_level_6lowpan,
    .max_log_level = 0},
   {.name = "nullnet",
    .curr_log_level = & curr_log_level_nullnet,
    .max_log_level = 0},
   {.name = "mac", .curr_log_level = & curr_log_level_mac, .max_log_level = 0},
   {.name = "framer",
    .curr_log_level = & curr_log_level_framer,
    .max_log_level = 0},
   {.name = "6top",
    .curr_log_level = & curr_log_level_6top,
    .max_log_level = 0},
   {.name = "coap",
    .curr_log_level = & curr_log_level_coap,
    .max_log_level = 0},
   {.name = "lwm2m",
    .curr_log_level = & curr_log_level_lwm2m,
    .max_log_level = 0},
   {.name = "main",
    .curr_log_level = & curr_log_level_main,
    .max_log_level = 3},
   {.name = (char const *)0, .curr_log_level = (int *)0, .max_log_level = 0}};
void log_6addr(uip_ipaddr_t const *ipaddr)
{
  char buf_0[40];
  uiplib_ipaddr_snprint(buf_0,sizeof(buf_0),ipaddr);
  printf("%s",buf_0);
  return;
}

int log_6addr_compact_snprint(char *buf_0, size_t size,
                              uip_ipaddr_t const *ipaddr)
{
  int __retres;
  if (ipaddr == (uip_ipaddr_t const *)0) {
    int tmp;
    tmp = snprintf(buf_0,size,"6A-NULL");
    __retres = tmp;
    goto return_label;
  }
  else {
    int tmp_0;
    char *prefix = (char *)0;
    if ((int)ipaddr->u8[0] == 0xFF) prefix = (char *)"6M";
    else 
      if ((int)ipaddr->u8[0] == 0xfe) {
        if ((int)ipaddr->u8[1] == 0x80) prefix = (char *)"6L";
        else goto _LAND;
      }
      else _LAND: prefix = (char *)"6G";
    tmp_0 = snprintf(buf_0,size,"%s-%04x",prefix,
                     (int)((unsigned short)(((int)ipaddr->u16[sizeof(uip_ipaddr_t) / (unsigned long)2 - (unsigned long)1] << 8) | (
                                            (int)ipaddr->u16[sizeof(uip_ipaddr_t) / (unsigned long)2 - (unsigned long)1] >> 8))));
    __retres = tmp_0;
    goto return_label;
  }
  return_label: return __retres;
}

void log_6addr_compact(uip_ipaddr_t const *ipaddr)
{
  char buf_0[8];
  log_6addr_compact_snprint(buf_0,sizeof(buf_0),ipaddr);
  printf("%s",buf_0);
  return;
}

void log_lladdr(linkaddr_t const *lladdr)
{
  if (lladdr == (linkaddr_t const *)0) {
    printf("(NULL LL addr)");
    goto return_label;
  }
  else {
    unsigned int i;
    i = (unsigned int)0;
    while (i < (unsigned int)8) {
      if (i > (unsigned int)0) 
        if (i % (unsigned int)2 == (unsigned int)0) printf(".");
      printf("%02x",(int)lladdr->u8[i]);
      i ++;
    }
  }
  return_label: return;
}

void log_lladdr_compact(linkaddr_t const *lladdr)
{
  if (lladdr == (linkaddr_t const *)0) goto _LOR;
  else {
    int tmp;
    tmp = linkaddr_cmp(lladdr,& linkaddr_null);
    if (tmp) _LOR: printf("LL-NULL");
    else printf("LL-%04x",
                (int)((unsigned short)(((int)lladdr->u16[8 / 2 - 1] << 8) | (
                                       (int)lladdr->u16[8 / 2 - 1] >> 8))));
  }
  return;
}

void log_set_level(char const *module, int level)
{
  if (level >= 0) 
    if (level <= 4) {
      int tmp_0;
      int tmp;
      int i = 0;
      tmp = strcmp("all",module);
      if (tmp) tmp_0 = 0; else tmp_0 = 1;
      int module_all = tmp_0;
      while (all_modules[i].name != (char const *)0) {
        if (module_all) goto _LOR;
        else {
          int tmp_1;
          tmp_1 = strcmp(module,all_modules[i].name);
          if (! tmp_1) 
            _LOR:
            if (level < all_modules[i].max_log_level) *(all_modules[i].curr_log_level) = level;
            else *(all_modules[i].curr_log_level) = all_modules[i].max_log_level;
        }
        i ++;
      }
    }
  return;
}

int log_get_level(char const *module)
{
  int __retres;
  int i = 0;
  if (module == (char const *)0) {
    __retres = -1;
    goto return_label;
  }
  while (all_modules[i].name != (char const *)0) {
    int tmp;
    tmp = strcmp(module,all_modules[i].name);
    if (! tmp) {
      __retres = *(all_modules[i].curr_log_level);
      goto return_label;
    }
    i ++;
  }
  __retres = -1;
  return_label: return __retres;
}

char const *log_level_to_str(int level)
{
  char const *__retres;
  switch (level) {
    case 0: __retres = "None";
    goto return_label;
    case 1: __retres = "Errors";
    goto return_label;
    case 2: __retres = "Warnings";
    goto return_label;
    case 3: __retres = "Info";
    goto return_label;
    case 4: __retres = "Debug";
    goto return_label;
    default: __retres = "N/A";
    goto return_label;
  }
  return_label: return __retres;
}

__inline static unsigned int __bswap_32_15(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_15(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

__inline static uint64_t energest_type_time_0(energest_type_t type)
{
  uint64_t __retres;
  __retres = (unsigned long)0;
  return __retres;
}

__inline static void energest_type_set_0(energest_type_t type,
                                         uint64_t time_0)
{
  return;
}

__inline static void energest_on_0(energest_type_t type)
{
  return;
}

__inline static void energest_off_0(energest_type_t type)
{
  return;
}

__inline static void energest_switch_0(energest_type_t type_off,
                                       energest_type_t type_on)
{
  return;
}

void energest_init(void)
{
  return;
}

void energest_flush(void)
{
  return;
}

uint64_t energest_get_total_time(void)
{
  uint64_t __retres;
  __retres = (unsigned long)0;
  return __retres;
}

__inline static unsigned int __bswap_32_16(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_16(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static struct etimer *timerlist;
static clock_time_t next_expiration;
static char process_thread_etimer_process(struct pt *process_pt,
                                          process_event_t ev,
                                          process_data_t data);

struct process etimer_process =
  {.next = (struct process *)0,
   .name = "Event timer",
   .thread = & process_thread_etimer_process,
   .pt = {.lc = (unsigned short)0},
   .state = (unsigned char)0,
   .needspoll = (unsigned char)0};
static void update_time(void)
{
  clock_time_t tdist;
  clock_time_t now;
  struct etimer *t;
  if (timerlist == (struct etimer *)0) next_expiration = (unsigned long)0;
  else {
    now = clock_time();
    t = timerlist;
    tdist = (t->timer.start + t->timer.interval) - now;
    t = t->next;
    while (t != (struct etimer *)0) {
      if ((t->timer.start + t->timer.interval) - now < tdist) tdist = 
                                                              (t->timer.start + t->timer.interval) - now;
      t = t->next;
    }
    next_expiration = now + tdist;
  }
  return;
}

static char process_thread_etimer_process(struct pt *process_pt,
                                          process_event_t ev,
                                          process_data_t data)
{
  char __retres;
  struct etimer *t;
  struct etimer *u;
  {
    char PT_YIELD_FLAG = (char)1;
    if (PT_YIELD_FLAG) ;
    switch ((int)process_pt->lc) {
      case 0: ;
      timerlist = (struct etimer *)0;
      while (1) {
        PT_YIELD_FLAG = (char)0;
        process_pt->lc = (unsigned short)89;
        case 89: ;
        if ((int)PT_YIELD_FLAG == 0) {
          __retres = (char)1;
          goto return_label;
        }
        if ((int)ev == 0x87) {
          struct process *p = (struct process *)data;
          while (1) {
            if (timerlist != (struct etimer *)0) {
              if (! (timerlist->p == p)) break;
            }
            else break;
            timerlist = timerlist->next;
          }
          if (timerlist != (struct etimer *)0) {
            t = timerlist;
            while (t->next != (struct etimer *)0) 
              if ((t->next)->p == p) t->next = (t->next)->next;
              else t = t->next;
          }
          continue;
        }
        else 
          if ((int)ev != 0x82) continue;
        again: u = (struct etimer *)0;
        t = timerlist;
        while (t != (struct etimer *)0) {
          {
            int tmp_0;
            tmp_0 = timer_expired(& t->timer);
            if (tmp_0) {
              int tmp;
              tmp = process_post(t->p,(unsigned char)0x88,(void *)t);
              if (tmp == 0) {
                t->p = (struct process *)0;
                if (u != (struct etimer *)0) u->next = t->next;
                else timerlist = t->next;
                t->next = (struct etimer *)0;
                update_time();
                goto again;
              }
              else etimer_request_poll();
            }
            u = t;
          }
          t = t->next;
        }
      }
    }
    PT_YIELD_FLAG = (char)0;
    process_pt->lc = (unsigned short)0;
    __retres = (char)3;
    goto return_label;
  }
  return_label: return __retres;
}

void etimer_request_poll(void)
{
  process_poll(& etimer_process);
  return;
}

static void add_timer(struct etimer *timer)
{
  struct etimer *t;
  etimer_request_poll();
  if (timer->p != (struct process *)0) {
    t = timerlist;
    while (t != (struct etimer *)0) {
      if (t == timer) {
        timer->p = process_current;
        update_time();
        goto return_label;
      }
      t = t->next;
    }
  }
  timer->p = process_current;
  timer->next = timerlist;
  timerlist = timer;
  update_time();
  return_label: return;
}

void etimer_set(struct etimer *et, clock_time_t interval)
{
  timer_set(& et->timer,interval);
  add_timer(et);
  return;
}

void etimer_reset_with_new_interval(struct etimer *et, clock_time_t interval)
{
  timer_reset(& et->timer);
  et->timer.interval = interval;
  add_timer(et);
  return;
}

void etimer_reset(struct etimer *et)
{
  timer_reset(& et->timer);
  add_timer(et);
  return;
}

void etimer_restart(struct etimer *et)
{
  timer_restart(& et->timer);
  add_timer(et);
  return;
}

void etimer_adjust(struct etimer *et, int timediff)
{
  et->timer.start += (clock_time_t)timediff;
  update_time();
  return;
}

int etimer_expired(struct etimer *et)
{
  int __retres;
  __retres = et->p == (struct process *)0;
  return __retres;
}

clock_time_t etimer_expiration_time(struct etimer *et)
{
  clock_time_t __retres;
  __retres = et->timer.start + et->timer.interval;
  return __retres;
}

clock_time_t etimer_start_time(struct etimer *et)
{
  clock_time_t __retres;
  __retres = et->timer.start;
  return __retres;
}

int etimer_pending(void)
{
  int __retres;
  __retres = timerlist != (struct etimer *)0;
  return __retres;
}

clock_time_t etimer_next_expiration_time(void)
{
  clock_time_t tmp_0;
  int tmp;
  tmp = etimer_pending();
  if (tmp) tmp_0 = next_expiration; else tmp_0 = (unsigned long)0;
  return tmp_0;
}

void etimer_stop(struct etimer *et)
{
  struct etimer *t;
  if (et == timerlist) {
    timerlist = timerlist->next;
    update_time();
  }
  else {
    t = timerlist;
    while (1) {
      if (t != (struct etimer *)0) {
        if (! (t->next != et)) break;
      }
      else break;
      t = t->next;
    }
    if (t != (struct etimer *)0) {
      t->next = et->next;
      update_time();
    }
  }
  et->next = (struct etimer *)0;
  et->p = (struct process *)0;
  return;
}

__inline static unsigned int __bswap_32_17(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_17(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

uint16_t node_id = (unsigned short)0;
void node_id_init(void)
{
  node_id = (unsigned short)((int)linkaddr_node_addr.u8[8 - 1] + ((int)linkaddr_node_addr.u8[
                                                                  8 - 2] << 8));
  return;
}

__inline static unsigned int __bswap_32_18(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_18(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

_Bool mutex_generic_try_lock(mutex_t volatile *mutex);

void mutex_generic_unlock(mutex_t volatile *mutex);

__inline static int_master_status_t critical_enter(void)
{
  int_master_status_t status = int_master_read_and_disable();
  return status;
}

__inline static void critical_exit(int_master_status_t status)
{
  int_master_status_set(status);
  return;
}

_Bool mutex_generic_try_lock(mutex_t volatile *mutex)
{
  _Bool success = (_Bool)0;
  int_master_status_t status = critical_enter();
  if ((int)*mutex == 0) {
    *mutex = (unsigned char)1;
    success = (_Bool)1;
  }
  critical_exit(status);
  return success;
}

void mutex_generic_unlock(mutex_t volatile *mutex)
{
  int_master_status_t status = critical_enter();
  *mutex = (unsigned char)0;
  critical_exit(status);
  return;
}

__inline static unsigned int __bswap_32_19(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_19(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static void *ctimer_list_list = (void *)0;
static list_t ctimer_list = & ctimer_list_list;
static char initialized;
static char process_thread_ctimer_process(struct pt *process_pt,
                                          process_event_t ev,
                                          process_data_t data);

struct process ctimer_process =
  {.next = (struct process *)0,
   .name = "Ctimer process",
   .thread = & process_thread_ctimer_process,
   .pt = {.lc = (unsigned short)0},
   .state = (unsigned char)0,
   .needspoll = (unsigned char)0};
static char process_thread_ctimer_process(struct pt *process_pt,
                                          process_event_t ev,
                                          process_data_t data)
{
  char __retres;
  struct ctimer *c;
  {
    char PT_YIELD_FLAG = (char)1;
    if (PT_YIELD_FLAG) ;
    switch ((int)process_pt->lc) {
      case 0: ;
      c = (struct ctimer *)list_head(ctimer_list);
      while (c != (struct ctimer *)0) {
        etimer_set(& c->etimer,c->etimer.timer.interval);
        c = c->next;
      }
      initialized = (char)1;
      while (1) {
        PT_YIELD_FLAG = (char)0;
        process_pt->lc = (unsigned short)74;
        case 74: ;
        if ((int)PT_YIELD_FLAG == 0) goto _LOR;
        else 
          if (! ((int)ev == 0x88)) {
            _LOR: {
                    __retres = (char)1;
                    goto return_label;
                  }
          }
        c = (struct ctimer *)list_head(ctimer_list);
        while (c != (struct ctimer *)0) {
          if ((void *)(& c->etimer) == data) {
            list_remove(ctimer_list,(void *)c);
            {
              struct process *tmp_current = process_current;
              process_current = c->p;
              if (c->f != (void (*)(void *))0) (*(c->f))(c->ptr);
              process_current = tmp_current;
            }
            break;
          }
          c = c->next;
        }
      }
    }
    PT_YIELD_FLAG = (char)0;
    process_pt->lc = (unsigned short)0;
    __retres = (char)3;
    goto return_label;
  }
  return_label: return __retres;
}

void ctimer_init(void)
{
  initialized = (char)0;
  list_init(ctimer_list);
  process_start(& ctimer_process,(void *)0);
  return;
}

void ctimer_set(struct ctimer *c, clock_time_t t, void (*f)(void *),
                void *ptr)
{
  ctimer_set_with_process(c,t,f,ptr,process_current);
  return;
}

void ctimer_set_with_process(struct ctimer *c, clock_time_t t,
                             void (*f)(void *), void *ptr, struct process *p)
{
  c->p = p;
  c->f = f;
  c->ptr = ptr;
  if (initialized) {
    {
      struct process *tmp_current = process_current;
      process_current = & ctimer_process;
      etimer_set(& c->etimer,t);
      process_current = tmp_current;
    }
  }
  else c->etimer.timer.interval = t;
  list_add(ctimer_list,(void *)c);
  return;
}

void ctimer_reset(struct ctimer *c)
{
  if (initialized) {
    {
      struct process *tmp_current = process_current;
      process_current = & ctimer_process;
      etimer_reset(& c->etimer);
      process_current = tmp_current;
    }
  }
  list_add(ctimer_list,(void *)c);
  return;
}

void ctimer_restart(struct ctimer *c)
{
  if (initialized) {
    {
      struct process *tmp_current = process_current;
      process_current = & ctimer_process;
      etimer_restart(& c->etimer);
      process_current = tmp_current;
    }
  }
  list_add(ctimer_list,(void *)c);
  return;
}

void ctimer_stop(struct ctimer *c)
{
  if (initialized) etimer_stop(& c->etimer);
  else {
    c->etimer.next = (struct etimer *)0;
    c->etimer.p = (struct process *)0;
  }
  list_remove(ctimer_list,(void *)c);
  return;
}

int ctimer_expired(struct ctimer *c)
{
  int __retres;
  struct ctimer *t;
  if (initialized) {
    int tmp;
    tmp = etimer_expired(& c->etimer);
    __retres = tmp;
    goto return_label;
  }
  t = (struct ctimer *)list_head(ctimer_list);
  while (t != (struct ctimer *)0) {
    if (t == c) {
      __retres = 0;
      goto return_label;
    }
    t = t->next;
  }
  __retres = 1;
  return_label: return __retres;
}

__inline static unsigned int __bswap_32_20(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_20(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

__inline static uint64_t energest_type_time_1(energest_type_t type)
{
  uint64_t __retres;
  __retres = (unsigned long)0;
  return __retres;
}

__inline static void energest_type_set_1(energest_type_t type,
                                         uint64_t time_0)
{
  return;
}

__inline static void energest_on_1(energest_type_t type)
{
  return;
}

__inline static void energest_off_1(energest_type_t type)
{
  return;
}

__inline static void energest_switch_1(energest_type_t type_off,
                                       energest_type_t type_on)
{
  return;
}

struct compower_activity compower_idle_activity;
void compower_init(void);

void compower_accumulate(struct compower_activity *e);

void compower_clear(struct compower_activity *e);

void compower_init(void)
{
  compower_clear(& compower_idle_activity);
  return;
}

static uint64_t compower_accumulate_last_listen;
static uint64_t compower_accumulate_last_transmit;
void compower_accumulate(struct compower_activity *e)
{
  uint64_t listen_0;
  uint64_t transmit_0;
  energest_flush();
  listen_0 = energest_type_time_1(ENERGEST_TYPE_LISTEN);
  e->listen += listen_0 - compower_accumulate_last_listen;
  compower_accumulate_last_listen = listen_0;
  transmit_0 = energest_type_time_1(ENERGEST_TYPE_TRANSMIT);
  e->transmit += transmit_0 - compower_accumulate_last_transmit;
  compower_accumulate_last_transmit = transmit_0;
  return;
}

void compower_clear(struct compower_activity *e)
{
  uint64_t tmp;
  tmp = (unsigned long)0;
  e->transmit = tmp;
  e->listen = tmp;
  return;
}

__inline static unsigned int __bswap_32_21(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_21(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

struct process *process_list = (struct process *)0;
struct process *process_current = (struct process *)0;
static process_event_t lastevent;
static process_num_events_t nevents;
static process_num_events_t fevent;
static struct event_data events[32];
static unsigned char volatile poll_requested;
static void call_process(struct process *p, process_event_t ev,
                         process_data_t data);

process_event_t process_alloc_event(void)
{
  process_event_t tmp;
  tmp = lastevent;
  lastevent = (process_event_t)((int)lastevent + 1);
  ;
  return tmp;
}

void process_start(struct process *p, process_data_t data)
{
  struct process *q;
  q = process_list;
  while (1) {
    if (q != p) {
      if (! (q != (struct process *)0)) break;
    }
    else break;
    q = q->next;
  }
  if (q == p) goto return_label;
  p->next = process_list;
  process_list = p;
  p->state = (unsigned char)1;
  p->pt.lc = (unsigned short)0;
  process_post_synch(p,(unsigned char)0x81,data);
  return_label: return;
}

static void exit_process(struct process *p, struct process *fromprocess)
{
  register struct process *q;
  int tmp;
  struct process *old_current = process_current;
  q = process_list;
  while (1) {
    if (q != p) {
      if (! (q != (struct process *)0)) break;
    }
    else break;
    q = q->next;
  }
  if (q == (struct process *)0) goto return_label;
  tmp = process_is_running(p);
  if (tmp) {
    p->state = (unsigned char)0;
    q = process_list;
    while (q != (struct process *)0) {
      if (p != q) call_process(q,(unsigned char)0x87,(void *)p);
      q = q->next;
    }
    if (p->thread != (char (*)(struct pt *, process_event_t , process_data_t ))0) 
      if (p != fromprocess) {
        process_current = p;
        (*(p->thread))(& p->pt,(unsigned char)0x83,(void *)0);
      }
  }
  if (p == process_list) process_list = process_list->next;
  else {
    q = process_list;
    while (q != (struct process *)0) {
      if (q->next == p) {
        q->next = p->next;
        break;
      }
      q = q->next;
    }
  }
  process_current = old_current;
  return_label: return;
}

static void call_process(struct process *p, process_event_t ev,
                         process_data_t data)
{
  int ret;
  if ((int)p->state & 1) 
    if (p->thread != (char (*)(struct pt *, process_event_t , process_data_t ))0) {
      char tmp;
      process_current = p;
      p->state = (unsigned char)2;
      tmp = (*(p->thread))(& p->pt,ev,data);
      ret = (int)tmp;
      if (ret == 2) goto _LOR;
      else 
        if (ret == 3) goto _LOR;
        else 
          if ((int)ev == 0x83) _LOR: exit_process(p,p);
          else p->state = (unsigned char)1;
    }
  return;
}

void process_exit(struct process *p)
{
  exit_process(p,process_current);
  return;
}

void process_init(void)
{
  lastevent = (unsigned char)0x8a;
  fevent = (unsigned char)0;
  nevents = fevent;
  process_list = (struct process *)0;
  process_current = process_list;
  return;
}

static void do_poll(void)
{
  struct process *p;
  poll_requested = (unsigned char)0;
  p = process_list;
  while (p != (struct process *)0) {
    if (p->needspoll) {
      p->state = (unsigned char)1;
      p->needspoll = (unsigned char)0;
      call_process(p,(unsigned char)0x82,(void *)0);
    }
    p = p->next;
  }
  return;
}

static void do_event(void)
{
  process_event_t ev;
  process_data_t data;
  struct process *receiver;
  struct process *p;
  if ((int)nevents > 0) {
    ev = events[fevent].ev;
    data = events[fevent].data;
    receiver = events[fevent].p;
    fevent = (unsigned char)(((int)fevent + 1) % 32);
    nevents = (process_num_events_t)((int)nevents - 1);
    if (receiver == (struct process *)0) {
      p = process_list;
      while (p != (struct process *)0) {
        if (poll_requested) do_poll();
        call_process(p,ev,data);
        p = p->next;
      }
    }
    else {
      if ((int)ev == 0x81) receiver->state = (unsigned char)1;
      call_process(receiver,ev,data);
    }
  }
  return;
}

int process_run(void)
{
  int __retres;
  if (poll_requested) do_poll();
  do_event();
  __retres = (int)nevents + (int)poll_requested;
  return __retres;
}

int process_nevents(void)
{
  int __retres;
  __retres = (int)nevents + (int)poll_requested;
  return __retres;
}

int process_post(struct process *p, process_event_t ev, process_data_t data)
{
  int __retres;
  process_num_events_t snum;
  if (process_current == (struct process *)0) ;
  if ((int)nevents == 32) {
    __retres = 1;
    goto return_label;
  }
  snum = (unsigned char)((int)((unsigned char)((int)fevent + (int)nevents)) % 32);
  events[snum].ev = ev;
  events[snum].data = data;
  events[snum].p = p;
  nevents = (process_num_events_t)((int)nevents + 1);
  __retres = 0;
  return_label: return __retres;
}

void process_post_synch(struct process *p, process_event_t ev,
                        process_data_t data)
{
  struct process *caller = process_current;
  call_process(p,ev,data);
  process_current = caller;
  return;
}

void process_poll(struct process *p)
{
  if (p != (struct process *)0) 
    if ((int)p->state == 1) goto _LOR;
    else 
      if ((int)p->state == 2) {
        _LOR:
        {
          p->needspoll = (unsigned char)1;
          poll_requested = (unsigned char)1;
        }
      }
  return;
}

int process_is_running(struct process *p)
{
  int __retres;
  __retres = (int)p->state != 0;
  return __retres;
}

__inline static unsigned int __bswap_32_22(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_22(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static struct rtimer *next_rtimer;
void rtimer_init(void)
{
  rtimer_arch_init();
  return;
}

int rtimer_set(struct rtimer *rtimer, rtimer_clock_t time_0,
               rtimer_clock_t duration,
               void (*func)(struct rtimer *t, void *ptr), void *ptr)
{
  int __retres;
  int first = 0;
  if (next_rtimer == (struct rtimer *)0) first = 1;
  rtimer->func = func;
  rtimer->ptr = ptr;
  rtimer->time = time_0;
  next_rtimer = rtimer;
  if (first == 1) rtimer_arch_schedule(time_0);
  __retres = RTIMER_OK;
  return __retres;
}

void rtimer_run_next(void)
{
  struct rtimer *t;
  if (next_rtimer == (struct rtimer *)0) goto return_label;
  t = next_rtimer;
  next_rtimer = (struct rtimer *)0;
  (*(t->func))(t,t->ptr);
  if (next_rtimer != (struct rtimer *)0) rtimer_arch_schedule(next_rtimer->time);
  return_label: return;
}

__inline static unsigned int __bswap_32_23(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_23(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void timer_set(struct timer *t, clock_time_t interval)
{
  t->interval = interval;
  t->start = clock_time();
  return;
}

void timer_reset(struct timer *t)
{
  int tmp;
  tmp = timer_expired(t);
  if (tmp) t->start += t->interval;
  return;
}

void timer_restart(struct timer *t)
{
  t->start = clock_time();
  return;
}

int timer_expired(struct timer *t)
{
  int __retres;
  clock_time_t tmp;
  tmp = clock_time();
  clock_time_t diff = (tmp - t->start) + (clock_time_t)1;
  __retres = t->interval < diff;
  return __retres;
}

clock_time_t timer_remaining(struct timer *t)
{
  clock_time_t __retres;
  clock_time_t tmp;
  tmp = clock_time();
  ;
  __retres = (t->start + t->interval) - tmp;
  return __retres;
}

__inline static unsigned int __bswap_32_24(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_24(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

__inline static int_master_status_t critical_enter_0(void)
{
  int_master_status_t status = int_master_read_and_disable();
  return status;
}

__inline static void critical_exit_0(int_master_status_t status)
{
  int_master_status_set(status);
  return;
}

process_event_t button_hal_press_event;
process_event_t button_hal_release_event;
process_event_t button_hal_periodic_event;
static char process_thread_button_hal_process(struct pt *process_pt,
                                              process_event_t ev,
                                              process_data_t data);

struct process button_hal_process =
  {.next = (struct process *)0,
   .name = "Button HAL process",
   .thread = & process_thread_button_hal_process,
   .pt = {.lc = (unsigned short)0},
   .state = (unsigned char)0,
   .needspoll = (unsigned char)0};
static gpio_hal_pin_mask_t volatile pmask;
static gpio_hal_event_handler_t button_event_handler;
static void duration_exceeded_callback(void *btn)
{
  button_hal_button_t *button = (button_hal_button_t *)btn;
  button->press_duration_seconds = (uint8_t)((int)button->press_duration_seconds + 1);
  ctimer_set(& button->duration_ctimer,(unsigned long)1000,
             & duration_exceeded_callback,(void *)button);
  process_post((struct process *)0,button_hal_periodic_event,(void *)button);
  return;
}

static void debounce_handler(void *btn)
{
  button_hal_button_t *button;
  int expired;
  uint8_t button_state;
  int tmp;
  button = (button_hal_button_t *)btn;
  tmp = ctimer_expired(& button->debounce_ctimer);
  if (! tmp) goto return_label;
  expired = ctimer_expired(& button->duration_ctimer);
  button_state = button_hal_get_state(button);
  if ((int)button_state == 1) {
    if (expired) {
      button->press_duration_seconds = (unsigned char)0;
      ctimer_set(& button->duration_ctimer,
                 (unsigned long)(1000 - (1000 >> 6)),
                 & duration_exceeded_callback,(void *)button);
      process_post((struct process *)0,button_hal_press_event,(void *)button);
    }
    else goto _LAND;
  }
  else {
    _LAND: ;
    if ((int)button_state == 0) 
      if (expired == 0) {
        ctimer_stop(& button->duration_ctimer);
        process_post((struct process *)0,button_hal_release_event,
                     (void *)button);
      }
  }
  return_label: return;
}

static void press_release_handler(gpio_hal_pin_mask_t pin_mask)
{
  pmask |= pin_mask;
  process_poll(& button_hal_process);
  return;
}

button_hal_button_t *button_hal_get_by_id(uint8_t unique_id)
{
  button_hal_button_t *__retres;
  button_hal_button_t **button;
  button = button_hal_buttons;
  while (*button != (button_hal_button_t *)0) {
    if ((int)(*button)->unique_id == (int)unique_id) {
      __retres = *button;
      goto return_label;
    }
    button ++;
  }
  __retres = (button_hal_button_t *)0;
  return_label: return __retres;
}

button_hal_button_t *button_hal_get_by_index(uint8_t index_0)
{
  button_hal_button_t *__retres;
  if ((int)index_0 >= (int)button_hal_button_count) {
    __retres = (button_hal_button_t *)0;
    goto return_label;
  }
  __retres = button_hal_buttons[index_0];
  return_label: return __retres;
}

uint8_t button_hal_get_state(button_hal_button_t *button)
{
  uint8_t __retres;
  uint8_t pin_state_0 = gpio_hal_arch_no_port_read_pin(button->pin);
  if ((int)pin_state_0 == 0) {
    if ((int)button->negative_logic == 1) goto _LOR; else goto _LAND;
  }
  else {
    _LAND: ;
    if ((int)pin_state_0 == 1) 
      if ((int)button->negative_logic == 0) {
        _LOR: {
                __retres = (unsigned char)1;
                goto return_label;
              }
      }
  }
  __retres = (unsigned char)0;
  return_label: return __retres;
}

void button_hal_init(void)
{
  button_hal_button_t **button;
  gpio_hal_pin_cfg_t cfg;
  button_hal_press_event = process_alloc_event();
  button_hal_release_event = process_alloc_event();
  button_hal_periodic_event = process_alloc_event();
  button_event_handler.pin_mask = (unsigned int)0;
  button_event_handler.handler = & press_release_handler;
  button = button_hal_buttons;
  while (*button != (button_hal_button_t *)0) {
    cfg = (unsigned int)((0x04 | 0x08) | 0x80) | (*button)->pull;
    gpio_hal_arch_no_port_pin_set_input((*button)->pin);
    gpio_hal_arch_no_port_pin_cfg_set((*button)->pin,cfg);
    gpio_hal_arch_no_port_interrupt_enable((*button)->pin);
    button_event_handler.pin_mask |= (unsigned int)1 << (int)(*button)->pin;
    button ++;
  }
  process_start(& button_hal_process,(void *)0);
  gpio_hal_register_handler(& button_event_handler);
  return;
}

static char process_thread_button_hal_process(struct pt *process_pt,
                                              process_event_t ev,
                                              process_data_t data)
{
  char __retres;
  int_master_status_t status;
  gpio_hal_pin_mask_t pins;
  button_hal_button_t **button;
  {
    char PT_YIELD_FLAG = (char)1;
    if (PT_YIELD_FLAG) ;
    switch ((int)process_pt->lc) {
      case 0: ;
      while (1) {
        PT_YIELD_FLAG = (char)0;
        process_pt->lc = (unsigned short)213;
        case 213: ;
        if ((int)PT_YIELD_FLAG == 0) goto _LOR;
        else 
          if (! ((int)ev == 0x82)) {
            _LOR: {
                    __retres = (char)1;
                    goto return_label;
                  }
          }
        status = critical_enter_0();
        pins = pmask;
        pmask = (unsigned int)0;
        critical_exit_0(status);
        button = button_hal_buttons;
        while (*button != (button_hal_button_t *)0) {
          if (((unsigned int)1 << (int)(*button)->pin) & pins) {
            int tmp;
            tmp = ctimer_expired(& (*button)->debounce_ctimer);
            if (tmp) ctimer_set(& (*button)->debounce_ctimer,
                                (unsigned long)(1000 >> 6),
                                & debounce_handler,(void *)*button);
          }
          button ++;
        }
      }
    }
    PT_YIELD_FLAG = (char)0;
    process_pt->lc = (unsigned short)0;
    __retres = (char)3;
    goto return_label;
  }
  return_label: return __retres;
}

__inline static unsigned int __bswap_32_25(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_25(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

process_event_t serial_line_event_message;
void ringbuf_init(struct ringbuf *r, uint8_t *dataptr, uint8_t size);

int ringbuf_put(struct ringbuf *r, uint8_t c);

int ringbuf_get(struct ringbuf *r);

int ringbuf_size(struct ringbuf *r);

int ringbuf_elements(struct ringbuf *r);

static struct ringbuf rxbuf;
static uint8_t rxbuf_data[128];
static char process_thread_serial_line_process(struct pt *process_pt,
                                               process_event_t ev,
                                               process_data_t data);

struct process serial_line_process =
  {.next = (struct process *)0,
   .name = "Serial driver",
   .thread = & process_thread_serial_line_process,
   .pt = {.lc = (unsigned short)0},
   .state = (unsigned char)0,
   .needspoll = (unsigned char)0};
static uint8_t serial_line_input_byte_overflow = (unsigned char)0;
int serial_line_input_byte(unsigned char c)
{
  int __retres;
  if ((int)c == 0x0d) {
    __retres = 0;
    goto return_label;
  }
  if (! serial_line_input_byte_overflow) {
    int tmp;
    tmp = ringbuf_put(& rxbuf,c);
    if (tmp == 0) serial_line_input_byte_overflow = (unsigned char)1;
  }
  else 
    if ((int)c == 0x0a) {
      int tmp_0;
      tmp_0 = ringbuf_put(& rxbuf,c);
      if (tmp_0 != 0) serial_line_input_byte_overflow = (unsigned char)0;
    }
  process_poll(& serial_line_process);
  __retres = 1;
  return_label: return __retres;
}

static char process_thread_serial_line_process_buf[128];
static int process_thread_serial_line_process_ptr;
static char process_thread_serial_line_process(struct pt *process_pt,
                                               process_event_t ev,
                                               process_data_t data)
{
  char __retres;
  {
    char PT_YIELD_FLAG = (char)1;
    if (PT_YIELD_FLAG) ;
    switch ((int)process_pt->lc) {
      case 0: ;
      serial_line_event_message = process_alloc_event();
      process_thread_serial_line_process_ptr = 0;
      while (1) {
        {
          int c = ringbuf_get(& rxbuf);
          if (c == -1) {
            PT_YIELD_FLAG = (char)0;
            process_pt->lc = (unsigned short)108;
            case 108: ;
            if ((int)PT_YIELD_FLAG == 0) {
              __retres = (char)1;
              goto return_label;
            }
          }
          else 
            if (c != 0x0a) {
              if (process_thread_serial_line_process_ptr < 128 - 1) {
                int tmp_0;
                tmp_0 = process_thread_serial_line_process_ptr;
                process_thread_serial_line_process_ptr ++;
                process_thread_serial_line_process_buf[tmp_0] = (char)((unsigned char)c);
              }
            }
            else {
              int tmp_1;
              int tmp_2;
              tmp_1 = process_thread_serial_line_process_ptr;
              process_thread_serial_line_process_ptr ++;
              process_thread_serial_line_process_buf[tmp_1] = (char)((unsigned char)'\000');
              process_post((struct process *)0,serial_line_event_message,
                           (void *)(process_thread_serial_line_process_buf));
              tmp_2 = process_post(process_current,(unsigned char)0x85,
                                   (void *)0);
              if (0 == tmp_2) {
                PT_YIELD_FLAG = (char)0;
                process_pt->lc = (unsigned short)126;
                case 126: ;
                if ((int)PT_YIELD_FLAG == 0) goto _LOR;
                else 
                  if (! ((int)ev == 0x85)) {
                    _LOR: {
                            __retres = (char)1;
                            goto return_label;
                          }
                  }
              }
              process_thread_serial_line_process_ptr = 0;
            }
        }
      }
    }
    PT_YIELD_FLAG = (char)0;
    process_pt->lc = (unsigned short)0;
    __retres = (char)3;
    goto return_label;
  }
  return_label: return __retres;
}

void serial_line_init(void)
{
  ringbuf_init(& rxbuf,rxbuf_data,(unsigned char)sizeof(rxbuf_data));
  process_start(& serial_line_process,(void *)0);
  return;
}

__inline static unsigned int __bswap_32_26(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_26(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static leds_t const *leds_arch_leds = (leds_t const *)0;
void leds_init(void)
{
  leds_num_t led;
  led = (unsigned char)0;
  while ((int)led < 0) {
    gpio_hal_arch_no_port_pin_set_output((leds_arch_leds + led)->pin);
    led = (leds_num_t)((int)led + 1);
  }
  leds_off((unsigned char)((1 << 0) - 1));
  return;
}

void leds_single_on(leds_num_t led)
{
  if ((int)led >= 0) goto return_label;
  if ((leds_arch_leds + led)->negative_logic) gpio_hal_arch_no_port_clear_pin
                                              ((leds_arch_leds + led)->pin);
  else gpio_hal_arch_no_port_set_pin((leds_arch_leds + led)->pin);
  return_label: return;
}

void leds_single_off(leds_num_t led)
{
  if ((int)led >= 0) goto return_label;
  if ((leds_arch_leds + led)->negative_logic) gpio_hal_arch_no_port_set_pin
                                              ((leds_arch_leds + led)->pin);
  else gpio_hal_arch_no_port_clear_pin((leds_arch_leds + led)->pin);
  return_label: return;
}

void leds_single_toggle(leds_num_t led)
{
  if ((int)led >= 0) goto return_label;
  gpio_hal_arch_no_port_toggle_pin((leds_arch_leds + led)->pin);
  return_label: return;
}

void leds_on(leds_mask_t leds)
{
  leds_num_t led;
  led = (unsigned char)0;
  while ((int)led < 0) {
    if ((1 << (int)led) & (int)leds) 
      if ((leds_arch_leds + led)->negative_logic) gpio_hal_arch_no_port_clear_pin
                                                  ((leds_arch_leds + led)->pin);
      else gpio_hal_arch_no_port_set_pin((leds_arch_leds + led)->pin);
    led = (leds_num_t)((int)led + 1);
  }
  return;
}

void leds_off(leds_mask_t leds)
{
  leds_num_t led;
  led = (unsigned char)0;
  while ((int)led < 0) {
    if ((1 << (int)led) & (int)leds) 
      if ((leds_arch_leds + led)->negative_logic) gpio_hal_arch_no_port_set_pin
                                                  ((leds_arch_leds + led)->pin);
      else gpio_hal_arch_no_port_clear_pin((leds_arch_leds + led)->pin);
    led = (leds_num_t)((int)led + 1);
  }
  return;
}

void leds_toggle(leds_mask_t leds)
{
  leds_num_t led;
  led = (unsigned char)0;
  while ((int)led < 0) {
    if ((1 << (int)led) & (int)leds) gpio_hal_arch_no_port_toggle_pin
                                     ((leds_arch_leds + led)->pin);
    led = (leds_num_t)((int)led + 1);
  }
  return;
}

void leds_set(leds_mask_t leds)
{
  leds_off((unsigned char)((1 << 0) - 1));
  leds_on(leds);
  return;
}

leds_mask_t leds_get(void)
{
  leds_num_t led;
  uint8_t pin_state_0;
  leds_mask_t rv = (unsigned char)0;
  led = (unsigned char)0;
  while ((int)led < 0) {
    pin_state_0 = gpio_hal_arch_no_port_read_pin((leds_arch_leds + led)->pin);
    if ((int)(leds_arch_leds + led)->negative_logic == 0) {
      if ((int)pin_state_0 == 1) goto _LOR; else goto _LAND;
    }
    else {
      _LAND: ;
      if ((int)(leds_arch_leds + led)->negative_logic == 1) 
        if ((int)pin_state_0 == 0) _LOR:
                                   rv = (unsigned char)((int)rv | (1 << (int)led));
    }
    led = (leds_num_t)((int)led + 1);
  }
  return rv;
}

static int init(void)
{
  int __retres;
  __retres = 0;
  return __retres;
}

static int prepare(void const *payload, unsigned short payload_len)
{
  int __retres;
  __retres = 1;
  return __retres;
}

static int transmit(unsigned short transmit_len)
{
  int __retres;
  __retres = RADIO_TX_OK;
  return __retres;
}

static int send_0(void const *payload, unsigned short payload_len)
{
  int tmp;
  prepare(payload,payload_len);
  tmp = transmit(payload_len);
  return tmp;
}

static int radio_read(void *buf_0, unsigned short buf_len)
{
  int __retres;
  __retres = 0;
  return __retres;
}

static int channel_clear(void)
{
  int __retres;
  __retres = 1;
  return __retres;
}

static int receiving_packet(void)
{
  int __retres;
  __retres = 0;
  return __retres;
}

static int pending_packet(void)
{
  int __retres;
  __retres = 0;
  return __retres;
}

static int on(void)
{
  int __retres;
  __retres = 0;
  return __retres;
}

static int off(void)
{
  int __retres;
  __retres = 0;
  return __retres;
}

static radio_result_t get_value(radio_param_t param, radio_value_t *value)
{
  radio_result_t __retres;
  __retres = RADIO_RESULT_NOT_SUPPORTED;
  return __retres;
}

static radio_result_t set_value(radio_param_t param, radio_value_t value)
{
  radio_result_t __retres;
  __retres = RADIO_RESULT_NOT_SUPPORTED;
  return __retres;
}

static radio_result_t get_object(radio_param_t param, void *dest, size_t size)
{
  radio_result_t __retres;
  __retres = RADIO_RESULT_NOT_SUPPORTED;
  return __retres;
}

static radio_result_t set_object(radio_param_t param, void const *src,
                                 size_t size)
{
  radio_result_t __retres;
  __retres = RADIO_RESULT_NOT_SUPPORTED;
  return __retres;
}

struct radio_driver const nullradio_driver =
  {.init = & init,
   .prepare = & prepare,
   .transmit = & transmit,
   .send = & send_0,
   .read = & radio_read,
   .channel_clear = & channel_clear,
   .receiving_packet = & receiving_packet,
   .pending_packet = & pending_packet,
   .on = & on,
   .off = & off,
   .get_value = & get_value,
   .set_value = & set_value,
   .get_object = & get_object,
   .set_object = & set_object};
__inline static unsigned int __bswap_32_27(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_27(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static void *handlers_list = (void *)0;
static list_t handlers = & handlers_list;
void gpio_hal_register_handler(gpio_hal_event_handler_t *handler)
{
  list_add(handlers,(void *)handler);
  return;
}

void gpio_hal_event_handler(gpio_hal_pin_mask_t pins)
{
  gpio_hal_event_handler_t *this;
  this = (gpio_hal_event_handler_t *)list_head(handlers);
  while (this != (gpio_hal_event_handler_t *)0) {
    if (pins & this->pin_mask) 
      if (this->handler != (void (*)(gpio_hal_pin_mask_t pin_mask))0) 
        (*(this->handler))(pins & this->pin_mask);
    this = this->next;
  }
  return;
}

void gpio_hal_init(void)
{
  list_init(handlers);
  gpio_hal_arch_init();
  return;
}

void gpio_hal_arch_port_toggle_pin(gpio_hal_port_t port, gpio_hal_pin_t pin)
{
  uint8_t tmp;
  tmp = gpio_hal_arch_no_port_read_pin(pin);
  ;
  gpio_hal_arch_no_port_write_pin(pin,(unsigned char)((int)tmp ^ 1));
  return;
}

void gpio_hal_arch_port_toggle_pins(gpio_hal_port_t port,
                                    gpio_hal_pin_mask_t pins)
{
  gpio_hal_pin_mask_t tmp;
  tmp = gpio_hal_arch_no_port_read_pins(pins);
  ;
  gpio_hal_arch_no_port_write_pins(pins,~ tmp);
  return;
}

void gpio_hal_arch_no_port_toggle_pin(gpio_hal_pin_t pin)
{
  uint8_t tmp;
  if ((int)pin >= 32) {
    if (1 <= 0) {
      printf("[%-4s: %-10s] ","ERR","GPIO HAL");
      printf("Pin %u out of bounds\n",(int)pin);
    }
    goto return_label;
  }
  tmp = gpio_hal_arch_no_port_read_pin(pin);
  ;
  gpio_hal_arch_no_port_write_pin(pin,(unsigned char)((int)tmp ^ 1));
  return_label: return;
}

void gpio_hal_arch_no_port_toggle_pins(gpio_hal_pin_mask_t pins)
{
  gpio_hal_pin_mask_t tmp;
  tmp = gpio_hal_arch_no_port_read_pins(pins);
  ;
  gpio_hal_arch_no_port_write_pins(pins,~ tmp);
  return;
}

__inline static unsigned int __bswap_32_28(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_28(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void dbl_circ_list_init(dbl_circ_list_t dblcl);

void *dbl_circ_list_head(dbl_circ_list_t dblcl);

void *dbl_circ_list_tail(dbl_circ_list_t dblcl);

void dbl_circ_list_add_head(dbl_circ_list_t dblcl, void *element);

void dbl_circ_list_add_tail(dbl_circ_list_t dblcl, void *element);

void dbl_circ_list_add_after(dbl_circ_list_t dblcl, void *existing,
                             void *element);

void dbl_circ_list_add_before(dbl_circ_list_t dblcl, void *existing,
                              void *element);

void dbl_circ_list_remove(dbl_circ_list_t dblcl, void *element);

unsigned long dbl_circ_list_length(dbl_circ_list_t dblcl);

_Bool dbl_circ_list_is_empty(dbl_circ_list_t dblcl);

void dbl_circ_list_init(dbl_circ_list_t dblcl)
{
  *dblcl = (void *)0;
  return;
}

void *dbl_circ_list_head(dbl_circ_list_t dblcl)
{
  void *__retres;
  __retres = *dblcl;
  return __retres;
}

void *dbl_circ_list_tail(dbl_circ_list_t dblcl)
{
  void *__retres;
  struct dblcl *this;
  if (*dblcl == (void *)0) {
    __retres = (void *)0;
    goto return_label;
  }
  this = (struct dblcl *)*dblcl;
  while ((void *)this->next != *dblcl) this = this->next;
  __retres = (void *)this;
  return_label: return __retres;
}

void dbl_circ_list_remove(dbl_circ_list_t dblcl, void *element)
{
  struct dblcl *this;
  if (*dblcl == (void *)0) goto _LOR;
  else 
    if (element == (void *)0) _LOR: goto return_label;
  this = (struct dblcl *)*dblcl;
  while (1) {
    if ((void *)this == element) {
      (this->previous)->next = this->next;
      (this->next)->previous = this->previous;
      if (*dblcl == element) 
        if (this->next == this) *dblcl = (void *)0;
        else *dblcl = (void *)this->next;
      this->next = (struct dblcl *)0;
      this->previous = (struct dblcl *)0;
      goto return_label;
    }
    this = this->next;
    if (! ((void *)this != *dblcl)) break;
  }
  return_label: return;
}

void dbl_circ_list_add_head(dbl_circ_list_t dblcl, void *element)
{
  struct dblcl *head;
  if (element == (void *)0) goto return_label;
  dbl_circ_list_remove(dblcl,element);
  head = (struct dblcl *)dbl_circ_list_head(dblcl);
  if (head == (struct dblcl *)0) {
    ((struct dblcl *)element)->next = (struct dblcl *)element;
    ((struct dblcl *)element)->previous = (struct dblcl *)element;
  }
  else {
    ((struct dblcl *)element)->next = head;
    ((struct dblcl *)element)->previous = head->previous;
    (head->previous)->next = (struct dblcl *)element;
    head->previous = (struct dblcl *)element;
  }
  *dblcl = element;
  return_label: return;
}

void dbl_circ_list_add_tail(dbl_circ_list_t dblcl, void *element)
{
  struct dblcl *tail;
  if (element == (void *)0) goto return_label;
  dbl_circ_list_remove(dblcl,element);
  tail = (struct dblcl *)dbl_circ_list_tail(dblcl);
  if (tail == (struct dblcl *)0) {
    ((struct dblcl *)element)->next = (struct dblcl *)element;
    ((struct dblcl *)element)->previous = (struct dblcl *)element;
    *dblcl = element;
  }
  else {
    ((struct dblcl *)element)->next = (struct dblcl *)*dblcl;
    ((struct dblcl *)element)->previous = tail;
    (tail->next)->previous = (struct dblcl *)element;
    tail->next = (struct dblcl *)element;
  }
  return_label: return;
}

void dbl_circ_list_add_after(dbl_circ_list_t dblcl, void *existing,
                             void *element)
{
  if (element == (void *)0) goto _LOR;
  else 
    if (existing == (void *)0) _LOR: goto return_label;
  dbl_circ_list_remove(dblcl,element);
  ((struct dblcl *)element)->next = ((struct dblcl *)existing)->next;
  ((struct dblcl *)element)->previous = (struct dblcl *)existing;
  (((struct dblcl *)existing)->next)->previous = (struct dblcl *)element;
  ((struct dblcl *)existing)->next = (struct dblcl *)element;
  return_label: return;
}

void dbl_circ_list_add_before(dbl_circ_list_t dblcl, void *existing,
                              void *element)
{
  if (element == (void *)0) goto _LOR;
  else 
    if (existing == (void *)0) _LOR: goto return_label;
  dbl_circ_list_remove(dblcl,element);
  ((struct dblcl *)element)->next = (struct dblcl *)existing;
  ((struct dblcl *)element)->previous = ((struct dblcl *)existing)->previous;
  (((struct dblcl *)existing)->previous)->next = (struct dblcl *)element;
  ((struct dblcl *)existing)->previous = (struct dblcl *)element;
  if (*dblcl == existing) *dblcl = element;
  return_label: return;
}

unsigned long dbl_circ_list_length(dbl_circ_list_t dblcl)
{
  unsigned long __retres;
  struct dblcl *this;
  unsigned long len = (unsigned long)1;
  if (*dblcl == (void *)0) {
    __retres = (unsigned long)0;
    goto return_label;
  }
  this = (struct dblcl *)*dblcl;
  while ((void *)this->next != *dblcl) {
    len ++;
    this = this->next;
  }
  __retres = len;
  return_label: return __retres;
}

_Bool dbl_circ_list_is_empty(dbl_circ_list_t dblcl)
{
  _Bool __retres;
  int tmp;
  if (*dblcl == (void *)0) tmp = 1; else tmp = 0;
  __retres = (_Bool)(tmp != 0);
  return __retres;
}

unsigned short crc16_add(unsigned char b, unsigned short acc)
{
  acc = (unsigned short)((int)acc ^ (int)b);
  acc = (unsigned short)(((int)acc >> 8) | ((int)acc << 8));
  acc = (unsigned short)((int)acc ^ (((int)acc & 0xff00) << 4));
  acc = (unsigned short)((int)acc ^ (((int)acc >> 8) >> 4));
  acc = (unsigned short)((int)acc ^ (((int)acc & 0xff00) >> 5));
  return acc;
}

unsigned short crc16_data(unsigned char const *data, int len,
                          unsigned short acc)
{
  int i;
  i = 0;
  while (i < len) {
    acc = crc16_add(*data,acc);
    data ++;
    i ++;
  }
  return acc;
}

__inline static unsigned int __bswap_32_29(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_29(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void ifft(int16_t *xre, int16_t *xim, uint16_t n);

static int8_t const SIN_TAB[120] =
  {(signed char)0,
   (signed char)6,
   (signed char)13,
   (signed char)20,
   (signed char)26,
   (signed char)33,
   (signed char)39,
   (signed char)45,
   (signed char)52,
   (signed char)58,
   (signed char)63,
   (signed char)69,
   (signed char)75,
   (signed char)80,
   (signed char)85,
   (signed char)90,
   (signed char)95,
   (signed char)99,
   (signed char)103,
   (signed char)107,
   (signed char)110,
   (signed char)114,
   (signed char)116,
   (signed char)119,
   (signed char)121,
   (signed char)123,
   (signed char)125,
   (signed char)126,
   (signed char)127,
   (signed char)127,
   (signed char)127,
   (signed char)127,
   (signed char)127,
   (signed char)126,
   (signed char)125,
   (signed char)123,
   (signed char)121,
   (signed char)119,
   (signed char)116,
   (signed char)114,
   (signed char)110,
   (signed char)107,
   (signed char)103,
   (signed char)99,
   (signed char)95,
   (signed char)90,
   (signed char)85,
   (signed char)80,
   (signed char)75,
   (signed char)69,
   (signed char)63,
   (signed char)58,
   (signed char)52,
   (signed char)45,
   (signed char)39,
   (signed char)33,
   (signed char)26,
   (signed char)20,
   (signed char)13,
   (signed char)6,
   (signed char)0,
   (signed char)(-6),
   (signed char)(-13),
   (signed char)(-20),
   (signed char)(-26),
   (signed char)(-33),
   (signed char)(-39),
   (signed char)(-45),
   (signed char)(-52),
   (signed char)(-58),
   (signed char)(-63),
   (signed char)(-69),
   (signed char)(-75),
   (signed char)(-80),
   (signed char)(-85),
   (signed char)(-90),
   (signed char)(-95),
   (signed char)(-99),
   (signed char)(-103),
   (signed char)(-107),
   (signed char)(-110),
   (signed char)(-114),
   (signed char)(-116),
   (signed char)(-119),
   (signed char)(-121),
   (signed char)(-123),
   (signed char)(-125),
   (signed char)(-126),
   (signed char)(-127),
   (signed char)(-127),
   (signed char)(-127),
   (signed char)(-127),
   (signed char)(-127),
   (signed char)(-126),
   (signed char)(-125),
   (signed char)(-123),
   (signed char)(-121),
   (signed char)(-119),
   (signed char)(-116),
   (signed char)(-114),
   (signed char)(-110),
   (signed char)(-107),
   (signed char)(-103),
   (signed char)(-99),
   (signed char)(-95),
   (signed char)(-90),
   (signed char)(-85),
   (signed char)(-80),
   (signed char)(-75),
   (signed char)(-69),
   (signed char)(-63),
   (signed char)(-58),
   (signed char)(-52),
   (signed char)(-45),
   (signed char)(-39),
   (signed char)(-33),
   (signed char)(-26),
   (signed char)(-20),
   (signed char)(-13),
   (signed char)(-6)};
static uint16_t bitrev(uint16_t j, uint16_t nu)
{
  uint16_t k;
  k = (unsigned short)0;
  while ((int)nu > 0) {
    k = (unsigned short)(((int)k << 1) + ((int)j & 1));
    j = (unsigned short)((int)j >> 1);
    nu = (uint16_t)((int)nu - 1);
  }
  return k;
}

static int16_t sinI(uint16_t angleMilli)
{
  int16_t __retres;
  uint16_t pos;
  pos = (unsigned short)(((unsigned int)120 * (unsigned int)angleMilli) / (unsigned int)1000);
  __retres = (short)SIN_TAB[(int)pos % 120];
  return __retres;
}

static int16_t cosI(uint16_t angleMilli)
{
  int16_t tmp;
  tmp = sinI((unsigned short)((int)angleMilli + 250));
  return tmp;
}

static uint16_t ilog2(uint16_t val)
{
  uint16_t log;
  log = (unsigned short)0;
  val = (unsigned short)((int)val >> 1);
  while ((int)val > 0) {
    val = (unsigned short)((int)val >> 1);
    log = (uint16_t)((int)log + 1);
  }
  return log;
}

void ifft(int16_t *xre, int16_t *xim, uint16_t n)
{
  uint16_t nu;
  uint16_t n2;
  uint16_t nu1;
  int p;
  int k;
  int l;
  int i;
  int32_t c;
  int32_t s;
  int32_t tr;
  int32_t ti;
  nu = ilog2(n);
  nu1 = (unsigned short)((int)nu - 1);
  n2 = (unsigned short)((int)n / 2);
  i = 0;
  while (i < (int)n) {
    *(xim + i) = (short)0;
    i ++;
  }
  l = 1;
  while (l <= (int)nu) {
    k = 0;
    while (k < (int)n) {
      i = 1;
      while (i <= (int)n2) {
        {
          uint16_t tmp;
          int16_t tmp_0;
          int16_t tmp_1;
          tmp = bitrev((unsigned short)(k >> (int)nu1),nu);
          p = (int)tmp;
          tmp_0 = cosI((unsigned short)((1000 * p) / (int)n));
          c = (int)tmp_0;
          tmp_1 = sinI((unsigned short)((1000 * p) / (int)n));
          s = (int)tmp_1;
          tr = ((int)*(xre + (k + (int)n2)) * c + (int)*(xim + (k + (int)n2)) * s) >> 7;
          ti = ((int)*(xim + (k + (int)n2)) * c - (int)*(xre + (k + (int)n2)) * s) >> 7;
          *(xre + (k + (int)n2)) = (short)((int)*(xre + k) - tr);
          *(xim + (k + (int)n2)) = (short)((int)*(xim + k) - ti);
          *(xre + k) = (short)((int)*(xre + k) + tr);
          *(xim + k) = (short)((int)*(xim + k) + ti);
          k ++;
        }
        i ++;
      }
      k += (int)n2;
    }
    nu1 = (uint16_t)((int)nu1 - 1);
    n2 = (unsigned short)((int)n2 / 2);
    l ++;
  }
  k = 0;
  while (k < (int)n) {
    {
      uint16_t tmp_2;
      tmp_2 = bitrev((unsigned short)k,nu);
      p = (int)tmp_2;
      if (p > k) {
        n2 = (unsigned short)*(xre + k);
        *(xre + k) = *(xre + p);
        *(xre + p) = (short)n2;
        n2 = (unsigned short)*(xim + k);
        *(xim + k) = *(xim + p);
        *(xim + p) = (short)n2;
      }
    }
    k ++;
  }
  i = 0;
  n2 = (unsigned short)((int)n / 2);
  while (i < (int)n2) {
    {
      int tmp_3;
      int tmp_4;
      if ((int)*(xre + i) < 0) tmp_3 = - ((int)*(xre + i));
      else tmp_3 = (int)*(xre + i);
      if ((int)*(xim + i) < 0) tmp_4 = - ((int)*(xim + i));
      else tmp_4 = (int)*(xim + i);
      *(xre + i) = (short)(tmp_3 + tmp_4);
    }
    i ++;
  }
  return;
}

__inline static unsigned int __bswap_32_30(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_30(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

struct ccm_star_driver const ccm_star_driver;

struct aes_128_driver const aes_128_driver;

static void set_iv(uint8_t *iv, uint8_t flags, uint8_t const *nonce,
                   uint8_t counter)
{
  *(iv + 0) = flags;
  memcpy((void *)(iv + 1),(void const *)nonce,(unsigned long)13);
  *(iv + 14) = (unsigned char)0;
  *(iv + 15) = counter;
  return;
}

static void ctr_step(uint8_t const *nonce, uint8_t pos,
                     uint8_t *m_and_result, uint8_t m_len, uint8_t counter)
{
  uint8_t a[16];
  uint8_t i;
  set_iv(a,(unsigned char)1,nonce,counter);
  (*(aes_128_driver.encrypt))(a);
  i = (unsigned char)0;
  while (1) {
    if ((int)pos + (int)i < (int)m_len) {
      if (! ((int)i < 16)) break;
    }
    else break;
    *(m_and_result + ((int)pos + (int)i)) = (unsigned char)((int)*(m_and_result + (
                                                                   (int)pos + (int)i)) ^ (int)a[i]);
    i = (uint8_t)((int)i + 1);
  }
  return;
}

static void mic(uint8_t const *nonce, uint8_t const *m, uint8_t m_len,
                uint8_t const *a, uint8_t a_len, uint8_t *result,
                uint8_t mic_len)
{
  uint8_t x[16];
  uint8_t pos;
  uint8_t i;
  unsigned int tmp;
  ;
  ;
  if (a_len) tmp = 1u << 6; else tmp = (unsigned int)0;
  ;
  set_iv(x,
         (unsigned char)((tmp | ((((unsigned int)mic_len - 2u) >> 1) << 3)) | 1u),
         nonce,m_len);
  (*(aes_128_driver.encrypt))(x);
  if (a_len) {
    x[1] = (unsigned char)((int)x[1] ^ (int)a_len);
    i = (unsigned char)2;
    while (1) {
      if ((int)i - 2 < (int)a_len) {
        if (! ((int)i < 16)) break;
      }
      else break;
      x[i] = (unsigned char)((int)x[i] ^ (int)*(a + ((int)i - 2)));
      i = (uint8_t)((int)i + 1);
    }
    (*(aes_128_driver.encrypt))(x);
    pos = (unsigned char)14;
    while ((int)pos < (int)a_len) {
      i = (unsigned char)0;
      while (1) {
        if ((int)pos + (int)i < (int)a_len) {
          if (! ((int)i < 16)) break;
        }
        else break;
        x[i] = (unsigned char)((int)x[i] ^ (int)*(a + ((int)pos + (int)i)));
        i = (uint8_t)((int)i + 1);
      }
      pos = (unsigned char)((int)pos + 16);
      (*(aes_128_driver.encrypt))(x);
    }
  }
  if (m_len) {
    pos = (unsigned char)0;
    while ((int)pos < (int)m_len) {
      i = (unsigned char)0;
      while (1) {
        if ((int)pos + (int)i < (int)m_len) {
          if (! ((int)i < 16)) break;
        }
        else break;
        x[i] = (unsigned char)((int)x[i] ^ (int)*(m + ((int)pos + (int)i)));
        i = (uint8_t)((int)i + 1);
      }
      pos = (unsigned char)((int)pos + 16);
      (*(aes_128_driver.encrypt))(x);
    }
  }
  ctr_step(nonce,(unsigned char)0,x,(unsigned char)16,(unsigned char)0);
  memcpy((void *)result,(void const *)(x),(unsigned long)mic_len);
  return;
}

static void ctr(uint8_t const *nonce, uint8_t *m, uint8_t m_len)
{
  uint8_t pos;
  uint8_t counter;
  pos = (unsigned char)0;
  counter = (unsigned char)1;
  while ((int)pos < (int)m_len) {
    uint8_t tmp;
    tmp = counter;
    counter = (uint8_t)((int)counter + 1);
    ;
    ;
    ;
    ;
    ;
    ctr_step(nonce,pos,m,m_len,tmp);
    pos = (unsigned char)((int)pos + 16);
  }
  return;
}

static void set_key(uint8_t const *key)
{
  (*(aes_128_driver.set_key))(key);
  return;
}

static void aead(uint8_t const *nonce, uint8_t *m, uint8_t m_len,
                 uint8_t const *a, uint8_t a_len, uint8_t *result,
                 uint8_t mic_len, int forward)
{
  if (! forward) ctr(nonce,m,m_len);
  mic(nonce,(uint8_t const *)m,m_len,a,a_len,result,mic_len);
  if (forward) ctr(nonce,m,m_len);
  return;
}

struct ccm_star_driver const ccm_star_driver =
  {.set_key = & set_key, .aead = & aead};
__inline static unsigned int __bswap_32_31(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_31(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void dbl_list_init(dbl_list_t dll);

void *dbl_list_head(dbl_list_t dll);

void *dbl_list_tail(dbl_list_t dll);

void dbl_list_add_head(dbl_list_t dll, void *element);

void dbl_list_add_tail(dbl_list_t dll, void *element);

void dbl_list_add_after(dbl_list_t dll, void *existing, void *element);

void dbl_list_add_before(dbl_list_t dll, void *existing, void *element);

void dbl_list_remove(dbl_list_t dll, void *element);

unsigned long dbl_list_length(dbl_list_t dll);

_Bool dbl_list_is_empty(dbl_list_t dll);

void dbl_list_init(dbl_list_t dll)
{
  *dll = (void *)0;
  return;
}

void *dbl_list_head(dbl_list_t dll)
{
  void *__retres;
  __retres = *dll;
  return __retres;
}

void *dbl_list_tail(dbl_list_t dll)
{
  void *__retres;
  struct dll *this;
  if (*dll == (void *)0) {
    __retres = (void *)0;
    goto return_label;
  }
  this = (struct dll *)*dll;
  while (this->next != (struct dll *)0) this = this->next;
  __retres = (void *)this;
  return_label: return __retres;
}

void dbl_list_remove(dbl_list_t dll, void *element)
{
  struct dll *this;
  struct dll *previous;
  struct dll *next;
  if (*dll == (void *)0) goto _LOR;
  else 
    if (element == (void *)0) _LOR: goto return_label;
  this = (struct dll *)*dll;
  while (this != (struct dll *)0) {
    if ((void *)this == element) {
      previous = this->previous;
      next = this->next;
      if (previous) previous->next = this->next;
      if (next) next->previous = this->previous;
      if (*dll == (void *)this) *dll = (void *)next;
      goto return_label;
    }
    this = this->next;
  }
  return_label: return;
}

void dbl_list_add_head(dbl_list_t dll, void *element)
{
  struct dll *head;
  if (element == (void *)0) goto return_label;
  dbl_list_remove(dll,element);
  head = (struct dll *)dbl_list_head(dll);
  ((struct dll *)element)->previous = (struct dll *)0;
  ((struct dll *)element)->next = head;
  if (head) head->previous = (struct dll *)element;
  *dll = element;
  return_label: return;
}

void dbl_list_add_tail(dbl_list_t dll, void *element)
{
  struct dll *tail;
  if (element == (void *)0) goto return_label;
  dbl_list_remove(dll,element);
  tail = (struct dll *)dbl_list_tail(dll);
  if (tail == (struct dll *)0) *dll = element;
  else tail->next = (struct dll *)element;
  ((struct dll *)element)->previous = tail;
  ((struct dll *)element)->next = (struct dll *)0;
  return_label: return;
}

void dbl_list_add_after(dbl_list_t dll, void *existing, void *element)
{
  if (element == (void *)0) goto _LOR;
  else 
    if (existing == (void *)0) _LOR: goto return_label;
  dbl_list_remove(dll,element);
  ((struct dll *)element)->next = ((struct dll *)existing)->next;
  ((struct dll *)element)->previous = (struct dll *)existing;
  if (((struct dll *)existing)->next) (((struct dll *)existing)->next)->previous = (struct dll *)element;
  ((struct dll *)existing)->next = (struct dll *)element;
  return_label: return;
}

void dbl_list_add_before(dbl_list_t dll, void *existing, void *element)
{
  if (element == (void *)0) goto _LOR;
  else 
    if (existing == (void *)0) _LOR: goto return_label;
  dbl_list_remove(dll,element);
  ((struct dll *)element)->next = (struct dll *)existing;
  ((struct dll *)element)->previous = ((struct dll *)existing)->previous;
  if (((struct dll *)existing)->previous) (((struct dll *)existing)->previous)->next = (struct dll *)element;
  ((struct dll *)existing)->previous = (struct dll *)element;
  if (*dll == existing) *dll = element;
  return_label: return;
}

unsigned long dbl_list_length(dbl_list_t dll)
{
  unsigned long __retres;
  struct dll *this;
  unsigned long len = (unsigned long)0;
  if (*dll == (void *)0) {
    __retres = (unsigned long)0;
    goto return_label;
  }
  this = (struct dll *)*dll;
  while (this != (struct dll *)0) {
    len ++;
    this = this->next;
  }
  __retres = len;
  return_label: return __retres;
}

_Bool dbl_list_is_empty(dbl_list_t dll)
{
  _Bool __retres;
  int tmp;
  if (*dll == (void *)0) tmp = 1; else tmp = 0;
  __retres = (_Bool)(tmp != 0);
  return __retres;
}

__inline static unsigned int __bswap_32_32(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_32(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void ringbufindex_init(struct ringbufindex *r, uint8_t size)
{
  r->mask = (unsigned char)((int)size - 1);
  r->put_ptr = (unsigned char)0;
  r->get_ptr = (unsigned char)0;
  return;
}

int ringbufindex_put(struct ringbufindex *r)
{
  int __retres;
  if ((((int)r->put_ptr - (int)r->get_ptr) & (int)r->mask) == (int)r->mask) {
    __retres = 0;
    goto return_label;
  }
  r->put_ptr = (unsigned char)(((int)r->put_ptr + 1) & (int)r->mask);
  __retres = 1;
  return_label: return __retres;
}

int ringbufindex_peek_put(struct ringbufindex const *r)
{
  int __retres;
  if ((((int)r->put_ptr - (int)r->get_ptr) & (int)r->mask) == (int)r->mask) {
    __retres = -1;
    goto return_label;
  }
  __retres = (int)r->put_ptr;
  return_label: return __retres;
}

int ringbufindex_get(struct ringbufindex *r)
{
  int __retres;
  int get_ptr;
  if ((((int)r->put_ptr - (int)r->get_ptr) & (int)r->mask) > 0) {
    get_ptr = (int)r->get_ptr;
    r->get_ptr = (unsigned char)(((int)r->get_ptr + 1) & (int)r->mask);
    __retres = get_ptr;
    goto return_label;
  }
  else {
    __retres = -1;
    goto return_label;
  }
  return_label: return __retres;
}

int ringbufindex_peek_get(struct ringbufindex const *r)
{
  int __retres;
  if ((((int)r->put_ptr - (int)r->get_ptr) & (int)r->mask) > 0) {
    __retres = (int)r->get_ptr;
    goto return_label;
  }
  else {
    __retres = -1;
    goto return_label;
  }
  return_label: return __retres;
}

int ringbufindex_size(struct ringbufindex const *r)
{
  int __retres;
  __retres = (int)r->mask + 1;
  return __retres;
}

int ringbufindex_elements(struct ringbufindex const *r)
{
  int __retres;
  __retres = ((int)r->put_ptr - (int)r->get_ptr) & (int)r->mask;
  return __retres;
}

int ringbufindex_full(struct ringbufindex const *r)
{
  int __retres;
  __retres = (((int)r->put_ptr - (int)r->get_ptr) & (int)r->mask) == (int)r->mask;
  return __retres;
}

int ringbufindex_empty(struct ringbufindex const *r)
{
  int __retres;
  int tmp;
  tmp = ringbufindex_elements(r);
  __retres = tmp == 0;
  return __retres;
}

__inline static unsigned int __bswap_32_33(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_33(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void list_init(list_t list)
{
  *list = (void *)0;
  return;
}

void *list_head(list_t list)
{
  void *__retres;
  __retres = *list;
  return __retres;
}

void list_copy(list_t dest, list_t src)
{
  *dest = *src;
  return;
}

void *list_tail(list_t list)
{
  void *__retres;
  struct list *l;
  if (*list == (void *)0) {
    __retres = (void *)0;
    goto return_label;
  }
  l = (struct list *)*list;
  while (l->next != (struct list *)0) l = l->next;
  __retres = (void *)l;
  return_label: return __retres;
}

void list_add(list_t list, void *item)
{
  struct list *l;
  list_remove(list,item);
  ((struct list *)item)->next = (struct list *)0;
  l = (struct list *)list_tail(list);
  if (l == (struct list *)0) *list = item;
  else l->next = (struct list *)item;
  return;
}

void list_push(list_t list, void *item)
{
  list_remove(list,item);
  ((struct list *)item)->next = (struct list *)*list;
  *list = item;
  return;
}

void *list_chop(list_t list)
{
  void *__retres;
  struct list *l;
  struct list *r;
  if (*list == (void *)0) {
    __retres = (void *)0;
    goto return_label;
  }
  if (((struct list *)*list)->next == (struct list *)0) {
    l = (struct list *)*list;
    *list = (void *)0;
    __retres = (void *)l;
    goto return_label;
  }
  l = (struct list *)*list;
  while ((l->next)->next != (struct list *)0) l = l->next;
  r = l->next;
  l->next = (struct list *)0;
  __retres = (void *)r;
  return_label: return __retres;
}

void *list_pop(list_t list)
{
  void *__retres;
  struct list *l;
  l = (struct list *)*list;
  if (*list != (void *)0) *list = (void *)((struct list *)*list)->next;
  __retres = (void *)l;
  return __retres;
}

void list_remove(list_t list, void *item)
{
  struct list *l;
  struct list *r;
  if (*list == (void *)0) goto return_label;
  r = (struct list *)0;
  l = (struct list *)*list;
  while (l != (struct list *)0) {
    if ((void *)l == item) {
      if (r == (struct list *)0) *list = (void *)l->next;
      else r->next = l->next;
      l->next = (struct list *)0;
      goto return_label;
    }
    r = l;
    l = l->next;
  }
  return_label: return;
}

int list_length(list_t list)
{
  struct list *l;
  int n = 0;
  l = (struct list *)*list;
  while (l != (struct list *)0) {
    n ++;
    l = l->next;
  }
  return n;
}

void list_insert(list_t list, void *previtem, void *newitem)
{
  if (previtem == (void *)0) list_push(list,newitem);
  else {
    list_remove(list,newitem);
    ((struct list *)newitem)->next = ((struct list *)previtem)->next;
    ((struct list *)previtem)->next = (struct list *)newitem;
  }
  return;
}

void *list_item_next(void *item)
{
  void *__retres;
  struct list *tmp;
  if (item == (void *)0) tmp = (struct list *)0;
  else tmp = ((struct list *)item)->next;
  __retres = (void *)tmp;
  return __retres;
}

_Bool list_contains(list_t list, void *item)
{
  _Bool __retres;
  struct list *l;
  l = (struct list *)*list;
  while (l != (struct list *)0) {
    if (item == (void *)l) {
      __retres = (_Bool)1;
      goto return_label;
    }
    l = l->next;
  }
  __retres = (_Bool)0;
  return_label: return __retres;
}

__inline static unsigned int __bswap_32_34(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_34(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void circular_list_init(circular_list_t cl);

void *circular_list_head(circular_list_t cl);

void *circular_list_tail(circular_list_t cl);

void circular_list_add(circular_list_t cl, void *element);

void circular_list_remove(circular_list_t cl, void *element);

unsigned long circular_list_length(circular_list_t cl);

_Bool circular_list_is_empty(circular_list_t cl);

void circular_list_init(circular_list_t cl)
{
  *cl = (void *)0;
  return;
}

void *circular_list_head(circular_list_t cl)
{
  void *__retres;
  __retres = *cl;
  return __retres;
}

void *circular_list_tail(circular_list_t cl)
{
  void *__retres;
  struct cl *this;
  if (*cl == (void *)0) {
    __retres = (void *)0;
    goto return_label;
  }
  this = (struct cl *)*cl;
  while ((void *)this->next != *cl) this = this->next;
  __retres = (void *)this;
  return_label: return __retres;
}

void circular_list_remove(circular_list_t cl, void *element)
{
  struct cl *this;
  struct cl *previous;
  if (*cl == (void *)0) goto return_label;
  previous = (struct cl *)*cl;
  this = previous->next;
  while (1) {
    if ((void *)this == element) {
      previous->next = this->next;
      if (this->next == this) *cl = (void *)0; else *cl = (void *)previous;
      goto return_label;
    }
    previous = this;
    this = this->next;
    if (! (this != ((struct cl *)*cl)->next)) break;
  }
  return_label: return;
}

void circular_list_add(circular_list_t cl, void *element)
{
  struct cl *head;
  if (element == (void *)0) goto return_label;
  circular_list_remove(cl,element);
  head = (struct cl *)*cl;
  if (head == (struct cl *)0) ((struct cl *)element)->next = (struct cl *)element;
  else {
    ((struct cl *)element)->next = head->next;
    head->next = (struct cl *)element;
  }
  *cl = element;
  return_label: return;
}

unsigned long circular_list_length(circular_list_t cl)
{
  unsigned long __retres;
  struct cl *this;
  _Bool tmp;
  unsigned long len = (unsigned long)1;
  tmp = circular_list_is_empty(cl);
  if (tmp) {
    __retres = (unsigned long)0;
    goto return_label;
  }
  this = (struct cl *)*cl;
  while ((void *)this->next != *cl) {
    len ++;
    this = this->next;
  }
  __retres = len;
  return_label: return __retres;
}

_Bool circular_list_is_empty(circular_list_t cl)
{
  _Bool __retres;
  int tmp;
  if (*cl == (void *)0) tmp = 1; else tmp = 0;
  __retres = (_Bool)(tmp != 0);
  return __retres;
}

__inline static unsigned int __bswap_32_35(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_35(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static uint8_t const sbox[256] =
  {(unsigned char)0x63,
   (unsigned char)0x7c,
   (unsigned char)0x77,
   (unsigned char)0x7b,
   (unsigned char)0xf2,
   (unsigned char)0x6b,
   (unsigned char)0x6f,
   (unsigned char)0xc5,
   (unsigned char)0x30,
   (unsigned char)0x01,
   (unsigned char)0x67,
   (unsigned char)0x2b,
   (unsigned char)0xfe,
   (unsigned char)0xd7,
   (unsigned char)0xab,
   (unsigned char)0x76,
   (unsigned char)0xca,
   (unsigned char)0x82,
   (unsigned char)0xc9,
   (unsigned char)0x7d,
   (unsigned char)0xfa,
   (unsigned char)0x59,
   (unsigned char)0x47,
   (unsigned char)0xf0,
   (unsigned char)0xad,
   (unsigned char)0xd4,
   (unsigned char)0xa2,
   (unsigned char)0xaf,
   (unsigned char)0x9c,
   (unsigned char)0xa4,
   (unsigned char)0x72,
   (unsigned char)0xc0,
   (unsigned char)0xb7,
   (unsigned char)0xfd,
   (unsigned char)0x93,
   (unsigned char)0x26,
   (unsigned char)0x36,
   (unsigned char)0x3f,
   (unsigned char)0xf7,
   (unsigned char)0xcc,
   (unsigned char)0x34,
   (unsigned char)0xa5,
   (unsigned char)0xe5,
   (unsigned char)0xf1,
   (unsigned char)0x71,
   (unsigned char)0xd8,
   (unsigned char)0x31,
   (unsigned char)0x15,
   (unsigned char)0x04,
   (unsigned char)0xc7,
   (unsigned char)0x23,
   (unsigned char)0xc3,
   (unsigned char)0x18,
   (unsigned char)0x96,
   (unsigned char)0x05,
   (unsigned char)0x9a,
   (unsigned char)0x07,
   (unsigned char)0x12,
   (unsigned char)0x80,
   (unsigned char)0xe2,
   (unsigned char)0xeb,
   (unsigned char)0x27,
   (unsigned char)0xb2,
   (unsigned char)0x75,
   (unsigned char)0x09,
   (unsigned char)0x83,
   (unsigned char)0x2c,
   (unsigned char)0x1a,
   (unsigned char)0x1b,
   (unsigned char)0x6e,
   (unsigned char)0x5a,
   (unsigned char)0xa0,
   (unsigned char)0x52,
   (unsigned char)0x3b,
   (unsigned char)0xd6,
   (unsigned char)0xb3,
   (unsigned char)0x29,
   (unsigned char)0xe3,
   (unsigned char)0x2f,
   (unsigned char)0x84,
   (unsigned char)0x53,
   (unsigned char)0xd1,
   (unsigned char)0x00,
   (unsigned char)0xed,
   (unsigned char)0x20,
   (unsigned char)0xfc,
   (unsigned char)0xb1,
   (unsigned char)0x5b,
   (unsigned char)0x6a,
   (unsigned char)0xcb,
   (unsigned char)0xbe,
   (unsigned char)0x39,
   (unsigned char)0x4a,
   (unsigned char)0x4c,
   (unsigned char)0x58,
   (unsigned char)0xcf,
   (unsigned char)0xd0,
   (unsigned char)0xef,
   (unsigned char)0xaa,
   (unsigned char)0xfb,
   (unsigned char)0x43,
   (unsigned char)0x4d,
   (unsigned char)0x33,
   (unsigned char)0x85,
   (unsigned char)0x45,
   (unsigned char)0xf9,
   (unsigned char)0x02,
   (unsigned char)0x7f,
   (unsigned char)0x50,
   (unsigned char)0x3c,
   (unsigned char)0x9f,
   (unsigned char)0xa8,
   (unsigned char)0x51,
   (unsigned char)0xa3,
   (unsigned char)0x40,
   (unsigned char)0x8f,
   (unsigned char)0x92,
   (unsigned char)0x9d,
   (unsigned char)0x38,
   (unsigned char)0xf5,
   (unsigned char)0xbc,
   (unsigned char)0xb6,
   (unsigned char)0xda,
   (unsigned char)0x21,
   (unsigned char)0x10,
   (unsigned char)0xff,
   (unsigned char)0xf3,
   (unsigned char)0xd2,
   (unsigned char)0xcd,
   (unsigned char)0x0c,
   (unsigned char)0x13,
   (unsigned char)0xec,
   (unsigned char)0x5f,
   (unsigned char)0x97,
   (unsigned char)0x44,
   (unsigned char)0x17,
   (unsigned char)0xc4,
   (unsigned char)0xa7,
   (unsigned char)0x7e,
   (unsigned char)0x3d,
   (unsigned char)0x64,
   (unsigned char)0x5d,
   (unsigned char)0x19,
   (unsigned char)0x73,
   (unsigned char)0x60,
   (unsigned char)0x81,
   (unsigned char)0x4f,
   (unsigned char)0xdc,
   (unsigned char)0x22,
   (unsigned char)0x2a,
   (unsigned char)0x90,
   (unsigned char)0x88,
   (unsigned char)0x46,
   (unsigned char)0xee,
   (unsigned char)0xb8,
   (unsigned char)0x14,
   (unsigned char)0xde,
   (unsigned char)0x5e,
   (unsigned char)0x0b,
   (unsigned char)0xdb,
   (unsigned char)0xe0,
   (unsigned char)0x32,
   (unsigned char)0x3a,
   (unsigned char)0x0a,
   (unsigned char)0x49,
   (unsigned char)0x06,
   (unsigned char)0x24,
   (unsigned char)0x5c,
   (unsigned char)0xc2,
   (unsigned char)0xd3,
   (unsigned char)0xac,
   (unsigned char)0x62,
   (unsigned char)0x91,
   (unsigned char)0x95,
   (unsigned char)0xe4,
   (unsigned char)0x79,
   (unsigned char)0xe7,
   (unsigned char)0xc8,
   (unsigned char)0x37,
   (unsigned char)0x6d,
   (unsigned char)0x8d,
   (unsigned char)0xd5,
   (unsigned char)0x4e,
   (unsigned char)0xa9,
   (unsigned char)0x6c,
   (unsigned char)0x56,
   (unsigned char)0xf4,
   (unsigned char)0xea,
   (unsigned char)0x65,
   (unsigned char)0x7a,
   (unsigned char)0xae,
   (unsigned char)0x08,
   (unsigned char)0xba,
   (unsigned char)0x78,
   (unsigned char)0x25,
   (unsigned char)0x2e,
   (unsigned char)0x1c,
   (unsigned char)0xa6,
   (unsigned char)0xb4,
   (unsigned char)0xc6,
   (unsigned char)0xe8,
   (unsigned char)0xdd,
   (unsigned char)0x74,
   (unsigned char)0x1f,
   (unsigned char)0x4b,
   (unsigned char)0xbd,
   (unsigned char)0x8b,
   (unsigned char)0x8a,
   (unsigned char)0x70,
   (unsigned char)0x3e,
   (unsigned char)0xb5,
   (unsigned char)0x66,
   (unsigned char)0x48,
   (unsigned char)0x03,
   (unsigned char)0xf6,
   (unsigned char)0x0e,
   (unsigned char)0x61,
   (unsigned char)0x35,
   (unsigned char)0x57,
   (unsigned char)0xb9,
   (unsigned char)0x86,
   (unsigned char)0xc1,
   (unsigned char)0x1d,
   (unsigned char)0x9e,
   (unsigned char)0xe1,
   (unsigned char)0xf8,
   (unsigned char)0x98,
   (unsigned char)0x11,
   (unsigned char)0x69,
   (unsigned char)0xd9,
   (unsigned char)0x8e,
   (unsigned char)0x94,
   (unsigned char)0x9b,
   (unsigned char)0x1e,
   (unsigned char)0x87,
   (unsigned char)0xe9,
   (unsigned char)0xce,
   (unsigned char)0x55,
   (unsigned char)0x28,
   (unsigned char)0xdf,
   (unsigned char)0x8c,
   (unsigned char)0xa1,
   (unsigned char)0x89,
   (unsigned char)0x0d,
   (unsigned char)0xbf,
   (unsigned char)0xe6,
   (unsigned char)0x42,
   (unsigned char)0x68,
   (unsigned char)0x41,
   (unsigned char)0x99,
   (unsigned char)0x2d,
   (unsigned char)0x0f,
   (unsigned char)0xb0,
   (unsigned char)0x54,
   (unsigned char)0xbb,
   (unsigned char)0x16};
static uint8_t round_keys[11][16];
static uint8_t galois_mul2(uint8_t value)
{
  uint8_t __retres;
  uint8_t xor_val = (unsigned char)(((int)value >> 7) * 0x1b);
  __retres = (unsigned char)(((int)value << 1) ^ (int)xor_val);
  return __retres;
}

static void set_key_0(uint8_t const *key)
{
  uint8_t i;
  uint8_t j;
  uint8_t rcon;
  rcon = (unsigned char)0x01;
  memcpy((void *)(round_keys[0]),(void const *)key,(unsigned long)16);
  i = (unsigned char)1;
  while ((int)i <= 10) {
    round_keys[i][0] = (unsigned char)(((int)sbox[round_keys[(int)i - 1][13]] ^ (int)round_keys[
                                        (int)i - 1][0]) ^ (int)rcon);
    round_keys[i][1] = (unsigned char)((int)sbox[round_keys[(int)i - 1][14]] ^ (int)round_keys[
                                       (int)i - 1][1]);
    round_keys[i][2] = (unsigned char)((int)sbox[round_keys[(int)i - 1][15]] ^ (int)round_keys[
                                       (int)i - 1][2]);
    round_keys[i][3] = (unsigned char)((int)sbox[round_keys[(int)i - 1][12]] ^ (int)round_keys[
                                       (int)i - 1][3]);
    j = (unsigned char)4;
    while ((int)j < 16) {
      round_keys[i][j] = (unsigned char)((int)round_keys[(int)i - 1][j] ^ (int)round_keys[i][
                                         (int)j - 4]);
      j = (uint8_t)((int)j + 1);
    }
    rcon = galois_mul2(rcon);
    i = (uint8_t)((int)i + 1);
  }
  return;
}

static void encrypt(uint8_t *state)
{
  uint8_t buf1;
  uint8_t buf2;
  uint8_t buf3;
  uint8_t buf4;
  uint8_t round;
  uint8_t i;
  i = (unsigned char)0;
  while ((int)i < 16) {
    *(state + i) = (unsigned char)((int)*(state + i) ^ (int)round_keys[0][i]);
    i = (uint8_t)((int)i + 1);
  }
  round = (unsigned char)1;
  while ((int)round <= 10) {
    i = (unsigned char)0;
    while ((int)i < 16) {
      *(state + i) = sbox[*(state + i)];
      i = (uint8_t)((int)i + 1);
    }
    buf1 = *(state + 1);
    *(state + 1) = *(state + 5);
    *(state + 5) = *(state + 9);
    *(state + 9) = *(state + 13);
    *(state + 13) = buf1;
    buf1 = *(state + 2);
    buf2 = *(state + 6);
    *(state + 2) = *(state + 10);
    *(state + 6) = *(state + 14);
    *(state + 10) = buf1;
    *(state + 14) = buf2;
    buf1 = *(state + 15);
    *(state + 15) = *(state + 11);
    *(state + 11) = *(state + 7);
    *(state + 7) = *(state + 3);
    *(state + 3) = buf1;
    if ((int)round < 10) {
      i = (unsigned char)0;
      while ((int)i < 4) {
        buf4 = (unsigned char)((int)i << 2);
        buf1 = (unsigned char)((((int)*(state + buf4) ^ (int)*(state + (
                                                               (int)buf4 + 1))) ^ (int)*(
                                state + ((int)buf4 + 2))) ^ (int)*(state + (
                                                                   (int)buf4 + 3)));
        buf2 = *(state + buf4);
        buf3 = (unsigned char)((int)*(state + buf4) ^ (int)*(state + (
                                                             (int)buf4 + 1)));
        buf3 = galois_mul2(buf3);
        *(state + buf4) = (unsigned char)(((int)*(state + buf4) ^ (int)buf3) ^ (int)buf1);
        buf3 = (unsigned char)((int)*(state + ((int)buf4 + 1)) ^ (int)*(
                               state + ((int)buf4 + 2)));
        buf3 = galois_mul2(buf3);
        *(state + ((int)buf4 + 1)) = (unsigned char)(((int)*(state + (
                                                             (int)buf4 + 1)) ^ (int)buf3) ^ (int)buf1);
        buf3 = (unsigned char)((int)*(state + ((int)buf4 + 2)) ^ (int)*(
                               state + ((int)buf4 + 3)));
        buf3 = galois_mul2(buf3);
        *(state + ((int)buf4 + 2)) = (unsigned char)(((int)*(state + (
                                                             (int)buf4 + 2)) ^ (int)buf3) ^ (int)buf1);
        buf3 = (unsigned char)((int)*(state + ((int)buf4 + 3)) ^ (int)buf2);
        buf3 = galois_mul2(buf3);
        *(state + ((int)buf4 + 3)) = (unsigned char)(((int)*(state + (
                                                             (int)buf4 + 3)) ^ (int)buf3) ^ (int)buf1);
        i = (uint8_t)((int)i + 1);
      }
    }
    i = (unsigned char)0;
    while ((int)i < 16) {
      *(state + i) = (unsigned char)((int)*(state + i) ^ (int)round_keys[round][i]);
      i = (uint8_t)((int)i + 1);
    }
    round = (uint8_t)((int)round + 1);
  }
  return;
}

struct aes_128_driver const aes_128_driver =
  {.set_key = & set_key_0, .encrypt = & encrypt};
__inline static unsigned int __bswap_32_36(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_36(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

uint8_t trickle_timer_config(struct trickle_timer *tt, clock_time_t i_min,
                             uint8_t i_max, uint8_t k);

uint8_t trickle_timer_set(struct trickle_timer *tt,
                          void (*proto_cb)(void *ptr, uint8_t suppress),
                          void *ptr);

void trickle_timer_consistency(struct trickle_timer *tt);

void trickle_timer_inconsistency(struct trickle_timer *tt);

static struct trickle_timer *loctt;
static clock_time_t loc_clock;
static void fire(void *ptr);

static void double_interval(void *ptr);

static uint32_t wide_rand(void)
{
  uint32_t __retres;
  unsigned short tmp;
  unsigned short tmp_0;
  tmp = random_rand();
  tmp_0 = random_rand();
  __retres = ((unsigned int)tmp << 16) | (unsigned int)tmp_0;
  return __retres;
}

static uint8_t max_imax(clock_time_t value)
{
  uint8_t __retres;
  uint8_t i;
  uint8_t zeros = (unsigned char)0;
  clock_time_t mask = (unsigned long)0xFFFF;
  value --;
  i = (unsigned char)(sizeof(clock_time_t) << 2);
  while ((int)i > 0) {
    mask <<= (int)i;
    ;
    if ((value & mask) == (unsigned long)0) {
      zeros = (unsigned char)((int)zeros + (int)i);
      value <<= (int)i;
    }
    i = (unsigned char)((int)i >> 1);
  }
  __retres = (unsigned char)((int)zeros - 1);
  return __retres;
}

static clock_time_t get_t(clock_time_t i_cur)
{
  clock_time_t __retres;
  uint32_t tmp;
  i_cur >>= 1;
  tmp = wide_rand();
  ;
  __retres = i_cur + (unsigned long)tmp % i_cur;
  return __retres;
}

static void schedule_for_end(struct trickle_timer *tt)
{
  clock_time_t now = clock_time();
  loc_clock = (tt->i_start + tt->i_cur) - now;
  if (loc_clock > (unsigned long)(~ 0) >> 1) loc_clock = (unsigned long)0;
  ctimer_set(& tt->ct,loc_clock,& double_interval,(void *)tt);
  return;
}

static void double_interval(void *ptr)
{
  clock_time_t last_end;
  clock_time_t tmp;
  loctt = (struct trickle_timer *)ptr;
  loctt->c = (unsigned char)0;
  last_end = loctt->i_start + loctt->i_cur;
  if (loctt->i_cur <= loctt->i_max_abs >> 1) loctt->i_cur <<= 1;
  else loctt->i_cur = loctt->i_max_abs;
  loc_clock = get_t(loctt->i_cur);
  tmp = clock_time();
  loc_clock = (last_end + loc_clock) - tmp;
  if (loc_clock > (unsigned long)(~ 0) >> 1) loc_clock = (unsigned long)0;
  ctimer_set(& loctt->ct,loc_clock,& fire,(void *)loctt);
  loctt->i_start = last_end;
  return;
}

static void fire(void *ptr)
{
  loctt = (struct trickle_timer *)ptr;
  if (loctt->cb) {
    int tmp;
    if ((int)loctt->k == 0x00) tmp = 1;
    else 
      if ((int)loctt->c < (int)loctt->k) tmp = 1; else tmp = 0;
    ;
    (*(loctt->cb))(loctt->cb_arg,(unsigned char)tmp);
  }
  if (loctt->i_cur != (clock_time_t)0) schedule_for_end(loctt);
  return;
}

static void new_interval(struct trickle_timer *tt)
{
  tt->c = (unsigned char)0;
  loc_clock = get_t(tt->i_cur);
  ctimer_set(& tt->ct,loc_clock,& fire,(void *)tt);
  tt->i_start = tt->ct.etimer.timer.start;
  return;
}

void trickle_timer_consistency(struct trickle_timer *tt)
{
  if (tt->i_cur == (clock_time_t)0) goto return_label;
  if ((int)tt->c < 0xFF) tt->c = (uint8_t)((int)tt->c + 1);
  return_label: return;
}

void trickle_timer_inconsistency(struct trickle_timer *tt)
{
  if (tt->i_cur == (clock_time_t)0) goto return_label;
  if (tt->i_cur != tt->i_min) {
    tt->i_cur = tt->i_min;
    new_interval(tt);
  }
  return_label: return;
}

uint8_t trickle_timer_config(struct trickle_timer *tt, clock_time_t i_min,
                             uint8_t i_max, uint8_t k)
{
  uint8_t __retres;
  if (i_min < (clock_time_t)2) goto _LOR;
  else 
    if (i_min > (unsigned long)(~ 0) >> 1) {
      _LOR: {
              __retres = (unsigned char)0;
              goto return_label;
            }
    }
  if (tt == (struct trickle_timer *)0) goto _LOR_0;
  else 
    if ((int)i_max == 0) goto _LOR_0;
    else 
      if ((int)k == 0) {
        _LOR_0: {
                  __retres = (unsigned char)0;
                  goto return_label;
                }
      }
  if ((unsigned long)(~ 0) >> ((int)i_max + 1) < i_min - (clock_time_t)1) 
    i_max = max_imax(i_min);
  tt->i_min = i_min;
  tt->i_max = i_max;
  tt->i_max_abs = i_min << (int)i_max;
  tt->k = k;
  tt->i_cur = (unsigned long)0;
  tt->cb = (void (*)(void *ptr, uint8_t suppress))0;
  __retres = (unsigned char)1;
  return_label: return __retres;
}

uint8_t trickle_timer_set(struct trickle_timer *tt,
                          void (*proto_cb)(void *ptr, uint8_t suppress),
                          void *ptr)
{
  uint8_t __retres;
  uint32_t tmp;
  if (tt == (struct trickle_timer *)0) goto _LOR;
  else 
    if (proto_cb == (void (*)(void *ptr, uint8_t suppress))0) {
      _LOR: {
              __retres = (unsigned char)0;
              goto return_label;
            }
    }
  tt->cb = proto_cb;
  tt->cb_arg = ptr;
  tmp = wide_rand();
  tt->i_cur = tt->i_min + (unsigned long)tmp % ((tt->i_max_abs - tt->i_min) + (clock_time_t)1);
  new_interval(tt);
  __retres = (unsigned char)1;
  return_label: return __retres;
}

__inline static unsigned int __bswap_32_37(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_37(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void memb_init(struct memb *m)
{
  memset((void *)m->count,0,(unsigned long)m->num);
  memset(m->mem,0,(unsigned long)((int)m->size * (int)m->num));
  return;
}

void *memb_alloc(struct memb *m)
{
  void *__retres;
  int i;
  i = 0;
  while (i < (int)m->num) {
    if ((int)*(m->count + i) == 0) {
      *(m->count + i) = (char)((int)*(m->count + i) + 1);
      __retres = (void *)((char *)m->mem + i * (int)m->size);
      goto return_label;
    }
    i ++;
  }
  __retres = (void *)0;
  return_label: return __retres;
}

char memb_free(struct memb *m, void *ptr)
{
  char __retres;
  int i;
  char *ptr2;
  ptr2 = (char *)m->mem;
  i = 0;
  while (i < (int)m->num) {
    if (ptr2 == (char *)ptr) {
      if ((int)*(m->count + i) > 0) *(m->count + i) = (char)((int)*(m->count + i) - 1);
      __retres = *(m->count + i);
      goto return_label;
    }
    ptr2 += (int)m->size;
    i ++;
  }
  __retres = (char)(-1);
  return_label: return __retres;
}

int memb_inmemb(struct memb *m, void *ptr)
{
  int tmp;
  if ((char *)ptr >= (char *)m->mem) 
    if ((char *)ptr < (char *)m->mem + (int)m->num * (int)m->size) tmp = 1;
    else tmp = 0;
  else tmp = 0;
  return tmp;
}

int memb_numfree(struct memb *m)
{
  int i;
  int num_free_0 = 0;
  i = 0;
  while (i < (int)m->num) {
    if ((int)*(m->count + i) == 0) num_free_0 ++;
    i ++;
  }
  return num_free_0;
}

__inline static unsigned int __bswap_32_38(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_38(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void *heapmem_alloc(size_t size);

void *heapmem_realloc(void *ptr, size_t size);

void heapmem_free(void *ptr);

void heapmem_stats(heapmem_stats_t *stats);

static char heap_base[1];
static size_t heap_usage;
static chunk_t *first_chunk = (chunk_t *)(heap_base);
static chunk_t *free_list;
static void *extend_space(size_t size)
{
  void *__retres;
  char *old_usage;
  if (heap_usage + size > (size_t)1) {
    __retres = (void *)0;
    goto return_label;
  }
  old_usage = & heap_base[heap_usage];
  heap_usage += size;
  __retres = (void *)old_usage;
  return_label: return __retres;
}

static void free_chunk(chunk_t * const chunk)
{
  chunk->flags = (unsigned char)((int)chunk->flags & ~ 0x1);
  if (((char *)chunk + sizeof(chunk_t)) + chunk->size == & heap_base[heap_usage]) 
    heap_usage -= sizeof(chunk_t) + chunk->size;
  else {
    chunk->prev = (struct chunk *)0;
    chunk->next = free_list;
    if (free_list != (chunk_t *)0) free_list->prev = chunk;
    free_list = chunk;
  }
  return;
}

static void allocate_chunk(chunk_t * const chunk)
{
  chunk->flags = (unsigned char)((int)chunk->flags | 0x1);
  if (chunk == free_list) {
    free_list = chunk->next;
    if (free_list != (chunk_t *)0) free_list->prev = (struct chunk *)0;
  }
  else (chunk->prev)->next = chunk->next;
  if (chunk->next != (struct chunk *)0) (chunk->next)->prev = chunk->prev;
  return;
}

static void split_chunk(chunk_t * const chunk, size_t offset)
{
  chunk_t *new_chunk;
  offset = (offset + (sizeof(int) - (unsigned long)1)) & ~ (sizeof(int) - (unsigned long)1);
  if (offset + sizeof(chunk_t) < chunk->size) {
    struct chunk *tmp;
    new_chunk = (chunk_t *)((char *)(chunk + 1) + offset);
    new_chunk->size = (chunk->size - sizeof(chunk_t)) - offset;
    new_chunk->flags = (unsigned char)0;
    free_chunk(new_chunk);
    chunk->size = offset;
    tmp = (struct chunk *)0;
    chunk->prev = tmp;
    chunk->next = tmp;
  }
  return;
}

static void coalesce_chunks(chunk_t *chunk)
{
  chunk_t *next;
  next = (chunk_t *)(((char *)chunk + sizeof(chunk_t)) + chunk->size);
  while (1) {
    if ((char *)next < & heap_base[heap_usage]) {
      if (! (~ ((int)next->flags) & 0x1)) break;
    }
    else break;
    chunk->size += sizeof(chunk_t) + next->size;
    allocate_chunk(next);
    next = (chunk_t *)(((char *)next + sizeof(chunk_t)) + next->size);
  }
  return;
}

static void defrag_chunks(void)
{
  int i;
  chunk_t *chunk;
  i = 16;
  chunk = free_list;
  while (chunk != (chunk_t *)0) {
    {
      int tmp;
      tmp = i;
      i --;
      ;
      if (tmp == 0) break;
      coalesce_chunks(chunk);
    }
    chunk = chunk->next;
  }
  return;
}

static chunk_t *get_free_chunk(size_t const size)
{
  int i;
  chunk_t *chunk;
  chunk_t *best;
  defrag_chunks();
  best = (chunk_t *)0;
  i = 16;
  chunk = free_list;
  while (chunk != (chunk_t *)0) {
    {
      int tmp;
      tmp = i;
      i --;
      ;
      if (tmp == 0) break;
      if (size <= chunk->size) {
        if (best == (chunk_t *)0) goto _LOR;
        else 
          if (chunk->size < best->size) _LOR: best = chunk;
        if (best->size == size) break;
      }
    }
    chunk = chunk->next;
  }
  if (best != (chunk_t *)0) {
    allocate_chunk(best);
    split_chunk(best,size);
  }
  return best;
}

void *heapmem_alloc(size_t size)
{
  void *__retres;
  chunk_t *chunk;
  size = (size + (sizeof(int) - (unsigned long)1)) & ~ (sizeof(int) - (unsigned long)1);
  chunk = get_free_chunk(size);
  if (chunk == (chunk_t *)0) {
    chunk = (chunk_t *)extend_space(sizeof(chunk_t) + size);
    if (chunk == (chunk_t *)0) {
      __retres = (void *)0;
      goto return_label;
    }
    chunk->size = size;
  }
  chunk->flags = (unsigned char)0x1;
  __retres = (void *)(chunk + 1);
  return_label: return __retres;
}

void heapmem_free(void *ptr)
{
  chunk_t *chunk;
  if (ptr) {
    chunk = (chunk_t *)((char *)ptr - sizeof(chunk_t));
    free_chunk(chunk);
  }
  return;
}

void *heapmem_realloc(void *ptr, size_t size)
{
  void *__retres;
  void *newptr;
  chunk_t *chunk;
  int size_adj;
  if (ptr == (void *)0) {
    void *tmp;
    tmp = heapmem_alloc(size);
    __retres = tmp;
    goto return_label;
  }
  else 
    if (size == (size_t)0) {
      heapmem_free(ptr);
      __retres = (void *)0;
      goto return_label;
    }
  chunk = (chunk_t *)((char *)ptr - sizeof(chunk_t));
  size = (size + (sizeof(int) - (unsigned long)1)) & ~ (sizeof(int) - (unsigned long)1);
  size_adj = (int)(size - chunk->size);
  if (size_adj <= 0) {
    split_chunk(chunk,size);
    __retres = ptr;
    goto return_label;
  }
  if (((char *)chunk + sizeof(chunk_t)) + chunk->size == & heap_base[heap_usage]) {
    void *tmp_0;
    tmp_0 = extend_space((unsigned long)size_adj);
    if (tmp_0 != (void *)0) {
      chunk->size = size;
      __retres = ptr;
      goto return_label;
    }
  }
  else {
    coalesce_chunks(chunk);
    if (chunk->size >= size) {
      split_chunk(chunk,size);
      __retres = ptr;
      goto return_label;
    }
  }
  newptr = heapmem_alloc(size);
  if (newptr == (void *)0) {
    __retres = (void *)0;
    goto return_label;
  }
  memcpy(newptr,(void const *)ptr,chunk->size);
  free_chunk(chunk);
  __retres = newptr;
  return_label: return __retres;
}

void heapmem_stats(heapmem_stats_t *stats)
{
  chunk_t *chunk;
  memset((void *)stats,0,sizeof(*stats));
  chunk = first_chunk;
  while ((char *)chunk < & heap_base[heap_usage]) {
    if ((int)chunk->flags & 0x1) stats->allocated += chunk->size;
    else {
      coalesce_chunks(chunk);
      stats->available += chunk->size;
    }
    stats->overhead += sizeof(chunk_t);
    chunk = (chunk_t *)(((char *)chunk + sizeof(chunk_t)) + chunk->size);
  }
  stats->available += (size_t)1 - heap_usage;
  stats->footprint = heap_usage;
  stats->chunks = stats->overhead / sizeof(chunk_t);
  return;
}

__inline static unsigned int __bswap_32_39(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_39(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void random_init(unsigned short seed)
{
  srand((unsigned int)seed);
  return;
}

unsigned short random_rand(void)
{
  unsigned short __retres;
  int tmp;
  tmp = rand();
  __retres = (unsigned short)tmp;
  return __retres;
}

__inline static unsigned int __bswap_32_40(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_40(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

 __attribute__((__noreturn__)) void _xassert(char const *file, int lineno);

 __attribute__((__noreturn__)) void _xassert(char const *file, int lineno);
void _xassert(char const *file, int lineno)
{
  printf("Assertion failed: file %s, line %d.\n",file,lineno);
  printf("The firmware will stop running\n");
  printf("A watchdog timer may restart this device\n");
  while (1) ;
  return;
}

__inline static unsigned int __bswap_32_41(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_41(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void ringbuf_init(struct ringbuf *r, uint8_t *dataptr, uint8_t size)
{
  r->data = dataptr;
  r->mask = (unsigned char)((int)size - 1);
  r->put_ptr = (unsigned char)0;
  r->get_ptr = (unsigned char)0;
  return;
}

int ringbuf_put(struct ringbuf *r, uint8_t c)
{
  int __retres;
  if ((((int)r->put_ptr - (int)r->get_ptr) & (int)r->mask) == (int)r->mask) {
    __retres = 0;
    goto return_label;
  }
  *((uint8_t volatile *)(r->data + r->put_ptr)) = c;
  *((uint8_t volatile *)(& r->put_ptr)) = (unsigned char)(((int)r->put_ptr + 1) & (int)r->mask);
  __retres = 1;
  return_label: return __retres;
}

int ringbuf_get(struct ringbuf *r)
{
  int __retres;
  uint8_t c;
  if ((((int)r->put_ptr - (int)r->get_ptr) & (int)r->mask) > 0) {
    c = *((uint8_t volatile *)(r->data + r->get_ptr));
    *((uint8_t volatile *)(& r->get_ptr)) = (unsigned char)(((int)r->get_ptr + 1) & (int)r->mask);
    __retres = (int)c;
    goto return_label;
  }
  else {
    __retres = -1;
    goto return_label;
  }
  return_label: return __retres;
}

int ringbuf_size(struct ringbuf *r)
{
  int __retres;
  __retres = (int)r->mask + 1;
  return __retres;
}

int ringbuf_elements(struct ringbuf *r)
{
  int __retres;
  __retres = ((int)r->put_ptr - (int)r->get_ptr) & (int)r->mask;
  return __retres;
}

__inline static unsigned int __bswap_32_42(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_42(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static char bufmem_memb_count[64];
static struct queuebuf bufmem_memb_mem[64];
static struct memb bufmem =
  {.size = (unsigned short)sizeof(struct queuebuf),
   .num = (unsigned short)64,
   .count = bufmem_memb_count,
   .mem = (void *)(bufmem_memb_mem)};
static char buframmem_memb_count[64];
static struct queuebuf_data buframmem_memb_mem[64];
static struct memb buframmem =
  {.size = (unsigned short)sizeof(struct queuebuf_data),
   .num = (unsigned short)64,
   .count = buframmem_memb_count,
   .mem = (void *)(buframmem_memb_mem)};
static struct queuebuf_data *queuebuf_load_to_ram(struct queuebuf *b)
{
  struct queuebuf_data *__retres;
  __retres = b->ram_ptr;
  return __retres;
}

void queuebuf_init(void)
{
  memb_init(& buframmem);
  memb_init(& bufmem);
  return;
}

int queuebuf_numfree(void)
{
  int tmp;
  tmp = memb_numfree(& bufmem);
  return tmp;
}

struct queuebuf *queuebuf_new_from_packetbuf(void)
{
  struct queuebuf *__retres;
  struct queuebuf *buf_0;
  struct queuebuf_data *buframptr;
  buf_0 = (struct queuebuf *)memb_alloc(& bufmem);
  if (buf_0 != (struct queuebuf *)0) {
    int tmp;
    buf_0->ram_ptr = (struct queuebuf_data *)memb_alloc(& buframmem);
    if (buf_0->ram_ptr == (struct queuebuf_data *)0) {
      memb_free(& bufmem,(void *)buf_0);
      __retres = (struct queuebuf *)0;
      goto return_label;
    }
    buframptr = buf_0->ram_ptr;
    tmp = packetbuf_copyto((void *)(buframptr->data));
    buframptr->len = (unsigned short)tmp;
    packetbuf_attr_copyto(buframptr->attrs,buframptr->addrs);
  }
  __retres = buf_0;
  return_label: return __retres;
}

void queuebuf_update_attr_from_packetbuf(struct queuebuf *buf_0)
{
  struct queuebuf_data *buframptr = queuebuf_load_to_ram(buf_0);
  packetbuf_attr_copyto(buframptr->attrs,buframptr->addrs);
  return;
}

void queuebuf_update_from_packetbuf(struct queuebuf *buf_0)
{
  int tmp_0;
  struct queuebuf_data *buframptr = queuebuf_load_to_ram(buf_0);
  packetbuf_attr_copyto(buframptr->attrs,buframptr->addrs);
  tmp_0 = packetbuf_copyto((void *)(buframptr->data));
  buframptr->len = (unsigned short)tmp_0;
  return;
}

void queuebuf_free(struct queuebuf *buf_0)
{
  int tmp;
  tmp = memb_inmemb(& bufmem,(void *)buf_0);
  if (tmp) {
    memb_free(& buframmem,(void *)buf_0->ram_ptr);
    memb_free(& bufmem,(void *)buf_0);
  }
  return;
}

void queuebuf_to_packetbuf(struct queuebuf *b)
{
  int tmp_0;
  tmp_0 = memb_inmemb(& bufmem,(void *)b);
  if (tmp_0) {
    struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
    packetbuf_copyfrom((void const *)(buframptr->data),buframptr->len);
    packetbuf_attr_copyfrom(buframptr->attrs,buframptr->addrs);
  }
  return;
}

void *queuebuf_dataptr(struct queuebuf *b)
{
  void *__retres;
  int tmp_0;
  tmp_0 = memb_inmemb(& bufmem,(void *)b);
  if (tmp_0) {
    struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
    __retres = (void *)(buframptr->data);
    goto return_label;
  }
  __retres = (void *)0;
  return_label: return __retres;
}

int queuebuf_datalen(struct queuebuf *b)
{
  int __retres;
  struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
  __retres = (int)buframptr->len;
  return __retres;
}

linkaddr_t *queuebuf_addr(struct queuebuf *b, uint8_t type)
{
  linkaddr_t *__retres;
  struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
  __retres = & buframptr->addrs[(int)type - PACKETBUF_ADDR_SENDER].addr;
  return __retres;
}

packetbuf_attr_t queuebuf_attr(struct queuebuf *b, uint8_t type)
{
  packetbuf_attr_t __retres;
  struct queuebuf_data *buframptr = queuebuf_load_to_ram(b);
  __retres = buframptr->attrs[type].val;
  return __retres;
}

void queuebuf_debug_print(void)
{
  return;
}

__inline static unsigned int __bswap_32_43(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_43(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

linkaddr_t const *rpl_nbr_policy_find_removable(nbr_table_reason_t reason,
                                                void *data);

static uint8_t used_map[300];
static uint8_t locked_map[300];
static struct nbr_table *all_tables[8];
static unsigned int num_tables;
static char neighbor_addr_mem_memb_count[300];
static nbr_table_key_t neighbor_addr_mem_memb_mem[300];
static struct memb neighbor_addr_mem =
  {.size = (unsigned short)sizeof(nbr_table_key_t),
   .num = (unsigned short)300,
   .count = neighbor_addr_mem_memb_count,
   .mem = (void *)(neighbor_addr_mem_memb_mem)};
static void *nbr_table_keys_list = (void *)0;
static list_t nbr_table_keys = & nbr_table_keys_list;
static nbr_table_key_t *key_from_index(int index_0)
{
  nbr_table_key_t *tmp;
  if (index_0 != -1) tmp = (nbr_table_key_t *)neighbor_addr_mem.mem + index_0;
  else tmp = (nbr_table_key_t *)0;
  return tmp;
}

static nbr_table_item_t *item_from_index(nbr_table_t *table, int index_0)
{
  nbr_table_item_t *__retres;
  char *tmp;
  if (table != (nbr_table_t *)0) 
    if (index_0 != -1) tmp = (char *)table->data + index_0 * table->item_size;
    else tmp = (char *)0;
  else tmp = (char *)0;
  __retres = (nbr_table_item_t *)tmp;
  return __retres;
}

static int index_from_key(nbr_table_key_t *key)
{
  int __retres;
  long tmp;
  if (key != (nbr_table_key_t *)0) tmp = key - (nbr_table_key_t *)neighbor_addr_mem.mem;
  else tmp = (long)(-1);
  __retres = (int)tmp;
  return __retres;
}

static int index_from_item(nbr_table_t *table, nbr_table_item_t const *item)
{
  int tmp;
  if (table != (nbr_table_t *)0) 
    if (item != (nbr_table_item_t const *)0) tmp = (int)((char *)item - (char *)table->data) / table->item_size;
    else tmp = -1;
  else tmp = -1;
  return tmp;
}

static nbr_table_item_t *item_from_key(nbr_table_t *table,
                                       nbr_table_key_t *key)
{
  nbr_table_item_t *tmp_0;
  int tmp;
  tmp = index_from_key(key);
  ;
  tmp_0 = item_from_index(table,tmp);
  return tmp_0;
}

static nbr_table_key_t *key_from_item(nbr_table_t *table,
                                      nbr_table_item_t const *item)
{
  nbr_table_key_t *tmp_0;
  int tmp;
  tmp = index_from_item(table,item);
  tmp_0 = key_from_index(tmp);
  return tmp_0;
}

static int index_from_lladdr(linkaddr_t const *lladdr)
{
  int __retres;
  nbr_table_key_t *key;
  if (lladdr == (linkaddr_t const *)0) lladdr = & linkaddr_null;
  key = (nbr_table_key_t *)list_head(nbr_table_keys);
  while (key != (nbr_table_key_t *)0) {
    if (lladdr) {
      int tmp_0;
      tmp_0 = linkaddr_cmp(lladdr,(linkaddr_t const *)(& key->lladdr));
      if (tmp_0) {
        int tmp;
        tmp = index_from_key(key);
        __retres = tmp;
        goto return_label;
      }
    }
    key = (nbr_table_key_t *)list_item_next((void *)key);
  }
  __retres = -1;
  return_label: return __retres;
}

static int nbr_get_bit(uint8_t *bitmap, nbr_table_t *table,
                       nbr_table_item_t *item)
{
  int __retres;
  int item_index = index_from_item(table,(nbr_table_item_t const *)item);
  if (table != (nbr_table_t *)0) {
    if (item_index != -1) {
      __retres = ((int)*(bitmap + item_index) & (1 << table->index)) != 0;
      goto return_label;
    }
    else goto _LAND;
  }
  else {
    _LAND: {
             __retres = 0;
             goto return_label;
           }
  }
  __retres = 0;
  return_label: return __retres;
}

static int nbr_set_bit(uint8_t *bitmap, nbr_table_t *table,
                       nbr_table_item_t *item, int value)
{
  int __retres;
  int item_index = index_from_item(table,(nbr_table_item_t const *)item);
  if (table != (nbr_table_t *)0) {
    if (item_index != -1) {
      if (value) *(bitmap + item_index) = (unsigned char)((int)*(bitmap + item_index) | (
                                                          1 << table->index));
      else *(bitmap + item_index) = (unsigned char)((int)*(bitmap + item_index) & ~ (
                                                    1 << table->index));
      __retres = 1;
      goto return_label;
    }
    else goto _LAND;
  }
  else {
    _LAND: {
             __retres = 0;
             goto return_label;
           }
  }
  __retres = 0;
  return_label: return __retres;
}

static void remove_key(nbr_table_key_t *least_used_key)
{
  int i;
  int tmp_1;
  i = 0;
  while (i < 8) {
    if (all_tables[i] != (struct nbr_table *)0) 
      if ((all_tables[i])->callback != (nbr_table_callback *)0) {
        int tmp_0;
        nbr_table_item_t *removed_item =
          item_from_key(all_tables[i],least_used_key);
        tmp_0 = nbr_get_bit(used_map,all_tables[i],removed_item);
        if (tmp_0 == 1) (*((all_tables[i])->callback))(removed_item);
      }
    i ++;
  }
  tmp_1 = index_from_key(least_used_key);
  used_map[tmp_1] = (unsigned char)0;
  list_remove(nbr_table_keys,(void *)least_used_key);
  return;
}

static nbr_table_key_t *nbr_table_allocate(nbr_table_reason_t reason,
                                           void *data)
{
  nbr_table_key_t *__retres;
  nbr_table_key_t *key;
  int least_used_count = 0;
  nbr_table_key_t *least_used_key = (nbr_table_key_t *)0;
  key = (nbr_table_key_t *)memb_alloc(& neighbor_addr_mem);
  if (key != (nbr_table_key_t *)0) {
    __retres = key;
    goto return_label;
  }
  else {
    linkaddr_t const *lladdr;
    lladdr = rpl_nbr_policy_find_removable(reason,data);
    if (lladdr == (linkaddr_t const *)0) {
      __retres = (nbr_table_key_t *)0;
      goto return_label;
    }
    else {
      int index_0;
      int locked = 0;
      index_0 = index_from_lladdr(lladdr);
      if (index_0 != -1) {
        least_used_key = key_from_index(index_0);
        locked = (int)locked_map[index_0];
      }
      if (least_used_key != (nbr_table_key_t *)0) 
        if (locked) locked_map[index_0] = (unsigned char)0;
    }
    if (least_used_key == (nbr_table_key_t *)0) {
      key = (nbr_table_key_t *)list_head(nbr_table_keys);
      while (key != (nbr_table_key_t *)0) {
        int item_index = index_from_key(key);
        int locked_0 = (int)locked_map[item_index];
        if (! locked_0) {
          int used = (int)used_map[item_index];
          int used_count = 0;
          while (used != 0) {
            if ((used & 1) == 1) used_count ++;
            used >>= 1;
          }
          if (least_used_key == (nbr_table_key_t *)0) goto _LOR;
          else 
            if (used_count < least_used_count) {
              _LOR:
              {
                least_used_key = key;
                least_used_count = used_count;
                if (used_count == 0) break;
              }
            }
        }
        key = (nbr_table_key_t *)list_item_next((void *)key);
      }
    }
    if (least_used_key == (nbr_table_key_t *)0) {
      __retres = (nbr_table_key_t *)0;
      goto return_label;
    }
    else {
      remove_key(least_used_key);
      __retres = least_used_key;
      goto return_label;
    }
  }
  return_label: return __retres;
}

int nbr_table_register(nbr_table_t *table, nbr_table_callback *callback_0)
{
  int __retres;
  int tmp;
  tmp = nbr_table_is_registered(table);
  if (tmp) {
    table->callback = callback_0;
    __retres = 1;
    goto return_label;
  }
  if (num_tables < (unsigned int)8) {
    unsigned int tmp_0;
    tmp_0 = num_tables;
    num_tables ++;
    table->index = (int)tmp_0;
    table->callback = callback_0;
    all_tables[table->index] = table;
    __retres = 1;
    goto return_label;
  }
  else {
    __retres = 0;
    goto return_label;
  }
  return_label: return __retres;
}

int nbr_table_is_registered(nbr_table_t *table)
{
  int __retres;
  if (table != (nbr_table_t *)0) 
    if (table->index >= 0) 
      if (table->index < 8) 
        if (all_tables[table->index] == table) {
          __retres = 1;
          goto return_label;
        }
  __retres = 0;
  return_label: return __retres;
}

nbr_table_item_t *nbr_table_head(nbr_table_t *table)
{
  nbr_table_item_t *__retres;
  nbr_table_item_t *tmp_0;
  void *tmp;
  int tmp_2;
  tmp = list_head(nbr_table_keys);
  ;
  tmp_0 = item_from_key(table,(nbr_table_key_t *)tmp);
  nbr_table_item_t *item = tmp_0;
  tmp_2 = nbr_get_bit(used_map,table,item);
  if (tmp_2) {
    __retres = item;
    goto return_label;
  }
  else {
    nbr_table_item_t *tmp_1;
    tmp_1 = nbr_table_next(table,item);
    __retres = tmp_1;
    goto return_label;
  }
  return_label: return __retres;
}

nbr_table_item_t *nbr_table_next(nbr_table_t *table, nbr_table_item_t *item)
{
  while (1) {
    {
      void *key = key_from_item(table,(nbr_table_item_t const *)item);
      key = list_item_next(key);
      item = item_from_key(table,(nbr_table_key_t *)key);
    }
    if (item) {
      int tmp_0;
      tmp_0 = nbr_get_bit(used_map,table,item);
      if (tmp_0) break;
    }
    else break;
  }
  return item;
}

nbr_table_item_t *nbr_table_add_lladdr(nbr_table_t *table,
                                       linkaddr_t const *lladdr,
                                       nbr_table_reason_t reason, void *data)
{
  nbr_table_item_t *__retres;
  int index_0;
  nbr_table_item_t *item;
  nbr_table_key_t *key;
  if (table == (nbr_table_t *)0) {
    __retres = (void *)0;
    goto return_label;
  }
  if (lladdr == (linkaddr_t const *)0) lladdr = & linkaddr_null;
  index_0 = index_from_lladdr(lladdr);
  if (index_0 == -1) {
    key = nbr_table_allocate(reason,data);
    if (key == (nbr_table_key_t *)0) {
      __retres = (void *)0;
      goto return_label;
    }
    list_add(nbr_table_keys,(void *)key);
    index_0 = index_from_key(key);
    linkaddr_copy(& key->lladdr,lladdr);
  }
  item = item_from_index(table,index_0);
  memset(item,0,(unsigned long)table->item_size);
  nbr_set_bit(used_map,table,item,1);
  __retres = item;
  return_label: return __retres;
}

void *nbr_table_get_from_lladdr(nbr_table_t *table, linkaddr_t const *lladdr)
{
  void *tmp_0;
  int tmp;
  void *tmp_2;
  int tmp_1;
  tmp = index_from_lladdr(lladdr);
  ;
  tmp_0 = item_from_index(table,tmp);
  void *item = tmp_0;
  tmp_1 = nbr_get_bit(used_map,table,item);
  if (tmp_1) tmp_2 = item; else tmp_2 = (void *)0;
  return tmp_2;
}

int nbr_table_remove(nbr_table_t *table, void *item)
{
  int ret = nbr_set_bit(used_map,table,item,0);
  nbr_set_bit(locked_map,table,item,0);
  return ret;
}

int nbr_table_lock(nbr_table_t *table, void *item)
{
  int tmp;
  tmp = nbr_set_bit(locked_map,table,item,1);
  return tmp;
}

int nbr_table_unlock(nbr_table_t *table, void *item)
{
  int tmp;
  tmp = nbr_set_bit(locked_map,table,item,0);
  return tmp;
}

linkaddr_t *nbr_table_get_lladdr(nbr_table_t *table, void const *item)
{
  linkaddr_t *tmp_0;
  nbr_table_key_t *key = key_from_item(table,item);
  if (key != (nbr_table_key_t *)0) tmp_0 = & key->lladdr;
  else tmp_0 = (linkaddr_t *)0;
  return tmp_0;
}

__inline static unsigned int __bswap_32_44(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_44(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

struct packetbuf_attr packetbuf_attrs[PACKETBUF_ATTR_MAX - 2];
struct packetbuf_addr packetbuf_addrs[2];
static uint16_t buflen;
static uint16_t bufptr;
static uint8_t hdrlen;
static uint32_t packetbuf_aligned[(128 + 3) / 4];
static uint8_t *packetbuf = (uint8_t *)(packetbuf_aligned);
void packetbuf_clear(void)
{
  bufptr = (unsigned short)0;
  buflen = bufptr;
  hdrlen = (unsigned char)0;
  packetbuf_attr_clear();
  return;
}

int packetbuf_copyfrom(void const *from, uint16_t len)
{
  int __retres;
  uint16_t l;
  packetbuf_clear();
  if (128 < (int)len) l = (unsigned short)128; else l = len;
  memcpy((void *)packetbuf,from,(unsigned long)l);
  buflen = l;
  __retres = (int)l;
  return __retres;
}

int packetbuf_copyto(void *to)
{
  int __retres;
  void *tmp;
  void *tmp_0;
  if ((int)hdrlen + (int)buflen > 128) {
    __retres = 0;
    goto return_label;
  }
  ;
  tmp = packetbuf_hdrptr();
  ;
  memcpy(to,(void const *)tmp,(unsigned long)hdrlen);
  ;
  tmp_0 = packetbuf_dataptr();
  ;
  memcpy((void *)((uint8_t *)to + (int)hdrlen),(void const *)tmp_0,
         (unsigned long)buflen);
  __retres = (int)hdrlen + (int)buflen;
  return_label: return __retres;
}

int packetbuf_hdralloc(int size)
{
  int __retres;
  int16_t i;
  uint16_t tmp;
  uint16_t tmp_0;
  tmp = packetbuf_totlen();
  ;
  if (size + (int)tmp > 128) {
    __retres = 0;
    goto return_label;
  }
  tmp_0 = packetbuf_totlen();
  i = (short)((int)tmp_0 - 1);
  while ((int)i >= 0) {
    *(packetbuf + ((int)i + size)) = *(packetbuf + i);
    i = (int16_t)((int)i - 1);
  }
  hdrlen = (unsigned char)((int)hdrlen + size);
  __retres = 1;
  return_label: return __retres;
}

int packetbuf_hdrreduce(int size)
{
  int __retres;
  if ((int)buflen < size) {
    __retres = 0;
    goto return_label;
  }
  bufptr = (unsigned short)((int)bufptr + size);
  buflen = (unsigned short)((int)buflen - size);
  __retres = 1;
  return_label: return __retres;
}

void packetbuf_set_datalen(uint16_t len)
{
  buflen = len;
  return;
}

void *packetbuf_dataptr(void)
{
  void *__retres;
  uint8_t tmp;
  tmp = packetbuf_hdrlen();
  ;
  __retres = (void *)(packetbuf + (int)tmp);
  return __retres;
}

void *packetbuf_hdrptr(void)
{
  void *__retres;
  __retres = (void *)packetbuf;
  return __retres;
}

uint16_t packetbuf_datalen(void)
{
  return buflen;
}

uint8_t packetbuf_hdrlen(void)
{
  uint8_t __retres;
  __retres = (unsigned char)((int)bufptr + (int)hdrlen);
  return __retres;
}

uint16_t packetbuf_totlen(void)
{
  uint16_t __retres;
  uint8_t tmp;
  uint16_t tmp_0;
  tmp = packetbuf_hdrlen();
  tmp_0 = packetbuf_datalen();
  __retres = (unsigned short)((int)tmp + (int)tmp_0);
  return __retres;
}

uint16_t packetbuf_remaininglen(void)
{
  uint16_t __retres;
  uint16_t tmp;
  tmp = packetbuf_totlen();
  __retres = (unsigned short)(128 - (int)tmp);
  return __retres;
}

void packetbuf_attr_clear(void)
{
  int i;
  memset((void *)(packetbuf_attrs),0,sizeof(packetbuf_attrs));
  i = 0;
  while (i < 2) {
    linkaddr_copy(& packetbuf_addrs[i].addr,& linkaddr_null);
    i ++;
  }
  return;
}

void packetbuf_attr_copyto(struct packetbuf_attr *attrs,
                           struct packetbuf_addr *addrs)
{
  memcpy((void *)attrs,(void const *)(packetbuf_attrs),
         sizeof(packetbuf_attrs));
  memcpy((void *)addrs,(void const *)(packetbuf_addrs),
         sizeof(packetbuf_addrs));
  return;
}

void packetbuf_attr_copyfrom(struct packetbuf_attr *attrs,
                             struct packetbuf_addr *addrs)
{
  memcpy((void *)(packetbuf_attrs),(void const *)attrs,
         sizeof(packetbuf_attrs));
  memcpy((void *)(packetbuf_addrs),(void const *)addrs,
         sizeof(packetbuf_addrs));
  return;
}

int packetbuf_set_attr(uint8_t type, packetbuf_attr_t const val)
{
  int __retres;
  packetbuf_attrs[type].val = val;
  __retres = 1;
  return __retres;
}

packetbuf_attr_t packetbuf_attr(uint8_t type)
{
  packetbuf_attr_t __retres;
  __retres = packetbuf_attrs[type].val;
  return __retres;
}

int packetbuf_set_addr(uint8_t type, linkaddr_t const *addr_0)
{
  int __retres;
  linkaddr_copy(& packetbuf_addrs[(int)type - PACKETBUF_ADDR_SENDER].addr,
                addr_0);
  __retres = 1;
  return __retres;
}

linkaddr_t const *packetbuf_addr(uint8_t type)
{
  linkaddr_t const *__retres;
  __retres = (linkaddr_t const *)(& packetbuf_addrs[(int)type - PACKETBUF_ADDR_SENDER].addr);
  return __retres;
}

int packetbuf_holds_broadcast(void)
{
  int tmp;
  tmp = linkaddr_cmp((linkaddr_t const *)(& packetbuf_addrs[PACKETBUF_ADDR_RECEIVER - PACKETBUF_ADDR_SENDER].addr),
                     & linkaddr_null);
  return tmp;
}

__inline static unsigned int __bswap_32_45(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_45(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static void *ip_processor_list_list = (void *)0;
static list_t ip_processor_list = & ip_processor_list_list;
enum netstack_ip_action netstack_process_ip_callback(uint8_t type,
                                                     linkaddr_t const *localdest)
{
  enum netstack_ip_action __retres;
  struct netstack_ip_packet_processor *p;
  enum netstack_ip_action action = NETSTACK_IP_PROCESS;
  p = (struct netstack_ip_packet_processor *)list_head(ip_processor_list);
  while (p != (struct netstack_ip_packet_processor *)0) {
    if ((int)type == NETSTACK_IP_OUTPUT) {
      if (p->process_output != (enum netstack_ip_action (*)(linkaddr_t const *localdest))0) 
        action = (*(p->process_output))(localdest);
    }
    else 
      if ((int)type == NETSTACK_IP_INPUT) 
        if (p->process_input != (enum netstack_ip_action (*)(void))0) 
          action = (*(p->process_input))();
    if (action != (unsigned int)NETSTACK_IP_PROCESS) {
      __retres = action;
      goto return_label;
    }
    p = (struct netstack_ip_packet_processor *)list_item_next((void *)p);
  }
  __retres = action;
  return_label: return __retres;
}

void netstack_ip_packet_processor_add(struct netstack_ip_packet_processor *p)
{
  if (p != (struct netstack_ip_packet_processor *)0) list_add(ip_processor_list,
                                                              (void *)p);
  return;
}

void uip_ds6_ip_packet_processor_rm(struct netstack_ip_packet_processor *p)
{
  list_remove(ip_processor_list,(void *)p);
  return;
}

void netstack_init(void)
{
  (*(nullradio_driver.init))();
  (*(nullmac_driver.init))();
  (*(tun6_net_driver.init))();
  return;
}

__inline static unsigned int __bswap_32_46(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_46(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

linkaddr_t linkaddr_node_addr;
linkaddr_t const linkaddr_null =
  {.u8 = {(unsigned char)0,
          (unsigned char)0,
          (unsigned char)0,
          (unsigned char)0,
          (unsigned char)0,
          (unsigned char)0,
          (unsigned char)0,
          (unsigned char)0}};
void linkaddr_copy(linkaddr_t *dest, linkaddr_t const *src)
{
  memcpy((void *)dest,(void const *)src,(unsigned long)8);
  return;
}

int linkaddr_cmp(linkaddr_t const *addr1, linkaddr_t const *addr2)
{
  int __retres;
  int tmp;
  tmp = memcmp((void const *)addr1,(void const *)addr2,(unsigned long)8);
  __retres = tmp == 0;
  return __retres;
}

void linkaddr_set_node_addr(linkaddr_t *t)
{
  linkaddr_copy(& linkaddr_node_addr,(linkaddr_t const *)t);
  return;
}

__inline static unsigned int __bswap_32_47(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_47(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void net_debug_lladdr_print(uip_lladdr_t const *addr_0)
{
  if (addr_0 == (uip_lladdr_t const *)0) {
    printf("(NULL LL addr)");
    goto return_label;
  }
  else {
    unsigned int i;
    i = (unsigned int)0;
    while (i < (unsigned int)8) {
      if (i > (unsigned int)0) 
        if (i % (unsigned int)2 == (unsigned int)0) printf(".");
      printf("%02x",(int)addr_0->addr[i]);
      i ++;
    }
  }
  return_label: return;
}

__inline static unsigned int __bswap_32_48(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_48(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

struct link_stats const *link_stats_from_lladdr(linkaddr_t const *lladdr);

linkaddr_t const *link_stats_get_lladdr(struct link_stats const *stat_0);

int link_stats_is_fresh(struct link_stats const *stats);

void link_stats_reset(void);

void link_stats_init(void);

void link_stats_packet_sent(linkaddr_t const *lladdr, int status, int numtx);

void link_stats_input_callback(linkaddr_t const *lladdr);

static struct link_stats _link_stats_mem[300];
static nbr_table_t link_stats_struct =
  {.index = 0,
   .item_size = (int)sizeof(struct link_stats),
   .callback = (nbr_table_callback *)0,
   .data = (nbr_table_item_t *)(_link_stats_mem)};
static nbr_table_t *link_stats = & link_stats_struct;
struct ctimer periodic_timer;
struct link_stats const *link_stats_from_lladdr(linkaddr_t const *lladdr)
{
  struct link_stats const *tmp;
  tmp = (struct link_stats const *)nbr_table_get_from_lladdr(link_stats,
                                                             lladdr);
  return tmp;
}

linkaddr_t const *link_stats_get_lladdr(struct link_stats const *stat_0)
{
  linkaddr_t const *tmp;
  tmp = (linkaddr_t const *)nbr_table_get_lladdr(link_stats,
                                                 (nbr_table_item_t const *)stat_0);
  return tmp;
}

int link_stats_is_fresh(struct link_stats const *stats)
{
  int tmp_0;
  if (stats != (struct link_stats const *)0) {
    clock_time_t tmp;
    tmp = clock_time();
    ;
    if (tmp - stats->last_tx_time < (unsigned long)(10 * 60) * (unsigned long)1000) 
      if ((int)stats->freshness >= 4) tmp_0 = 1; else tmp_0 = 0;
    else tmp_0 = 0;
  }
  else tmp_0 = 0;
  return tmp_0;
}

uint16_t guess_etx_from_rssi(struct link_stats const *stats)
{
  uint16_t __retres;
  if (stats != (struct link_stats const *)0) 
    if ((int)stats->rssi == 0) {
      __retres = (unsigned short)(2 * 128);
      goto return_label;
    }
    else {
      uint16_t etx;
      int tmp;
      int16_t bounded_rssi = stats->rssi;
      if ((int)bounded_rssi < -60) bounded_rssi = bounded_rssi;
      else bounded_rssi = (short)(-60);
      if ((int)bounded_rssi < -90 + 1) bounded_rssi = (short)(-90 + 1);
      else bounded_rssi = bounded_rssi;
      etx = (unsigned short)(((-60 - -90) * 128) / ((int)bounded_rssi - -90));
      if ((int)etx < 3 * 128) tmp = (int)etx; else tmp = 3 * 128;
      __retres = (unsigned short)tmp;
      goto return_label;
    }
  __retres = (unsigned short)0xffff;
  return_label: return __retres;
}

void link_stats_packet_sent(linkaddr_t const *lladdr, int status, int numtx)
{
  struct link_stats *stats;
  uint16_t packet_etx;
  uint8_t ewma_alpha;
  int tmp;
  if (status != MAC_TX_OK) 
    if (status != MAC_TX_NOACK) goto return_label;
  stats = (struct link_stats *)nbr_table_get_from_lladdr(link_stats,lladdr);
  if (stats == (struct link_stats *)0) {
    stats = (struct link_stats *)nbr_table_add_lladdr(link_stats,lladdr,
                                                      NBR_TABLE_REASON_LINK_STATS,
                                                      (void *)0);
    if (stats != (struct link_stats *)0) stats->etx = guess_etx_from_rssi
                                         ((struct link_stats const *)stats);
    else goto return_label;
  }
  stats->last_tx_time = clock_time();
  if ((int)stats->freshness + numtx < 16) stats->freshness = (unsigned char)(
                                          (int)stats->freshness + numtx);
  else stats->freshness = (unsigned char)16;
  if (status == MAC_TX_NOACK) numtx += 12;
  packet_etx = (unsigned short)(numtx * 128);
  tmp = link_stats_is_fresh((struct link_stats const *)stats);
  if (tmp) ewma_alpha = (unsigned char)10;
  else ewma_alpha = (unsigned char)25;
  stats->etx = (unsigned short)(((unsigned int)stats->etx * (unsigned int)(
                                 100 - (int)ewma_alpha) + (unsigned int)packet_etx * (unsigned int)ewma_alpha) / (unsigned int)100);
  return_label: return;
}

void link_stats_input_callback(linkaddr_t const *lladdr)
{
  struct link_stats *stats;
  packetbuf_attr_t tmp;
  tmp = packetbuf_attr((unsigned char)PACKETBUF_ATTR_RSSI);
  int16_t packet_rssi = (short)tmp;
  stats = (struct link_stats *)nbr_table_get_from_lladdr(link_stats,lladdr);
  if (stats == (struct link_stats *)0) {
    stats = (struct link_stats *)nbr_table_add_lladdr(link_stats,lladdr,
                                                      NBR_TABLE_REASON_LINK_STATS,
                                                      (void *)0);
    if (stats != (struct link_stats *)0) {
      stats->rssi = packet_rssi;
      stats->etx = guess_etx_from_rssi((struct link_stats const *)stats);
    }
    goto return_label;
  }
  stats->rssi = (short)(((int)stats->rssi * (100 - 10) + (int)packet_rssi * 10) / 100);
  return_label: return;
}

static void periodic(void *ptr)
{
  struct link_stats *stats;
  ctimer_reset(& periodic_timer);
  stats = (struct link_stats *)nbr_table_head(link_stats);
  while (stats != (struct link_stats *)0) {
    stats->freshness = (unsigned char)((int)stats->freshness >> 1);
    stats = (struct link_stats *)nbr_table_next(link_stats,
                                                (nbr_table_item_t *)stats);
  }
  return;
}

void link_stats_reset(void)
{
  struct link_stats *stats;
  stats = (struct link_stats *)nbr_table_head(link_stats);
  while (stats != (struct link_stats *)0) {
    nbr_table_remove(link_stats,(nbr_table_item_t *)stats);
    stats = (struct link_stats *)nbr_table_next(link_stats,
                                                (nbr_table_item_t *)stats);
  }
  return;
}

void link_stats_init(void)
{
  nbr_table_register(link_stats,(nbr_table_callback *)0);
  ctimer_set(& periodic_timer,(unsigned long)(15 * 60) * (unsigned long)1000,
             & periodic,(void *)0);
  return;
}

__inline static unsigned int __bswap_32_49(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_49(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

int mac_sequence_is_duplicate(void);

void mac_sequence_register_seqno(void);

static struct seqno received_seqnos[16];
int mac_sequence_is_duplicate(void)
{
  int __retres;
  int i;
  clock_time_t now = clock_time();
  i = 0;
  while (i < 16) {
    {
      int tmp_2;
      linkaddr_t const *tmp_1;
      ;
      tmp_1 = packetbuf_addr((unsigned char)PACKETBUF_ADDR_SENDER);
      tmp_2 = linkaddr_cmp(tmp_1,
                           (linkaddr_t const *)(& received_seqnos[i].sender));
      if (tmp_2) {
        packetbuf_attr_t tmp_0;
        tmp_0 = packetbuf_attr((unsigned char)PACKETBUF_ATTR_MAC_SEQNO);
        ;
        if ((int)tmp_0 == (int)received_seqnos[i].seqno) 
          if (now - received_seqnos[i].timestamp <= (clock_time_t)(20 * 1000)) {
            __retres = 1;
            goto return_label;
          }
        break;
      }
    }
    i ++;
  }
  __retres = 0;
  return_label: return __retres;
}

void mac_sequence_register_seqno(void)
{
  int i;
  int j;
  packetbuf_attr_t tmp_1;
  linkaddr_t const *tmp_2;
  i = 0;
  while (i < 16) {
    {
      int tmp_0;
      linkaddr_t const *tmp;
      ;
      tmp = packetbuf_addr((unsigned char)PACKETBUF_ADDR_SENDER);
      tmp_0 = linkaddr_cmp(tmp,
                           (linkaddr_t const *)(& received_seqnos[i].sender));
      if (tmp_0) {
        i ++;
        break;
      }
    }
    i ++;
  }
  j = i - 1;
  while (j > 0) {
    memcpy((void *)(& received_seqnos[j]),
           (void const *)(& received_seqnos[j - 1]),sizeof(struct seqno));
    j --;
  }
  tmp_1 = packetbuf_attr((unsigned char)PACKETBUF_ATTR_MAC_SEQNO);
  received_seqnos[0].seqno = (unsigned char)tmp_1;
  received_seqnos[0].timestamp = clock_time();
  tmp_2 = packetbuf_addr((unsigned char)PACKETBUF_ADDR_SENDER);
  linkaddr_copy(& received_seqnos[0].sender,tmp_2);
  return;
}

__inline static unsigned int __bswap_32_50(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_50(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void mac_call_sent_callback(void (*sent)(void *ptr, int status,
                                         int transmissions),
                            void *ptr, int status, int num_tx)
{
  if (sent) (*sent)(ptr,status,num_tx);
  return;
}

__inline static unsigned int __bswap_32_51(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_51(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static void create_header_ie_descriptor(uint8_t *buf_0, uint8_t element_id,
                                        int ie_len)
{
  uint16_t ie_desc;
  ie_desc = (unsigned short)((ie_len & 0x7f) + (((int)element_id & 0xff) << 7));
  *(buf_0 + 0) = (unsigned char)((int)ie_desc & 0xff);
  *(buf_0 + 1) = (unsigned char)(((int)ie_desc >> 8) & 0xff);
  return;
}

static void create_payload_ie_descriptor(uint8_t *buf_0, uint8_t group_id,
                                         int ie_len)
{
  uint16_t ie_desc;
  ie_desc = (unsigned short)(((ie_len & 0x07ff) + (((int)group_id & 0x0f) << 11)) + (
                             1 << 15));
  *(buf_0 + 0) = (unsigned char)((int)ie_desc & 0xff);
  *(buf_0 + 1) = (unsigned char)(((int)ie_desc >> 8) & 0xff);
  return;
}

static void create_mlme_short_ie_descriptor(uint8_t *buf_0, uint8_t sub_id,
                                            int ie_len)
{
  uint16_t ie_desc;
  ie_desc = (unsigned short)((ie_len & 0xff) + (((int)sub_id & 0x7f) << 8));
  *(buf_0 + 0) = (unsigned char)((int)ie_desc & 0xff);
  *(buf_0 + 1) = (unsigned char)(((int)ie_desc >> 8) & 0xff);
  return;
}

static void create_mlme_long_ie_descriptor(uint8_t *buf_0, uint8_t sub_id,
                                           int ie_len)
{
  uint16_t ie_desc;
  ie_desc = (unsigned short)(((ie_len & 0x07ff) + (((int)sub_id & 0x0f) << 11)) + (
                             1 << 15));
  *(buf_0 + 0) = (unsigned char)((int)ie_desc & 0xff);
  *(buf_0 + 1) = (unsigned char)(((int)ie_desc >> 8) & 0xff);
  return;
}

int frame80215e_create_ie_header_ack_nack_time_correction(uint8_t *buf_0,
                                                          int len,
                                                          struct ieee802154_ies *ies)
{
  int __retres;
  int ie_len = 2;
  if (len >= 2 + ie_len) {
    if (ies != (struct ieee802154_ies *)0) {
      int16_t drift_us;
      uint16_t time_sync_field;
      drift_us = ies->ie_time_correction;
      time_sync_field = (unsigned short)((int)drift_us & 0x0fff);
      if (ies->ie_is_nack) time_sync_field = (unsigned short)((int)time_sync_field | 0x8000);
      *((buf_0 + 2) + 0) = (unsigned char)((int)time_sync_field & 0xff);
      *((buf_0 + 2) + 1) = (unsigned char)(((int)time_sync_field >> 8) & 0xff);
      create_header_ie_descriptor(buf_0,
                                  (unsigned char)HEADER_IE_ACK_NACK_TIME_CORRECTION,
                                  ie_len);
      __retres = 2 + ie_len;
      goto return_label;
    }
    else goto _LAND;
  }
  else {
    _LAND: {
             __retres = -1;
             goto return_label;
           }
  }
  return_label: return __retres;
}

int frame80215e_create_ie_header_list_termination_1(uint8_t *buf_0, int len,
                                                    struct ieee802154_ies *ies)
{
  int __retres;
  int ie_len = 0;
  if (len >= 2 + ie_len) {
    if (ies != (struct ieee802154_ies *)0) {
      create_header_ie_descriptor(buf_0,
                                  (unsigned char)HEADER_IE_LIST_TERMINATION_1,
                                  0);
      __retres = 2 + ie_len;
      goto return_label;
    }
    else goto _LAND;
  }
  else {
    _LAND: {
             __retres = -1;
             goto return_label;
           }
  }
  return_label: return __retres;
}

int frame80215e_create_ie_header_list_termination_2(uint8_t *buf_0, int len,
                                                    struct ieee802154_ies *ies)
{
  int __retres;
  int ie_len = 0;
  if (len >= 2 + ie_len) {
    if (ies != (struct ieee802154_ies *)0) {
      create_header_ie_descriptor(buf_0,
                                  (unsigned char)HEADER_IE_LIST_TERMINATION_2,
                                  0);
      __retres = 2 + ie_len;
      goto return_label;
    }
    else goto _LAND;
  }
  else {
    _LAND: {
             __retres = -1;
             goto return_label;
           }
  }
  return_label: return __retres;
}

int frame80215e_create_ie_payload_list_termination(uint8_t *buf_0, int len,
                                                   struct ieee802154_ies *ies)
{
  int __retres;
  int ie_len = 0;
  if (len >= 2 + ie_len) {
    if (ies != (struct ieee802154_ies *)0) {
      create_payload_ie_descriptor(buf_0,
                                   (unsigned char)PAYLOAD_IE_LIST_TERMINATION,
                                   0);
      __retres = 2 + ie_len;
      goto return_label;
    }
    else goto _LAND;
  }
  else {
    _LAND: {
             __retres = -1;
             goto return_label;
           }
  }
  return_label: return __retres;
}

int frame80215e_create_ie_mlme(uint8_t *buf_0, int len,
                               struct ieee802154_ies *ies)
{
  int __retres;
  int ie_len = 0;
  if (len >= 2 + ie_len) {
    if (ies != (struct ieee802154_ies *)0) {
      create_payload_ie_descriptor(buf_0,(unsigned char)PAYLOAD_IE_MLME,
                                   (int)ies->ie_mlme_len);
      __retres = 2 + ie_len;
      goto return_label;
    }
    else goto _LAND;
  }
  else {
    _LAND: {
             __retres = -1;
             goto return_label;
           }
  }
  return_label: return __retres;
}

int frame80215e_create_ie_tsch_synchronization(uint8_t *buf_0, int len,
                                               struct ieee802154_ies *ies)
{
  int __retres;
  int ie_len = 6;
  if (len >= 2 + ie_len) {
    if (ies != (struct ieee802154_ies *)0) {
      *(buf_0 + 2) = (unsigned char)ies->ie_asn.ls4b;
      *(buf_0 + 3) = (unsigned char)(ies->ie_asn.ls4b >> 8);
      *(buf_0 + 4) = (unsigned char)(ies->ie_asn.ls4b >> 16);
      *(buf_0 + 5) = (unsigned char)(ies->ie_asn.ls4b >> 24);
      *(buf_0 + 6) = ies->ie_asn.ms1b;
      *(buf_0 + 7) = ies->ie_join_priority;
      create_mlme_short_ie_descriptor(buf_0,
                                      (unsigned char)MLME_SHORT_IE_TSCH_SYNCHRONIZATION,
                                      ie_len);
      __retres = 2 + ie_len;
      goto return_label;
    }
    else goto _LAND;
  }
  else {
    _LAND: {
             __retres = -1;
             goto return_label;
           }
  }
  return_label: return __retres;
}

int frame80215e_create_ie_tsch_slotframe_and_link(uint8_t *buf_0, int len,
                                                  struct ieee802154_ies *ies)
{
  int __retres;
  if (ies != (struct ieee802154_ies *)0) {
    int i;
    int num_slotframes = (int)ies->ie_tsch_slotframe_and_link.num_slotframes;
    int num_links = (int)ies->ie_tsch_slotframe_and_link.num_links;
    int ie_len = 1 + num_slotframes * (4 + 5 * num_links);
    if (num_slotframes > 1) goto _LOR;
    else 
      if (num_links > 4) goto _LOR;
      else 
        if (len < 2 + ie_len) {
          _LOR: {
                  __retres = -1;
                  goto return_label;
                }
        }
    *(buf_0 + 2) = (unsigned char)num_slotframes;
    if (num_slotframes == 1) {
      *(buf_0 + (2 + 1)) = ies->ie_tsch_slotframe_and_link.slotframe_handle;
      *(((buf_0 + 2) + 2) + 0) = (unsigned char)((int)ies->ie_tsch_slotframe_and_link.slotframe_size & 0xff);
      *(((buf_0 + 2) + 2) + 1) = (unsigned char)(((int)ies->ie_tsch_slotframe_and_link.slotframe_size >> 8) & 0xff);
      *(buf_0 + (2 + 4)) = (unsigned char)num_links;
      i = 0;
      while (i < num_links) {
        *((((buf_0 + 2) + 5) + i * 5) + 0) = (unsigned char)((int)ies->ie_tsch_slotframe_and_link.links[i].timeslot & 0xff);
        *((((buf_0 + 2) + 5) + i * 5) + 1) = (unsigned char)(((int)ies->ie_tsch_slotframe_and_link.links[i].timeslot >> 8) & 0xff);
        *(((((buf_0 + 2) + 5) + i * 5) + 2) + 0) = (unsigned char)((int)ies->ie_tsch_slotframe_and_link.links[i].channel_offset & 0xff);
        *(((((buf_0 + 2) + 5) + i * 5) + 2) + 1) = (unsigned char)(((int)ies->ie_tsch_slotframe_and_link.links[i].channel_offset >> 8) & 0xff);
        *(buf_0 + (((2 + 5) + i * 5) + 4)) = ies->ie_tsch_slotframe_and_link.links[i].link_options;
        i ++;
      }
    }
    create_mlme_short_ie_descriptor(buf_0,
                                    (unsigned char)MLME_SHORT_IE_TSCH_SLOFTRAME_AND_LINK,
                                    ie_len);
    __retres = 2 + ie_len;
    goto return_label;
  }
  else {
    __retres = -1;
    goto return_label;
  }
  return_label: return __retres;
}

int frame80215e_create_ie_tsch_timeslot(uint8_t *buf_0, int len,
                                        struct ieee802154_ies *ies)
{
  int __retres;
  int ie_len;
  if (ies == (struct ieee802154_ies *)0) {
    __retres = -1;
    goto return_label;
  }
  if ((int)ies->ie_tsch_timeslot_id == 0) ie_len = 1; else ie_len = 25;
  if (len >= 2 + ie_len) {
    *(buf_0 + 2) = ies->ie_tsch_timeslot_id;
    if ((int)ies->ie_tsch_timeslot_id != 0) {
      int i;
      i = 0;
      while (i < tsch_ts_elements_count) {
        *(((buf_0 + 3) + 2 * i) + 0) = (unsigned char)((int)ies->ie_tsch_timeslot[i] & 0xff);
        *(((buf_0 + 3) + 2 * i) + 1) = (unsigned char)(((int)ies->ie_tsch_timeslot[i] >> 8) & 0xff);
        i ++;
      }
    }
    create_mlme_short_ie_descriptor(buf_0,
                                    (unsigned char)MLME_SHORT_IE_TSCH_TIMESLOT,
                                    ie_len);
    __retres = 2 + ie_len;
    goto return_label;
  }
  else {
    __retres = -1;
    goto return_label;
  }
  return_label: return __retres;
}

int frame80215e_create_ie_tsch_channel_hopping_sequence(uint8_t *buf_0,
                                                        int len,
                                                        struct ieee802154_ies *ies)
{
  int __retres;
  int ie_len;
  if (ies == (struct ieee802154_ies *)0) goto _LOR;
  else 
    if ((unsigned long)ies->ie_hopping_sequence_len > sizeof(ies->ie_hopping_sequence_list)) {
      _LOR: {
              __retres = -1;
              goto return_label;
            }
    }
  if ((int)ies->ie_channel_hopping_sequence_id == 0) ie_len = 1;
  else ie_len = 12 + (int)ies->ie_hopping_sequence_len;
  if (len >= 2 + ie_len) {
    if (ies != (struct ieee802154_ies *)0) {
      *(buf_0 + 2) = ies->ie_channel_hopping_sequence_id;
      *(buf_0 + 3) = (unsigned char)0;
      *((buf_0 + 4) + 0) = (unsigned char)(0 & 0xff);
      *((buf_0 + 4) + 1) = (unsigned char)((0 >> 8) & 0xff);
      *((buf_0 + 6) + 0) = (unsigned char)(0 & 0xff);
      *((buf_0 + 6) + 1) = (unsigned char)((0 >> 8) & 0xff);
      *((buf_0 + 8) + 0) = (unsigned char)(0 & 0xff);
      *((buf_0 + 8) + 1) = (unsigned char)((0 >> 8) & 0xff);
      *((buf_0 + 10) + 0) = (unsigned char)((int)ies->ie_hopping_sequence_len & 0xff);
      *((buf_0 + 10) + 1) = (unsigned char)(((int)ies->ie_hopping_sequence_len >> 8) & 0xff);
      memcpy((void *)(buf_0 + 12),
             (void const *)(ies->ie_hopping_sequence_list),
             (unsigned long)ies->ie_hopping_sequence_len);
      *(((buf_0 + 12) + (int)ies->ie_hopping_sequence_len) + 0) = (unsigned char)(
      0 & 0xff);
      *(((buf_0 + 12) + (int)ies->ie_hopping_sequence_len) + 1) = (unsigned char)(
      (0 >> 8) & 0xff);
      create_mlme_long_ie_descriptor(buf_0,
                                     (unsigned char)MLME_LONG_IE_TSCH_CHANNEL_HOPPING_SEQUENCE,
                                     ie_len);
      __retres = 2 + ie_len;
      goto return_label;
    }
    else goto _LAND;
  }
  else {
    _LAND: {
             __retres = -1;
             goto return_label;
           }
  }
  return_label: return __retres;
}

static int frame802154e_parse_header_ie(uint8_t const *buf_0, int len,
                                        uint8_t element_id,
                                        struct ieee802154_ies *ies)
{
  int __retres;
  switch ((int)element_id) {
    case HEADER_IE_ACK_NACK_TIME_CORRECTION: ;
    if (len == 2) {
      if (ies != (struct ieee802154_ies *)0) {
        uint16_t time_sync_field = (unsigned short)0;
        int16_t drift_us = (short)0;
        time_sync_field = (unsigned short)((int)*((uint8_t *)buf_0 + 0) | (
                                           (int)*((uint8_t *)buf_0 + 1) << 8));
        if ((int)time_sync_field & (int)((unsigned short)0x8000)) ies->ie_is_nack = (unsigned char)1;
        else ies->ie_is_nack = (unsigned char)0;
        if ((int)time_sync_field & 0x0800) drift_us = (short)((int)time_sync_field | 0xf000);
        else drift_us = (short)((int)time_sync_field & 0x0fff);
        ies->ie_time_correction = drift_us;
      }
      __retres = len;
      goto return_label;
    }
    break;
  }
  __retres = -1;
  return_label: return __retres;
}

static int frame802154e_parse_mlme_short_ie(uint8_t const *buf_0, int len,
                                            uint8_t sub_id,
                                            struct ieee802154_ies *ies)
{
  int __retres;
  switch ((int)sub_id) {
    case MLME_SHORT_IE_TSCH_SLOFTRAME_AND_LINK: ;
    if (len >= 1) {
      int i;
      int num_slotframes = (int)*(buf_0 + 0);
      int num_links = (int)*(buf_0 + 4);
      if (num_slotframes == 0) {
        __retres = len;
        goto return_label;
      }
      if (num_slotframes <= 1) 
        if (num_links <= 4) 
          if (len == 1 + num_slotframes * (4 + 5 * num_links)) {
            if (ies != (struct ieee802154_ies *)0) {
              ies->ie_tsch_slotframe_and_link.num_slotframes = *(buf_0 + 0);
              ies->ie_tsch_slotframe_and_link.slotframe_handle = *(buf_0 + 1);
              ies->ie_tsch_slotframe_and_link.slotframe_size = (unsigned short)(
              (int)*((uint8_t *)(buf_0 + 2) + 0) | ((int)*((uint8_t *)(
                                                           buf_0 + 2) + 1) << 8));
              ies->ie_tsch_slotframe_and_link.num_links = *(buf_0 + 4);
              i = 0;
              while (i < num_links) {
                ies->ie_tsch_slotframe_and_link.links[i].timeslot = (unsigned short)(
                (int)*((uint8_t *)((buf_0 + 5) + i * 5) + 0) | ((int)*(
                                                                (uint8_t *)(
                                                                (buf_0 + 5) + 
                                                                i * 5) + 1) << 8));
                ies->ie_tsch_slotframe_and_link.links[i].channel_offset = (unsigned short)(
                (int)*((uint8_t *)(((buf_0 + 5) + i * 5) + 2) + 0) | (
                (int)*((uint8_t *)(((buf_0 + 5) + i * 5) + 2) + 1) << 8));
                ies->ie_tsch_slotframe_and_link.links[i].link_options = *(
                buf_0 + ((5 + i * 5) + 4));
                i ++;
              }
            }
            __retres = len;
            goto return_label;
          }
    }
    break;
    case MLME_SHORT_IE_TSCH_SYNCHRONIZATION: ;
    if (len == 6) {
      if (ies != (struct ieee802154_ies *)0) {
        ies->ie_asn.ls4b = (unsigned int)*(buf_0 + 0);
        ies->ie_asn.ls4b |= (unsigned int)*(buf_0 + 1) << 8;
        ies->ie_asn.ls4b |= (unsigned int)*(buf_0 + 2) << 16;
        ies->ie_asn.ls4b |= (unsigned int)*(buf_0 + 3) << 24;
        ies->ie_asn.ms1b = *(buf_0 + 4);
        ies->ie_join_priority = *(buf_0 + 5);
      }
      __retres = len;
      goto return_label;
    }
    break;
    case MLME_SHORT_IE_TSCH_TIMESLOT: ;
    if (len == 1) goto _LOR;
    else 
      if (len == 25) {
        _LOR:
        {
          if (ies != (struct ieee802154_ies *)0) {
            ies->ie_tsch_timeslot_id = *(buf_0 + 0);
            if (len == 25) {
              int i_0;
              i_0 = 0;
              while (i_0 < tsch_ts_elements_count) {
                ies->ie_tsch_timeslot[i_0] = (unsigned short)((int)*(
                                                              (uint8_t *)(
                                                              (buf_0 + 1) + 
                                                              2 * i_0) + 0) | (
                                                              (int)*(
                                                              (uint8_t *)(
                                                              (buf_0 + 1) + 
                                                              2 * i_0) + 1) << 8));
                i_0 ++;
              }
            }
          }
          __retres = len;
          goto return_label;
        }
      }
    break;
  }
  __retres = -1;
  return_label: return __retres;
}

static int frame802154e_parse_mlme_long_ie(uint8_t const *buf_0, int len,
                                           uint8_t sub_id,
                                           struct ieee802154_ies *ies)
{
  int __retres;
  switch ((int)sub_id) {
    case MLME_LONG_IE_TSCH_CHANNEL_HOPPING_SEQUENCE: ;
    if (len > 0) {
      if (ies != (struct ieee802154_ies *)0) {
        ies->ie_channel_hopping_sequence_id = *(buf_0 + 0);
        if (len > 1) {
          ies->ie_hopping_sequence_len = (unsigned short)((int)*((uint8_t *)(
                                                                 buf_0 + 8) + 0) | (
                                                          (int)*((uint8_t *)(
                                                                 buf_0 + 8) + 1) << 8));
          if ((unsigned long)ies->ie_hopping_sequence_len <= sizeof(ies->ie_hopping_sequence_list)) 
            if (len == 12 + (int)ies->ie_hopping_sequence_len) memcpy
                                                               ((void *)(ies->ie_hopping_sequence_list),
                                                                (void const *)(
                                                                buf_0 + 10),
                                                                (unsigned long)ies->ie_hopping_sequence_len);
        }
      }
      __retres = len;
      goto return_label;
    }
    break;
  }
  __retres = -1;
  return_label: return __retres;
}

int frame802154e_parse_information_elements(uint8_t const *buf_0,
                                            uint8_t buf_size,
                                            struct ieee802154_ies *ies)
{
  int __retres;
  uint16_t ie_desc;
  uint8_t type;
  uint8_t id;
  enum __anonenum_parsing_state_38 parsing_state;
  uint8_t const *start = buf_0;
  uint16_t len = (unsigned short)0;
  int nested_mlme_len = 0;
  if (ies == (struct ieee802154_ies *)0) {
    __retres = -1;
    goto return_label;
  }
  parsing_state = PARSING_HEADER_IE;
  ies->ie_payload_ie_offset = (unsigned char)0;
  while ((int)buf_size > 0) {
    if ((int)buf_size < 2) {
      __retres = -1;
      goto return_label;
    }
    ie_desc = (unsigned short)((int)*((uint8_t *)buf_0 + 0) | ((int)*(
                                                               (uint8_t *)buf_0 + 1) << 8));
    buf_size = (unsigned char)((int)buf_size - 2);
    buf_0 += 2;
    if ((int)ie_desc & 0x8000) type = (unsigned char)1;
    else type = (unsigned char)0;
    {
      int tmp;
      if (0 < curr_log_level_framer) tmp = 0;
      else tmp = curr_log_level_framer;
      if (4 <= tmp) {
        printf("[%-4s: %-10s] ","DBG","Frame 15.4");
        printf("ie type %u, current state %u\n",(int)type,parsing_state);
      }
    }
    switch (parsing_state) {
      case (enum __anonenum_parsing_state_38)PARSING_HEADER_IE: ;
      if ((int)type != 0) {
        {
          int tmp_0;
          if (0 < curr_log_level_framer) tmp_0 = 0;
          else tmp_0 = curr_log_level_framer;
          if (1 <= tmp_0) {
            printf("[%-4s: %-10s] ","ERR","Frame 15.4");
            printf("header ie: wrong type %04x\n",(int)ie_desc);
          }
        }
        __retres = -1;
        goto return_label;
      }
      len = (unsigned short)((int)ie_desc & 0x007f);
      id = (unsigned char)(((int)ie_desc & 0x7f80) >> 7);
      {
        int tmp_1;
        if (0 < curr_log_level_framer) tmp_1 = 0;
        else tmp_1 = curr_log_level_framer;
        if (4 <= tmp_1) {
          printf("[%-4s: %-10s] ","DBG","Frame 15.4");
          printf("header ie: len %u id %x\n",(int)len,(int)id);
        }
      }
      switch ((int)id) {
        case HEADER_IE_LIST_TERMINATION_1: ;
        if ((int)len == 0) {
          parsing_state = PARSING_PAYLOAD_IE;
          ies->ie_payload_ie_offset = (unsigned char)(buf_0 - start);
          {
            int tmp_2;
            if (0 < curr_log_level_framer) tmp_2 = 0;
            else tmp_2 = curr_log_level_framer;
            if (4 <= tmp_2) {
              printf("[%-4s: %-10s] ","DBG","Frame 15.4");
              printf("list termination 1, look for payload IEs\n");
            }
          }
        }
        else {
          {
            int tmp_3;
            if (0 < curr_log_level_framer) tmp_3 = 0;
            else tmp_3 = curr_log_level_framer;
            if (1 <= tmp_3) {
              printf("[%-4s: %-10s] ","ERR","Frame 15.4");
              printf("list termination 1, wrong len %u\n",(int)len);
            }
          }
          __retres = -1;
          goto return_label;
        }
        break;
        case HEADER_IE_LIST_TERMINATION_2: ;
        if ((int)len == 0) {
          ies->ie_payload_ie_offset = (unsigned char)(buf_0 - start);
          {
            int tmp_4;
            if (0 < curr_log_level_framer) tmp_4 = 0;
            else tmp_4 = curr_log_level_framer;
            if (4 <= tmp_4) {
              printf("[%-4s: %-10s] ","DBG","Frame 15.4");
              printf("list termination 2\n");
            }
          }
          __retres = (int)((buf_0 + (int)len) - start);
          goto return_label;
        }
        else {
          {
            int tmp_5;
            if (0 < curr_log_level_framer) tmp_5 = 0;
            else tmp_5 = curr_log_level_framer;
            if (1 <= tmp_5) {
              printf("[%-4s: %-10s] ","ERR","Frame 15.4");
              printf("list termination 2, wrong len %u\n",(int)len);
            }
          }
          __retres = -1;
          goto return_label;
        }
        default: ;
        if ((int)len > (int)buf_size) goto _LOR;
        else {
          int tmp_7;
          tmp_7 = frame802154e_parse_header_ie(buf_0,(int)len,id,ies);
          if (tmp_7 == -1) {
            _LOR:
            {
              {
                int tmp_6;
                if (0 < curr_log_level_framer) tmp_6 = 0;
                else tmp_6 = curr_log_level_framer;
                if (1 <= tmp_6) {
                  printf("[%-4s: %-10s] ","ERR","Frame 15.4");
                  printf("failed to parse\n");
                }
              }
              __retres = -1;
              goto return_label;
            }
          }
        }
        break;
      }
      break;
      case (enum __anonenum_parsing_state_38)PARSING_PAYLOAD_IE: ;
      if ((int)type != 1) {
        {
          int tmp_8;
          if (0 < curr_log_level_framer) tmp_8 = 0;
          else tmp_8 = curr_log_level_framer;
          if (1 <= tmp_8) {
            printf("[%-4s: %-10s] ","ERR","Frame 15.4");
            printf("payload ie: wrong type %04x\n",(int)ie_desc);
          }
        }
        __retres = -1;
        goto return_label;
      }
      len = (unsigned short)((int)ie_desc & 0x7ff);
      id = (unsigned char)(((int)ie_desc & 0x7800) >> 11);
      {
        int tmp_9;
        if (0 < curr_log_level_framer) tmp_9 = 0;
        else tmp_9 = curr_log_level_framer;
        if (4 <= tmp_9) {
          printf("[%-4s: %-10s] ","DBG","Frame 15.4");
          printf("payload ie: len %u id %x\n",(int)len,(int)id);
        }
      }
      switch ((int)id) {
        long tmp_12;
        case PAYLOAD_IE_MLME: parsing_state = PARSING_MLME_SUBIE;
        nested_mlme_len = (int)len;
        len = (unsigned short)0;
        {
          int tmp_10;
          if (0 < curr_log_level_framer) tmp_10 = 0;
          else tmp_10 = curr_log_level_framer;
          if (4 <= tmp_10) {
            printf("[%-4s: %-10s] ","DBG","Frame 15.4");
            printf("entering MLME ie with len %u\n",nested_mlme_len);
          }
        }
        break;
        case PAYLOAD_IE_LIST_TERMINATION:
        {
          int tmp_11;
          if (0 < curr_log_level_framer) tmp_11 = 0;
          else tmp_11 = curr_log_level_framer;
          if (4 <= tmp_11) {
            printf("[%-4s: %-10s] ","DBG","Frame 15.4");
            printf("payload ie list termination %u\n",(int)len);
          }
        }
        if ((int)len == 0) tmp_12 = (buf_0 + (int)len) - start;
        else tmp_12 = (long)(-1);
        __retres = (int)tmp_12;
        goto return_label;
        default:
        {
          int tmp_13;
          if (0 < curr_log_level_framer) tmp_13 = 0;
          else tmp_13 = curr_log_level_framer;
          if (1 <= tmp_13) {
            printf("[%-4s: %-10s] ","ERR","Frame 15.4");
            printf("non-supported payload ie\n");
          }
        }
        __retres = -1;
        goto return_label;
      }
      break;
      case (enum __anonenum_parsing_state_38)PARSING_MLME_SUBIE: ;
      if ((int)type == 0) {
        len = (unsigned short)((int)ie_desc & 0x00ff);
        id = (unsigned char)(((int)ie_desc & 0x7f00) >> 8);
        {
          int tmp_14;
          if (0 < curr_log_level_framer) tmp_14 = 0;
          else tmp_14 = curr_log_level_framer;
          if (4 <= tmp_14) {
            printf("[%-4s: %-10s] ","DBG","Frame 15.4");
            printf("short mlme ie len %u id %x\n",(int)len,(int)id);
          }
        }
        if ((int)len > (int)buf_size) goto _LOR_0;
        else {
          int tmp_16;
          tmp_16 = frame802154e_parse_mlme_short_ie(buf_0,(int)len,id,ies);
          if (tmp_16 == -1) {
            _LOR_0:
            {
              {
                int tmp_15;
                if (0 < curr_log_level_framer) tmp_15 = 0;
                else tmp_15 = curr_log_level_framer;
                if (1 <= tmp_15) {
                  printf("[%-4s: %-10s] ","ERR","Frame 15.4");
                  printf("failed to parse ie\n");
                }
              }
              __retres = -1;
              goto return_label;
            }
          }
        }
      }
      else {
        len = (unsigned short)((int)ie_desc & 0x7ff);
        id = (unsigned char)(((int)ie_desc & 0x7800) >> 11);
        {
          int tmp_17;
          if (0 < curr_log_level_framer) tmp_17 = 0;
          else tmp_17 = curr_log_level_framer;
          if (4 <= tmp_17) {
            printf("[%-4s: %-10s] ","DBG","Frame 15.4");
            printf("long mlme ie len %u id %x\n",(int)len,(int)id);
          }
        }
        if ((int)len > (int)buf_size) goto _LOR_1;
        else {
          int tmp_19;
          tmp_19 = frame802154e_parse_mlme_long_ie(buf_0,(int)len,id,ies);
          if (tmp_19 == -1) {
            _LOR_1:
            {
              {
                int tmp_18;
                if (0 < curr_log_level_framer) tmp_18 = 0;
                else tmp_18 = curr_log_level_framer;
                if (1 <= tmp_18) {
                  printf("[%-4s: %-10s] ","ERR","Frame 15.4");
                  printf("failed to parse ie\n");
                }
              }
              __retres = -1;
              goto return_label;
            }
          }
        }
      }
      nested_mlme_len -= 2 + (int)len;
      if (nested_mlme_len < 0) {
        {
          int tmp_20;
          if (0 < curr_log_level_framer) tmp_20 = 0;
          else tmp_20 = curr_log_level_framer;
          if (1 <= tmp_20) {
            printf("[%-4s: %-10s] ","ERR","Frame 15.4");
            printf("found more sub-IEs than initially advertised\n");
          }
        }
        __retres = -1;
        goto return_label;
      }
      if (nested_mlme_len == 0) {
        {
          int tmp_21;
          if (0 < curr_log_level_framer) tmp_21 = 0;
          else tmp_21 = curr_log_level_framer;
          if (4 <= tmp_21) {
            printf("[%-4s: %-10s] ","DBG","Frame 15.4");
            printf("end of MLME IE parsing\n");
          }
        }
        parsing_state = PARSING_PAYLOAD_IE;
      }
      break;
    }
    buf_0 += (int)len;
    buf_size = (unsigned char)((int)buf_size - (int)len);
  }
  if (parsing_state == (unsigned int)PARSING_HEADER_IE) ies->ie_payload_ie_offset = (unsigned char)(
                                                        buf_0 - start);
  __retres = (int)(buf_0 - start);
  return_label: return __retres;
}

__inline static unsigned int __bswap_32_52(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_52(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void framer_802154_setup_params(packetbuf_attr_t (*get_attr)(uint8_t type),
                                uint8_t dest_is_broadcast,
                                frame802154_t *params);

static uint8_t mac_dsn;
static uint8_t initialized_0 = (unsigned char)0;
static int create_frame(int do_create)
{
  int __retres;
  frame802154_t params;
  int hdr_len;
  uint16_t tmp;
  int tmp_2;
  int tmp_4;
  linkaddr_t const *tmp_5;
  uint16_t tmp_6;
  tmp = frame802154_get_pan_id();
  if ((int)tmp == 0xffff) {
    __retres = -1;
    goto return_label;
  }
  memset((void *)(& params),0,sizeof(params));
  if (! initialized_0) {
    unsigned short tmp_0;
    initialized_0 = (unsigned char)1;
    tmp_0 = random_rand();
    mac_dsn = (unsigned char)((int)tmp_0 & 0xff);
  }
  if (do_create != 0) {
    packetbuf_attr_t tmp_1;
    tmp_1 = packetbuf_attr((unsigned char)PACKETBUF_ATTR_MAC_SEQNO);
    if ((int)tmp_1 == 0) {
      if ((int)mac_dsn == 0) mac_dsn = (uint8_t)((int)mac_dsn + 1);
      packetbuf_set_attr((unsigned char)PACKETBUF_ATTR_MAC_SEQNO,
                         (unsigned short)mac_dsn);
      mac_dsn = (uint8_t)((int)mac_dsn + 1);
    }
  }
  tmp_2 = packetbuf_holds_broadcast();
  framer_802154_setup_params(& packetbuf_attr,(unsigned char)tmp_2,& params);
  tmp_4 = packetbuf_holds_broadcast();
  if (tmp_4) {
    params.dest_addr[0] = (unsigned char)0xFF;
    params.dest_addr[1] = (unsigned char)0xFF;
  }
  else {
    linkaddr_t const *tmp_3;
    tmp_3 = packetbuf_addr((unsigned char)PACKETBUF_ADDR_RECEIVER);
    linkaddr_copy((linkaddr_t *)(& params.dest_addr),tmp_3);
  }
  tmp_5 = packetbuf_addr((unsigned char)PACKETBUF_ADDR_SENDER);
  linkaddr_copy((linkaddr_t *)(& params.src_addr),tmp_5);
  params.payload = (uint8_t *)packetbuf_dataptr();
  tmp_6 = packetbuf_datalen();
  params.payload_len = (int)tmp_6;
  hdr_len = frame802154_hdrlen(& params);
  if (! do_create) {
    __retres = hdr_len;
    goto return_label;
  }
  else {
    int tmp_14;
    tmp_14 = packetbuf_hdralloc(hdr_len);
    if (tmp_14) {
      void *tmp_7;
      tmp_7 = packetbuf_hdrptr();
      frame802154_create(& params,(uint8_t *)tmp_7);
      {
        int tmp_8;
        if (0 < curr_log_level_framer) tmp_8 = 0;
        else tmp_8 = curr_log_level_framer;
        if (3 <= tmp_8) {
          printf("[%-4s: %-10s] ","INFO","Frame 15.4");
          printf("Out: %2X ",(int)params.fcf.frame_type);
        }
      }
      {
        int tmp_9;
        if (0 < curr_log_level_framer) tmp_9 = 0;
        else tmp_9 = curr_log_level_framer;
        if (3 <= tmp_9) log_lladdr((linkaddr_t const *)(params.dest_addr));
      }
      {
        int tmp_12;
        if (0 < curr_log_level_framer) tmp_12 = 0;
        else tmp_12 = curr_log_level_framer;
        if (3 <= tmp_12) {
          uint16_t tmp_10;
          uint16_t tmp_11;
          tmp_10 = packetbuf_totlen();
          tmp_11 = packetbuf_datalen();
          ;
          printf(" %d %u (%u)\n",hdr_len,(int)tmp_11,(int)tmp_10);
        }
      }
      __retres = hdr_len;
      goto return_label;
    }
    else {
      {
        int tmp_13;
        if (0 < curr_log_level_framer) tmp_13 = 0;
        else tmp_13 = curr_log_level_framer;
        if (1 <= tmp_13) {
          printf("[%-4s: %-10s] ","ERR","Frame 15.4");
          printf("Out: too large header: %u\n",hdr_len);
        }
      }
      __retres = -1;
      goto return_label;
    }
  }
  return_label: return __retres;
}

void framer_802154_setup_params(packetbuf_attr_t (*get_attr)(uint8_t type),
                                uint8_t dest_is_broadcast,
                                frame802154_t *params)
{
  packetbuf_attr_t tmp_0;
  packetbuf_attr_t tmp_2;
  packetbuf_attr_t tmp_3;
  packetbuf_attr_t tmp_4;
  packetbuf_attr_t tmp_5;
  if (get_attr == (packetbuf_attr_t (*)(uint8_t type))0) goto _LOR;
  else 
    if (params == (frame802154_t *)0) {
      _LOR:
      {
        {
          int tmp;
          if (0 < curr_log_level_framer) tmp = 0;
          else tmp = curr_log_level_framer;
          if (3 <= tmp) {
            printf("[%-4s: %-10s] ","INFO","Frame 15.4");
            printf("framer-802154: cannot setup params because of invalid argument\n");
          }
        }
        goto return_label;
      }
    }
  tmp_0 = (*get_attr)((unsigned char)PACKETBUF_ATTR_FRAME_TYPE);
  params->fcf.frame_type = (unsigned char)tmp_0;
  params->fcf.frame_pending = (unsigned char)0;
  if (dest_is_broadcast) {
    params->fcf.ack_required = (unsigned char)0;
    params->fcf.sequence_number_suppression = (unsigned char)(0x01 >= 0x02);
  }
  else {
    packetbuf_attr_t tmp_1;
    tmp_1 = (*get_attr)((unsigned char)PACKETBUF_ATTR_MAC_ACK);
    params->fcf.ack_required = (unsigned char)tmp_1;
    params->fcf.sequence_number_suppression = (unsigned char)0;
  }
  tmp_2 = (*get_attr)((unsigned char)PACKETBUF_ATTR_MAC_METADATA);
  params->fcf.ie_list_present = (unsigned char)tmp_2;
  params->fcf.frame_version = (unsigned char)0x01;
  params->fcf.security_enabled = (unsigned char)0;
  tmp_3 = (*get_attr)((unsigned char)PACKETBUF_ATTR_MAC_SEQNO);
  params->seq = (unsigned char)tmp_3;
  params->src_pid = frame802154_get_pan_id();
  tmp_4 = (*get_attr)((unsigned char)PACKETBUF_ATTR_MAC_NO_SRC_ADDR);
  if ((int)tmp_4 == 1) params->fcf.src_addr_mode = (unsigned char)0x00;
  else 
    if (8 == 2) params->fcf.src_addr_mode = (unsigned char)0x02;
    else params->fcf.src_addr_mode = (unsigned char)0x03;
  params->dest_pid = frame802154_get_pan_id();
  tmp_5 = (*get_attr)((unsigned char)PACKETBUF_ATTR_MAC_NO_DEST_ADDR);
  if ((int)tmp_5 == 1) params->fcf.dest_addr_mode = (unsigned char)0x00;
  else 
    if (dest_is_broadcast) params->fcf.dest_addr_mode = (unsigned char)0x02;
    else 
      if (8 == 2) params->fcf.dest_addr_mode = (unsigned char)0x02;
      else params->fcf.dest_addr_mode = (unsigned char)0x03;
  if ((int)params->fcf.src_addr_mode == 0x02) goto _LOR_0;
  else 
    if ((int)params->fcf.dest_addr_mode == 0x02) _LOR_0:
                                                 params->fcf.panid_compression = (unsigned char)1;
    else params->fcf.panid_compression = (unsigned char)0;
  return_label: return;
}

static int hdr_length(void)
{
  int tmp;
  tmp = create_frame(0);
  return tmp;
}

static int create(void)
{
  int tmp;
  tmp = create_frame(1);
  return tmp;
}

static int parse(void)
{
  int __retres;
  frame802154_t frame;
  int hdr_len;
  uint16_t tmp;
  void *tmp_0;
  tmp = packetbuf_datalen();
  tmp_0 = packetbuf_dataptr();
  hdr_len = frame802154_parse((uint8_t *)tmp_0,(int)tmp,& frame);
  if (hdr_len) {
    int tmp_15;
    tmp_15 = packetbuf_hdrreduce(hdr_len);
    if (tmp_15) {
      packetbuf_set_attr((unsigned char)PACKETBUF_ATTR_FRAME_TYPE,
                         (unsigned short)frame.fcf.frame_type);
      packetbuf_set_attr((unsigned char)PACKETBUF_ATTR_MAC_ACK,
                         (unsigned short)frame.fcf.ack_required);
      if (frame.fcf.dest_addr_mode) {
        uint16_t tmp_2;
        int tmp_3;
        tmp_2 = frame802154_get_pan_id();
        ;
        if ((int)frame.dest_pid != (int)tmp_2) 
          if ((int)frame.dest_pid != 0xFFFF) {
            {
              int tmp_1;
              if (0 < curr_log_level_framer) tmp_1 = 0;
              else tmp_1 = curr_log_level_framer;
              if (2 <= tmp_1) {
                printf("[%-4s: %-10s] ","WARN","Frame 15.4");
                printf("15.4: for another pan %u\n",(int)frame.dest_pid);
              }
            }
            __retres = -1;
            goto return_label;
          }
        tmp_3 = frame802154_is_broadcast_addr(frame.fcf.dest_addr_mode,
                                              frame.dest_addr);
        if (! tmp_3) packetbuf_set_addr((unsigned char)PACKETBUF_ADDR_RECEIVER,
                                        (linkaddr_t const *)(& frame.dest_addr));
      }
      packetbuf_set_addr((unsigned char)PACKETBUF_ADDR_SENDER,
                         (linkaddr_t const *)(& frame.src_addr));
      if ((int)frame.fcf.sequence_number_suppression == 0) packetbuf_set_attr
                                                           ((unsigned char)PACKETBUF_ATTR_MAC_SEQNO,
                                                            (unsigned short)frame.seq);
      else packetbuf_set_attr((unsigned char)PACKETBUF_ATTR_MAC_SEQNO,
                              (unsigned short)0xffff);
      {
        int tmp_4;
        if (0 < curr_log_level_framer) tmp_4 = 0;
        else tmp_4 = curr_log_level_framer;
        if (3 <= tmp_4) {
          printf("[%-4s: %-10s] ","INFO","Frame 15.4");
          printf("In: %2X ",(int)frame.fcf.frame_type);
        }
      }
      {
        int tmp_7;
        if (0 < curr_log_level_framer) tmp_7 = 0;
        else tmp_7 = curr_log_level_framer;
        if (3 <= tmp_7) {
          linkaddr_t const *tmp_6;
          tmp_6 = packetbuf_addr((unsigned char)PACKETBUF_ADDR_SENDER);
          log_lladdr(tmp_6);
        }
      }
      {
        int tmp_8;
        if (0 < curr_log_level_framer) tmp_8 = 0;
        else tmp_8 = curr_log_level_framer;
        if (3 <= tmp_8) printf(" ");
      }
      {
        int tmp_11;
        if (0 < curr_log_level_framer) tmp_11 = 0;
        else tmp_11 = curr_log_level_framer;
        if (3 <= tmp_11) {
          linkaddr_t const *tmp_10;
          tmp_10 = packetbuf_addr((unsigned char)PACKETBUF_ADDR_RECEIVER);
          log_lladdr(tmp_10);
        }
      }
      {
        int tmp_14;
        if (0 < curr_log_level_framer) tmp_14 = 0;
        else tmp_14 = curr_log_level_framer;
        if (3 <= tmp_14) {
          uint16_t tmp_12;
          uint16_t tmp_13;
          tmp_12 = packetbuf_totlen();
          tmp_13 = packetbuf_datalen();
          ;
          printf(" %d %u (%u)\n",hdr_len,(int)tmp_13,(int)tmp_12);
        }
      }
      __retres = hdr_len;
      goto return_label;
    }
  }
  __retres = -1;
  return_label: return __retres;
}

struct framer const framer_802154 =
  {.length = & hdr_length, .create = & create, .parse = & parse};
__inline static unsigned int __bswap_32_53(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_53(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static int is_broadcast_addr(uint8_t mode, uint8_t *addr_0)
{
  int __retres;
  int tmp;
  if ((int)mode == 0x02) tmp = 2; else tmp = 8;
  int i = tmp;
  while (1) {
    int tmp_0;
    tmp_0 = i;
    i --;
    ;
    if (! (tmp_0 > 0)) break;
    if ((int)*(addr_0 + i) != 0xff) {
      __retres = 0;
      goto return_label;
    }
  }
  __retres = 1;
  return_label: return __retres;
}

static int hdr_length_0(void)
{
  int __retres;
  __retres = 0;
  return __retres;
}

static int create_0(void)
{
  int __retres;
  __retres = 0;
  return __retres;
}

static int parse_0(void)
{
  int __retres;
  frame802154_t frame;
  int len;
  uint16_t tmp;
  int tmp_2;
  void *tmp_1;
  tmp = packetbuf_datalen();
  len = (int)tmp;
  ;
  tmp_1 = packetbuf_dataptr();
  tmp_2 = frame802154_parse((uint8_t *)tmp_1,len,& frame);
  if (tmp_2) {
    if (frame.fcf.dest_addr_mode) {
      int tmp_0;
      tmp_0 = is_broadcast_addr(frame.fcf.dest_addr_mode,frame.dest_addr);
      if (! tmp_0) packetbuf_set_addr((unsigned char)PACKETBUF_ADDR_RECEIVER,
                                      (linkaddr_t const *)(& frame.dest_addr));
    }
    packetbuf_set_addr((unsigned char)PACKETBUF_ADDR_SENDER,
                       (linkaddr_t const *)(& frame.src_addr));
    packetbuf_set_attr((unsigned char)PACKETBUF_ATTR_MAC_SEQNO,
                       (unsigned short)frame.seq);
    packetbuf_set_attr((unsigned char)PACKETBUF_ATTR_MAC_ACK,
                       (unsigned short)frame.fcf.ack_required);
    __retres = 0;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

struct framer const no_framer =
  {.length = & hdr_length_0, .create = & create_0, .parse = & parse_0};
__inline static unsigned int __bswap_32_54(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_54(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static uint16_t mac_pan_id = (unsigned short)0xabcd;
__inline static uint8_t addr_len(uint8_t mode)
{
  uint8_t __retres;
  switch ((int)mode) {
    case 0x02: __retres = (unsigned char)2;
    goto return_label;
    case 0x03: __retres = (unsigned char)8;
    goto return_label;
    default: __retres = (unsigned char)0;
    goto return_label;
  }
  return_label: return __retres;
}

uint16_t frame802154_get_pan_id(void)
{
  return mac_pan_id;
}

void frame802154_set_pan_id(uint16_t pan_id)
{
  mac_pan_id = pan_id;
  return;
}

void frame802154_has_panid(frame802154_fcf_t *fcf, int *has_src_pan_id,
                           int *has_dest_pan_id)
{
  int src_pan_id = 0;
  int dest_pan_id = 0;
  if (fcf == (frame802154_fcf_t *)0) goto return_label;
  if ((int)fcf->frame_version == 0x02) {
    if ((int)fcf->dest_addr_mode == 0x00) {
      if ((int)fcf->src_addr_mode == 0x00) {
        if ((int)fcf->panid_compression == 1) goto _LOR_0; else goto _LAND_5;
      }
      else goto _LAND_5;
    }
    else {
      _LAND_5: ;
      if ((int)fcf->dest_addr_mode != 0x00) {
        if ((int)fcf->src_addr_mode == 0x00) {
          if ((int)fcf->panid_compression == 0) goto _LOR_0;
          else goto _LAND_3;
        }
        else goto _LAND_3;
      }
      else {
        _LAND_3: ;
        if ((int)fcf->dest_addr_mode == 0x03) {
          if ((int)fcf->src_addr_mode == 0x03) {
            if ((int)fcf->panid_compression == 0) goto _LOR_0;
            else goto _LAND_1;
          }
          else goto _LAND_1;
        }
        else {
          _LAND_1: ;
          if ((int)fcf->dest_addr_mode == 0x02) {
            if ((int)fcf->src_addr_mode != 0x00) goto _LOR_0;
            else goto _LAND;
          }
          else {
            _LAND: ;
            if ((int)fcf->dest_addr_mode != 0x00) 
              if ((int)fcf->src_addr_mode == 0x02) _LOR_0: dest_pan_id = 1;
          }
        }
      }
    }
    if ((int)fcf->panid_compression == 0) 
      if ((int)fcf->dest_addr_mode == 0x00) {
        if ((int)fcf->src_addr_mode == 0x03) goto _LOR_1; else goto _LAND_9;
      }
      else {
        _LAND_9: ;
        if ((int)fcf->dest_addr_mode == 0x00) {
          if ((int)fcf->src_addr_mode == 0x02) goto _LOR_1;
          else goto _LAND_8;
        }
        else {
          _LAND_8: ;
          if ((int)fcf->dest_addr_mode == 0x02) {
            if ((int)fcf->src_addr_mode == 0x02) goto _LOR_1;
            else goto _LAND_7;
          }
          else {
            _LAND_7: ;
            if ((int)fcf->dest_addr_mode == 0x02) {
              if ((int)fcf->src_addr_mode == 0x03) goto _LOR_1;
              else goto _LAND_6;
            }
            else {
              _LAND_6: ;
              if ((int)fcf->dest_addr_mode == 0x03) 
                if ((int)fcf->src_addr_mode == 0x02) _LOR_1: src_pan_id = 1;
            }
          }
        }
      }
  }
  else 
    if ((int)fcf->frame_type != 0x02) {
      if (! fcf->panid_compression) 
        if ((int)fcf->src_addr_mode & 3) src_pan_id = 1;
      if ((int)fcf->dest_addr_mode & 3) dest_pan_id = 1;
    }
  if (has_src_pan_id != (int *)0) *has_src_pan_id = src_pan_id;
  if (has_dest_pan_id != (int *)0) *has_dest_pan_id = dest_pan_id;
  return_label: return;
}

int frame802154_check_dest_panid(frame802154_t *frame)
{
  int __retres;
  int has_dest_panid = 0;
  if (frame == (frame802154_t *)0) {
    __retres = 0;
    goto return_label;
  }
  frame802154_has_panid(& frame->fcf,(int *)0,& has_dest_panid);
  if (! has_dest_panid) goto _LOR;
  else {
    uint16_t tmp;
    tmp = frame802154_get_pan_id();
    ;
    if ((int)frame->dest_pid != (int)tmp) 
      if ((int)frame->dest_pid != 0xFFFF) {
        _LOR: {
                __retres = 0;
                goto return_label;
              }
      }
  }
  __retres = 1;
  return_label: return __retres;
}

int frame802154_is_broadcast_addr(uint8_t mode, uint8_t *addr_0)
{
  int __retres;
  int tmp;
  if ((int)mode == 0x02) tmp = 2; else tmp = 8;
  int i = tmp;
  while (1) {
    int tmp_0;
    tmp_0 = i;
    i --;
    ;
    if (! (tmp_0 > 0)) break;
    if ((int)*(addr_0 + i) != 0xff) {
      __retres = 0;
      goto return_label;
    }
  }
  __retres = 1;
  return_label: return __retres;
}

int frame802154_extract_linkaddr(frame802154_t *frame,
                                 linkaddr_t *source_address,
                                 linkaddr_t *dest_address)
{
  int __retres;
  int src_addr_len;
  int dest_addr_len;
  if (frame == (frame802154_t *)0) {
    __retres = 0;
    goto return_label;
  }
  if (frame->fcf.src_addr_mode) {
    int tmp;
    if ((int)frame->fcf.src_addr_mode == 0x02) tmp = 2; else tmp = 8;
    src_addr_len = tmp;
  }
  else src_addr_len = 0;
  if (src_addr_len == 0) goto _LOR;
  else {
    int tmp_0;
    tmp_0 = frame802154_is_broadcast_addr(frame->fcf.src_addr_mode,
                                          frame->src_addr);
    if (tmp_0) {
      _LOR:
      if (source_address != (linkaddr_t *)0) linkaddr_copy(source_address,
                                                           & linkaddr_null);
    }
    else {
      if (src_addr_len != 8) {
        __retres = 0;
        goto return_label;
      }
      if (source_address != (linkaddr_t *)0) linkaddr_copy(source_address,
                                                           (linkaddr_t const *)(frame->src_addr));
    }
  }
  if (frame->fcf.dest_addr_mode) {
    int tmp_1;
    if ((int)frame->fcf.dest_addr_mode == 0x02) tmp_1 = 2; else tmp_1 = 8;
    dest_addr_len = tmp_1;
  }
  else dest_addr_len = 0;
  if (dest_addr_len == 0) goto _LOR_0;
  else {
    int tmp_2;
    tmp_2 = frame802154_is_broadcast_addr(frame->fcf.dest_addr_mode,
                                          frame->dest_addr);
    if (tmp_2) {
      _LOR_0:
      if (dest_address != (linkaddr_t *)0) linkaddr_copy(dest_address,
                                                         & linkaddr_null);
    }
    else {
      if (dest_addr_len != 8) {
        __retres = 0;
        goto return_label;
      }
      if (dest_address != (linkaddr_t *)0) linkaddr_copy(dest_address,
                                                         (linkaddr_t const *)(frame->dest_addr));
    }
  }
  __retres = 1;
  return_label: return __retres;
}

static void field_len(frame802154_t *p, field_length_t *flen)
{
  int has_src_panid;
  int has_dest_panid;
  memset((void *)flen,0,sizeof(field_length_t));
  if (((int)p->fcf.sequence_number_suppression & 1) == 0) flen->seqno_len = (unsigned char)1;
  if ((int)p->fcf.frame_version < 0x02) 
    if ((int)p->fcf.dest_addr_mode & 3) {
      if ((int)p->fcf.src_addr_mode & 3) {
        if ((int)p->src_pid == (int)p->dest_pid) p->fcf.panid_compression = (unsigned char)1;
        else goto _LAND_0;
      }
      else goto _LAND_0;
    }
    else _LAND_0: p->fcf.panid_compression = (unsigned char)0;
  frame802154_has_panid(& p->fcf,& has_src_panid,& has_dest_panid);
  if (has_src_panid) flen->src_pid_len = (unsigned char)2;
  if (has_dest_panid) flen->dest_pid_len = (unsigned char)2;
  flen->dest_addr_len = addr_len((unsigned char)((int)p->fcf.dest_addr_mode & 3));
  flen->src_addr_len = addr_len((unsigned char)((int)p->fcf.src_addr_mode & 3));
  return;
}

int frame802154_hdrlen(frame802154_t *p)
{
  int __retres;
  field_length_t flen;
  field_len(p,& flen);
  __retres = (((((2 + (int)flen.seqno_len) + (int)flen.dest_pid_len) + (int)flen.dest_addr_len) + (int)flen.src_pid_len) + (int)flen.src_addr_len) + (int)flen.aux_sec_len;
  return __retres;
}

void frame802154_create_fcf(frame802154_fcf_t *fcf, uint8_t *buf_0)
{
  *(buf_0 + 0) = (unsigned char)((((((int)fcf->frame_type & 7) | (((int)fcf->security_enabled & 1) << 3)) | (
                                   ((int)fcf->frame_pending & 1) << 4)) | (
                                  ((int)fcf->ack_required & 1) << 5)) | (
                                 ((int)fcf->panid_compression & 1) << 6));
  *(buf_0 + 1) = (unsigned char)((((((int)fcf->sequence_number_suppression & 1) | (
                                    ((int)fcf->ie_list_present & 1) << 1)) | (
                                   ((int)fcf->dest_addr_mode & 3) << 2)) | (
                                  ((int)fcf->frame_version & 3) << 4)) | (
                                 ((int)fcf->src_addr_mode & 3) << 6));
  return;
}

int frame802154_create(frame802154_t *p, uint8_t *buf_0)
{
  int __retres;
  int c;
  field_length_t flen;
  uint8_t pos;
  field_len(p,& flen);
  frame802154_create_fcf(& p->fcf,buf_0);
  pos = (unsigned char)2;
  if ((int)flen.seqno_len == 1) {
    uint8_t tmp;
    tmp = pos;
    pos = (uint8_t)((int)pos + 1);
    *(buf_0 + tmp) = p->seq;
  }
  if ((int)flen.dest_pid_len == 2) {
    uint8_t tmp_0;
    uint8_t tmp_1;
    tmp_0 = pos;
    pos = (uint8_t)((int)pos + 1);
    *(buf_0 + tmp_0) = (unsigned char)((int)p->dest_pid & 0xff);
    tmp_1 = pos;
    pos = (uint8_t)((int)pos + 1);
    *(buf_0 + tmp_1) = (unsigned char)(((int)p->dest_pid >> 8) & 0xff);
  }
  c = (int)flen.dest_addr_len;
  while (c > 0) {
    {
      uint8_t tmp_2;
      tmp_2 = pos;
      pos = (uint8_t)((int)pos + 1);
      *(buf_0 + tmp_2) = p->dest_addr[c - 1];
    }
    c --;
  }
  if ((int)flen.src_pid_len == 2) {
    uint8_t tmp_3;
    uint8_t tmp_4;
    tmp_3 = pos;
    pos = (uint8_t)((int)pos + 1);
    *(buf_0 + tmp_3) = (unsigned char)((int)p->src_pid & 0xff);
    tmp_4 = pos;
    pos = (uint8_t)((int)pos + 1);
    *(buf_0 + tmp_4) = (unsigned char)(((int)p->src_pid >> 8) & 0xff);
  }
  c = (int)flen.src_addr_len;
  while (c > 0) {
    {
      uint8_t tmp_5;
      tmp_5 = pos;
      pos = (uint8_t)((int)pos + 1);
      *(buf_0 + tmp_5) = p->src_addr[c - 1];
    }
    c --;
  }
  __retres = (int)pos;
  return __retres;
}

void frame802154_parse_fcf(uint8_t *data, frame802154_fcf_t *pfcf)
{
  frame802154_fcf_t fcf;
  fcf.frame_type = (unsigned char)((int)*(data + 0) & 7);
  fcf.security_enabled = (unsigned char)(((int)*(data + 0) >> 3) & 1);
  fcf.frame_pending = (unsigned char)(((int)*(data + 0) >> 4) & 1);
  fcf.ack_required = (unsigned char)(((int)*(data + 0) >> 5) & 1);
  fcf.panid_compression = (unsigned char)(((int)*(data + 0) >> 6) & 1);
  fcf.sequence_number_suppression = (unsigned char)((int)*(data + 1) & 1);
  fcf.ie_list_present = (unsigned char)(((int)*(data + 1) >> 1) & 1);
  fcf.dest_addr_mode = (unsigned char)(((int)*(data + 1) >> 2) & 3);
  fcf.frame_version = (unsigned char)(((int)*(data + 1) >> 4) & 3);
  fcf.src_addr_mode = (unsigned char)(((int)*(data + 1) >> 6) & 3);
  memcpy((void *)pfcf,(void const *)(& fcf),sizeof(frame802154_fcf_t));
  return;
}

int frame802154_parse(uint8_t *data, int len, frame802154_t *pf)
{
  int __retres;
  uint8_t *p;
  frame802154_fcf_t fcf;
  int c;
  int has_src_panid;
  int has_dest_panid;
  int tmp;
  if (len < 2) {
    __retres = 0;
    goto return_label;
  }
  p = data;
  frame802154_parse_fcf(p,& fcf);
  memcpy((void *)(& pf->fcf),(void const *)(& fcf),sizeof(frame802154_fcf_t));
  p += 2;
  if ((int)fcf.sequence_number_suppression == 0) {
    pf->seq = *(p + 0);
    p ++;
  }
  frame802154_has_panid(& fcf,& has_src_panid,& has_dest_panid);
  if (fcf.dest_addr_mode) {
    if (has_dest_panid) {
      pf->dest_pid = (unsigned short)((int)*(p + 0) + ((int)*(p + 1) << 8));
      p += 2;
    }
    else pf->dest_pid = (unsigned short)0;
    if ((int)fcf.dest_addr_mode == 0x02) {
      linkaddr_copy((linkaddr_t *)(& pf->dest_addr),& linkaddr_null);
      pf->dest_addr[0] = *(p + 1);
      pf->dest_addr[1] = *(p + 0);
      p += 2;
    }
    else 
      if ((int)fcf.dest_addr_mode == 0x03) {
        c = 0;
        while (c < 8) {
          pf->dest_addr[c] = *(p + (7 - c));
          c ++;
        }
        p += 8;
      }
  }
  else {
    linkaddr_copy((linkaddr_t *)(& pf->dest_addr),& linkaddr_null);
    pf->dest_pid = (unsigned short)0;
  }
  if (fcf.src_addr_mode) {
    if (has_src_panid) {
      pf->src_pid = (unsigned short)((int)*(p + 0) + ((int)*(p + 1) << 8));
      p += 2;
      if (! has_dest_panid) pf->dest_pid = pf->src_pid;
    }
    else pf->src_pid = pf->dest_pid;
    if ((int)fcf.src_addr_mode == 0x02) {
      linkaddr_copy((linkaddr_t *)(& pf->src_addr),& linkaddr_null);
      pf->src_addr[0] = *(p + 1);
      pf->src_addr[1] = *(p + 0);
      p += 2;
    }
    else 
      if ((int)fcf.src_addr_mode == 0x03) {
        c = 0;
        while (c < 8) {
          pf->src_addr[c] = *(p + (7 - c));
          c ++;
        }
        p += 8;
      }
  }
  else {
    linkaddr_copy((linkaddr_t *)(& pf->src_addr),& linkaddr_null);
    pf->src_pid = (unsigned short)0;
  }
  c = (int)(p - data);
  pf->payload_len = len - c;
  pf->payload = p;
  if (c > len) tmp = 0; else tmp = c;
  __retres = tmp;
  return_label: return __retres;
}

__inline static unsigned int __bswap_32_55(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_55(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static void send_packet(void (*sent)(void *ptr, int status, int transmissions),
                        void *ptr)
{
  return;
}

static void packet_input(void)
{
  return;
}

static int on_0(void)
{
  int __retres;
  __retres = 0;
  return __retres;
}

static int off_0(void)
{
  int __retres;
  __retres = 0;
  return __retres;
}

static int max_payload(void)
{
  int __retres;
  __retres = 0;
  return __retres;
}

static void init_0(void)
{
  return;
}

struct mac_driver const nullmac_driver =
  {.name = (char *)"nullmac",
   .init = & init_0,
   .send = & send_packet,
   .input = & packet_input,
   .on = & on_0,
   .off = & off_0,
   .max_payload = & max_payload};
__inline static unsigned int __bswap_32_56(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_56(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static uint16_t uipbuf_attrs[UIPBUF_ATTR_MAX];
static uint16_t uipbuf_default_attrs[UIPBUF_ATTR_MAX];
void uipbuf_clear(void)
{
  uip_len = (unsigned short)0;
  uip_ext_len = (unsigned short)0;
  uip_last_proto = (unsigned char)0;
  uipbuf_clear_attr();
  return;
}

_Bool uipbuf_add_ext_hdr(int16_t len)
{
  _Bool __retres;
  if ((int)len + (int)uip_len <= 1280) {
    if ((int)len + (int)uip_len >= 0) {
      if ((int)len + (int)uip_ext_len >= 0) {
        uip_ext_len = (unsigned short)((int)uip_ext_len + (int)len);
        uip_len = (unsigned short)((int)uip_len + (int)len);
        __retres = (_Bool)1;
        goto return_label;
      }
      else goto _LAND_0;
    }
    else goto _LAND_0;
  }
  else {
    _LAND_0: {
               __retres = (_Bool)0;
               goto return_label;
             }
  }
  return_label: return __retres;
}

_Bool uipbuf_set_len(uint16_t len)
{
  _Bool __retres;
  if ((int)len <= 1280) {
    uip_len = len;
    __retres = (_Bool)1;
    goto return_label;
  }
  else {
    __retres = (_Bool)0;
    goto return_label;
  }
  return_label: return __retres;
}

void uipbuf_set_len_field(struct uip_ip_hdr *hdr, uint16_t len)
{
  hdr->len[0] = (unsigned char)((int)len >> 8);
  hdr->len[1] = (unsigned char)((int)len & 0xff);
  return;
}

uint16_t uipbuf_get_len_field(struct uip_ip_hdr *hdr)
{
  uint16_t __retres;
  __retres = (unsigned short)(((int)((unsigned short)hdr->len[0]) << 8) + (int)hdr->len[1]);
  return __retres;
}

uint8_t *uipbuf_get_next_header(uint8_t *buffer, uint16_t size,
                                uint8_t *protocol, _Bool start)
{
  uint8_t *__retres;
  int curr_hdr_len = 0;
  int next_hdr_len = 0;
  uint8_t *next_header = (uint8_t *)0;
  struct uip_ip_hdr *ipbuf = (struct uip_ip_hdr *)0;
  struct uip_ext_hdr *curr_ext = (struct uip_ext_hdr *)0;
  struct uip_ext_hdr *next_ext = (struct uip_ext_hdr *)0;
  if (start) {
    ipbuf = (struct uip_ip_hdr *)buffer;
    *protocol = ipbuf->proto;
    curr_hdr_len = 40;
  }
  else {
    curr_ext = (struct uip_ext_hdr *)buffer;
    *protocol = curr_ext->next;
    curr_hdr_len = ((int)curr_ext->len << 3) + 8;
  }
  if (curr_hdr_len > (int)size) {
    __retres = (uint8_t *)0;
    goto return_label;
  }
  next_header = buffer + curr_hdr_len;
  if ((int)*protocol != 6) {
    if ((int)*protocol != 17) {
      if ((int)*protocol != 58) {
        next_ext = (struct uip_ext_hdr *)next_header;
        next_hdr_len = ((int)next_ext->len << 3) + 8;
      }
      else goto _LAND_0;
    }
    else goto _LAND_0;
  }
  else 
    _LAND_0:
    if ((int)*protocol == 6) next_hdr_len = 20;
    else 
      if ((int)*protocol == 17) next_hdr_len = 8;
      else 
        if ((int)*protocol == 58) next_hdr_len = 4;
  if (next_hdr_len == 0) goto _LOR;
  else 
    if (curr_hdr_len + next_hdr_len > (int)size) {
      _LOR: {
              __retres = (uint8_t *)0;
              goto return_label;
            }
    }
  __retres = next_header;
  return_label: return __retres;
}

uint8_t *uipbuf_get_last_header(uint8_t *buffer, uint16_t size,
                                uint8_t *protocol)
{
  uint8_t *nbuf;
  nbuf = uipbuf_get_next_header(buffer,size,protocol,(_Bool)1);
  while (1) {
    if (nbuf != (uint8_t *)0) 
      if ((int)*protocol != 6) 
        if ((int)*protocol != 17) {
          if (! ((int)*protocol != 58)) break;
        }
        else break;
      else break;
    else break;
    nbuf = uipbuf_get_next_header(nbuf,
                                  (unsigned short)((long)size - (nbuf - buffer)),
                                  protocol,(_Bool)0);
  }
  return nbuf;
}

uint8_t *uipbuf_search_header(uint8_t *buffer, uint16_t size,
                              uint8_t protocol)
{
  uint8_t *__retres;
  uint8_t *nbuf;
  uint8_t next_proto;
  nbuf = uipbuf_get_next_header(buffer,size,& next_proto,(_Bool)1);
  while (1) {
    if (nbuf != (uint8_t *)0) 
      if ((int)next_proto != (int)protocol) 
        if ((int)next_proto != 6) 
          if ((int)next_proto != 17) {
            if (! ((int)next_proto != 58)) break;
          }
          else break;
        else break;
      else break;
    else break;
    nbuf = uipbuf_get_next_header(nbuf,
                                  (unsigned short)((long)size - (nbuf - buffer)),
                                  & next_proto,(_Bool)0);
  }
  if ((int)next_proto == (int)protocol) {
    __retres = nbuf;
    goto return_label;
  }
  else {
    __retres = (uint8_t *)0;
    goto return_label;
  }
  return_label: return __retres;
}

uint16_t uipbuf_get_attr(uint8_t type)
{
  uint16_t __retres;
  if ((int)type < UIPBUF_ATTR_MAX) {
    __retres = uipbuf_attrs[type];
    goto return_label;
  }
  __retres = (unsigned short)0;
  return_label: return __retres;
}

int uipbuf_set_attr(uint8_t type, uint16_t value)
{
  int __retres;
  if ((int)type < UIPBUF_ATTR_MAX) {
    uipbuf_attrs[type] = value;
    __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int uipbuf_set_default_attr(uint8_t type, uint16_t value)
{
  int __retres;
  if ((int)type < UIPBUF_ATTR_MAX) {
    uipbuf_default_attrs[type] = value;
    __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

void uipbuf_clear_attr(void)
{
  memcpy((void *)(uipbuf_attrs),(void const *)(uipbuf_default_attrs),
         sizeof(uipbuf_attrs));
  return;
}

void uipbuf_set_attr_flag(uint16_t flag)
{
  uipbuf_attrs[UIPBUF_ATTR_FLAGS] = (unsigned short)((int)uipbuf_attrs[UIPBUF_ATTR_FLAGS] | (int)flag);
  return;
}

void uipbuf_clr_attr_flag(uint16_t flag)
{
  uipbuf_attrs[UIPBUF_ATTR_FLAGS] = (unsigned short)((int)uipbuf_attrs[UIPBUF_ATTR_FLAGS] & ~ ((int)flag));
  return;
}

uint16_t uipbuf_is_attr_flag(uint16_t flag)
{
  uint16_t __retres;
  __retres = (unsigned short)(((int)uipbuf_attrs[UIPBUF_ATTR_FLAGS] & (int)flag) == (int)flag);
  return __retres;
}

void uipbuf_init(void)
{
  memset((void *)(uipbuf_default_attrs),0,sizeof(uipbuf_default_attrs));
  uipbuf_set_default_attr((unsigned char)UIPBUF_ATTR_MAX_MAC_TRANSMISSIONS,
                          (unsigned short)0);
  uipbuf_set_default_attr((unsigned char)UIPBUF_ATTR_LLSEC_LEVEL,
                          (unsigned short)0xffff);
  return;
}

__inline static unsigned int __bswap_32_57(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_57(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static uip_ipaddr_t tmp_ipaddr;
static void *echo_reply_callback_list_list = (void *)0;
static list_t echo_reply_callback_list = & echo_reply_callback_list_list;
static void *input_handler_list_list = (void *)0;
static list_t input_handler_list = & input_handler_list_list;
static uip_icmp6_input_handler_t *input_handler_lookup(uint8_t type,
                                                       uint8_t icode)
{
  uip_icmp6_input_handler_t *__retres;
  uip_icmp6_input_handler_t *handler = (uip_icmp6_input_handler_t *)0;
  handler = (uip_icmp6_input_handler_t *)list_head(input_handler_list);
  while (handler != (uip_icmp6_input_handler_t *)0) {
    if ((int)handler->type == (int)type) 
      if ((int)handler->icode == (int)icode) goto _LOR;
      else 
        if ((int)handler->icode == 0xFF) {
          _LOR: {
                  __retres = handler;
                  goto return_label;
                }
        }
    handler = (uip_icmp6_input_handler_t *)list_item_next((void *)handler);
  }
  __retres = (uip_icmp6_input_handler_t *)0;
  return_label: return __retres;
}

uint8_t uip_icmp6_input(uint8_t type, uint8_t icode)
{
  uint8_t __retres;
  uip_icmp6_input_handler_t *handler = input_handler_lookup(type,icode);
  if (handler == (uip_icmp6_input_handler_t *)0) {
    __retres = (unsigned char)1;
    goto return_label;
  }
  if (handler->handler == (void (*)(void))0) {
    __retres = (unsigned char)1;
    goto return_label;
  }
  (*(handler->handler))();
  __retres = (unsigned char)0;
  return_label: return __retres;
}

void uip_icmp6_register_input_handler(uip_icmp6_input_handler_t *handler)
{
  list_add(input_handler_list,(void *)handler);
  return;
}

static void echo_request_input(void)
{
  uint16_t tmp_4;
  {
    int tmp;
    if (0 < curr_log_level_ipv6) tmp = 0; else tmp = curr_log_level_ipv6;
    if (3 <= tmp) {
      printf("[%-4s: %-10s] ","INFO","ICMPv6");
      printf("Received Echo Request from ");
    }
  }
  {
    int tmp_0;
    if (0 < curr_log_level_ipv6) tmp_0 = 0; else tmp_0 = curr_log_level_ipv6;
    if (3 <= tmp_0) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr));
  }
  {
    int tmp_1;
    if (0 < curr_log_level_ipv6) tmp_1 = 0; else tmp_1 = curr_log_level_ipv6;
    if (3 <= tmp_1) printf(" to ");
  }
  {
    int tmp_2;
    if (0 < curr_log_level_ipv6) tmp_2 = 0; else tmp_2 = curr_log_level_ipv6;
    if (3 <= tmp_2) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
  }
  {
    int tmp_3;
    if (0 < curr_log_level_ipv6) tmp_3 = 0; else tmp_3 = curr_log_level_ipv6;
    if (3 <= tmp_3) printf("\n");
  }
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->ttl = uip_ds6_if.cur_hop_limit;
  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[0] == 0xFF) {
    ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr;
    uip_ds6_select_src(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr,
                       & ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr);
  }
  else {
    tmp_ipaddr = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr;
    ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr;
    ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr = tmp_ipaddr;
  }
  uip_remove_ext_hdr();
  ((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->type = (unsigned char)129;
  ((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->icode = (unsigned char)0;
  ((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->icmpchksum = (unsigned short)0;
  tmp_4 = uip_icmp6chksum();
  ((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->icmpchksum = (unsigned short)(~ ((int)tmp_4));
  {
    int tmp_5;
    if (0 < curr_log_level_ipv6) tmp_5 = 0; else tmp_5 = curr_log_level_ipv6;
    if (3 <= tmp_5) {
      printf("[%-4s: %-10s] ","INFO","ICMPv6");
      printf("Sending Echo Reply to ");
    }
  }
  {
    int tmp_6;
    if (0 < curr_log_level_ipv6) tmp_6 = 0; else tmp_6 = curr_log_level_ipv6;
    if (3 <= tmp_6) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
  }
  {
    int tmp_7;
    if (0 < curr_log_level_ipv6) tmp_7 = 0; else tmp_7 = curr_log_level_ipv6;
    if (3 <= tmp_7) printf(" from ");
  }
  {
    int tmp_8;
    if (0 < curr_log_level_ipv6) tmp_8 = 0; else tmp_8 = curr_log_level_ipv6;
    if (3 <= tmp_8) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr));
  }
  {
    int tmp_9;
    if (0 < curr_log_level_ipv6) tmp_9 = 0; else tmp_9 = curr_log_level_ipv6;
    if (3 <= tmp_9) printf("\n");
  }
  return;
}

void uip_icmp6_error_output(uint8_t type, uint8_t code, uint32_t param)
{
  uint16_t shift;
  _Bool tmp_0;
  uint16_t tmp_1;
  if ((int)uip_last_proto == 58) 
    if ((int)((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->type < 128) {
      uipbuf_clear();
      goto return_label;
    }
  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[0] == 0) {
    if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[1] == 0) {
      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[2] == 0) {
        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[3] == 0) {
          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[4] == 0) {
            if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[5] == 0) {
              if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[6] == 0) {
                if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[7] == 0) 
                  goto _LOR;
                else goto _LAND_5;
              }
              else goto _LAND_5;
            }
            else goto _LAND_5;
          }
          else goto _LAND_5;
        }
        else goto _LAND_5;
      }
      else goto _LAND_5;
    }
    else goto _LAND_5;
  }
  else {
    _LAND_5: ;
    if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u8[0] == 0xFF) {
      _LOR: {
              uipbuf_clear();
              goto return_label;
            }
    }
  }
  tmp_0 = (*(rpl_lite_driver.ext_header_remove))();
  if ((int)tmp_0 == 0) {
    int tmp;
    if (0 < curr_log_level_ipv6) tmp = 0; else tmp = curr_log_level_ipv6;
    if (2 <= tmp) {
      printf("[%-4s: %-10s] ","WARN","ICMPv6");
      printf("Unable to remove ext header before sending ICMPv6 ERROR message\n");
    }
  }
  tmp_ipaddr = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr;
  shift = (unsigned short)((40 + 4) + 4);
  uip_len = (unsigned short)((int)uip_len + (int)shift);
  if ((int)uip_len < 1280) uip_len = uip_len;
  else uip_len = (unsigned short)1280;
  uip_ext_len = (unsigned short)0;
  memmove((void *)(& uip_aligned_buf.u8[shift]),
          (void const *)(uip_aligned_buf.u8),
          (unsigned long)((int)uip_len - (int)shift));
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->vtc = (unsigned char)0x60;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->tcflow = (unsigned char)0;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->flow = (unsigned short)0;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto = (unsigned char)58;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->ttl = uip_ds6_if.cur_hop_limit;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr;
  if ((int)tmp_ipaddr.u8[0] == 0xFF) 
    if ((int)type == 4) {
      if ((int)code == 2) uip_ds6_select_src(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr,
                                             & tmp_ipaddr);
      else goto _LAND_6;
    }
    else {
      _LAND_6: {
                 uipbuf_clear();
                 goto return_label;
               }
    }
  else uip_ds6_select_src(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr,
                          & tmp_ipaddr);
  ((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->type = type;
  ((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->icode = code;
  ((struct uip_icmp6_error *)((& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4))->param = uip_htonl
  (param);
  uipbuf_set_len_field((struct uip_ip_hdr *)(uip_aligned_buf.u8),
                       (unsigned short)((int)uip_len - 40));
  ((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->icmpchksum = (unsigned short)0;
  tmp_1 = uip_icmp6chksum();
  ((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->icmpchksum = (unsigned short)(~ ((int)tmp_1));
  {
    int tmp_2;
    if (0 < curr_log_level_ipv6) tmp_2 = 0; else tmp_2 = curr_log_level_ipv6;
    if (2 <= tmp_2) {
      printf("[%-4s: %-10s] ","WARN","ICMPv6");
      printf("Sending ICMPv6 ERROR message type %d code %d to ",(int)type,
             (int)code);
    }
  }
  {
    int tmp_3;
    if (0 < curr_log_level_ipv6) tmp_3 = 0; else tmp_3 = curr_log_level_ipv6;
    if (2 <= tmp_3) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
  }
  {
    int tmp_4;
    if (0 < curr_log_level_ipv6) tmp_4 = 0; else tmp_4 = curr_log_level_ipv6;
    if (2 <= tmp_4) printf(" from ");
  }
  {
    int tmp_5;
    if (0 < curr_log_level_ipv6) tmp_5 = 0; else tmp_5 = curr_log_level_ipv6;
    if (2 <= tmp_5) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr));
  }
  {
    int tmp_6;
    if (0 < curr_log_level_ipv6) tmp_6 = 0; else tmp_6 = curr_log_level_ipv6;
    if (2 <= tmp_6) printf("\n");
  }
  return_label: return;
}

void uip_icmp6_send(uip_ipaddr_t const *dest, int type, int code,
                    int payload_len)
{
  uint16_t tmp;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->vtc = (unsigned char)0x60;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->tcflow = (unsigned char)0;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->flow = (unsigned short)0;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto = (unsigned char)58;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->ttl = uip_ds6_if.cur_hop_limit;
  uipbuf_set_len_field((struct uip_ip_hdr *)(uip_aligned_buf.u8),
                       (unsigned short)(4 + payload_len));
  memcpy((void *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr),
         (void const *)dest,sizeof(*dest));
  uip_ds6_select_src(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr,
                     & ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr);
  ((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->type = (unsigned char)type;
  ((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->icode = (unsigned char)code;
  ((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->icmpchksum = (unsigned short)0;
  tmp = uip_icmp6chksum();
  ((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->icmpchksum = (unsigned short)(~ ((int)tmp));
  uip_len = (unsigned short)((40 + 4) + payload_len);
  {
    int tmp_0;
    if (0 < curr_log_level_ipv6) tmp_0 = 0; else tmp_0 = curr_log_level_ipv6;
    if (3 <= tmp_0) {
      printf("[%-4s: %-10s] ","INFO","ICMPv6");
      printf("Sending ICMPv6 packet to ");
    }
  }
  {
    int tmp_1;
    if (0 < curr_log_level_ipv6) tmp_1 = 0; else tmp_1 = curr_log_level_ipv6;
    if (3 <= tmp_1) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
  }
  {
    int tmp_2;
    if (0 < curr_log_level_ipv6) tmp_2 = 0; else tmp_2 = curr_log_level_ipv6;
    if (3 <= tmp_2) printf(", type %u, code %u, len %u\n",type,code,
                           payload_len);
  }
  tcpip_ipv6_output();
  return;
}

static void echo_reply_input(void)
{
  int ttl;
  uip_ipaddr_t sender;
  {
    int tmp;
    if (0 < curr_log_level_ipv6) tmp = 0; else tmp = curr_log_level_ipv6;
    if (3 <= tmp) {
      printf("[%-4s: %-10s] ","INFO","ICMPv6");
      printf("Received Echo Reply from ");
    }
  }
  {
    int tmp_0;
    if (0 < curr_log_level_ipv6) tmp_0 = 0; else tmp_0 = curr_log_level_ipv6;
    if (3 <= tmp_0) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr));
  }
  {
    int tmp_1;
    if (0 < curr_log_level_ipv6) tmp_1 = 0; else tmp_1 = curr_log_level_ipv6;
    if (3 <= tmp_1) printf(" to ");
  }
  {
    int tmp_2;
    if (0 < curr_log_level_ipv6) tmp_2 = 0; else tmp_2 = curr_log_level_ipv6;
    if (3 <= tmp_2) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
  }
  {
    int tmp_3;
    if (0 < curr_log_level_ipv6) tmp_3 = 0; else tmp_3 = curr_log_level_ipv6;
    if (3 <= tmp_3) printf("\n");
  }
  sender = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr;
  ttl = (int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->ttl;
  uip_remove_ext_hdr();
  {
    struct uip_icmp6_echo_reply_notification *n;
    n = (struct uip_icmp6_echo_reply_notification *)list_head(echo_reply_callback_list);
    while (n != (struct uip_icmp6_echo_reply_notification *)0) {
      if (n->callback != (void (*)(uip_ipaddr_t *source, uint8_t ttl,
                                   uint8_t *data, uint16_t datalen))0) 
        (*(n->callback))(& sender,(unsigned char)ttl,
                         (uint8_t *)((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len) + sizeof(struct uip_icmp_hdr)),
                         (unsigned short)(((unsigned long)uip_len - sizeof(struct uip_icmp_hdr)) - (unsigned long)40));
      n = (struct uip_icmp6_echo_reply_notification *)list_item_next((void *)n);
    }
  }
  uipbuf_clear();
  return;
}

void uip_icmp6_echo_reply_callback_add(struct uip_icmp6_echo_reply_notification *n,
                                       void (*c)(uip_ipaddr_t *source,
                                                 uint8_t ttl, uint8_t *data,
                                                 uint16_t datalen))
{
  if (n != (struct uip_icmp6_echo_reply_notification *)0) 
    if (c != (void (*)(uip_ipaddr_t *source, uint8_t ttl, uint8_t *data,
                       uint16_t datalen))0) {
      n->callback = c;
      list_add(echo_reply_callback_list,(void *)n);
    }
  return;
}

void uip_icmp6_echo_reply_callback_rm(struct uip_icmp6_echo_reply_notification *n)
{
  list_remove(echo_reply_callback_list,(void *)n);
  return;
}

static uip_icmp6_input_handler_t echo_request_handler =
  {.next = (struct uip_icmp6_input_handler *)0,
   .type = (unsigned char)128,
   .icode = (unsigned char)0xFF,
   .handler = & echo_request_input};
static uip_icmp6_input_handler_t echo_reply_handler =
  {.next = (struct uip_icmp6_input_handler *)0,
   .type = (unsigned char)129,
   .icode = (unsigned char)0xFF,
   .handler = & echo_reply_input};
void uip_icmp6_init(void)
{
  uip_icmp6_register_input_handler(& echo_request_handler);
  uip_icmp6_register_input_handler(& echo_reply_handler);
  return;
}

__inline static unsigned int __bswap_32_58(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_58(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static int num_nodes;
static void *nodelist_list = (void *)0;
static list_t nodelist = & nodelist_list;
static char nodememb_memb_count[300];
static uip_sr_node_t nodememb_memb_mem[300];
static struct memb nodememb =
  {.size = (unsigned short)sizeof(uip_sr_node_t),
   .num = (unsigned short)300,
   .count = nodememb_memb_count,
   .mem = (void *)(nodememb_memb_mem)};
int uip_sr_num_nodes(void)
{
  return num_nodes;
}

static int node_matches_address(void *graph, uip_sr_node_t const *node,
                                uip_ipaddr_t const *addr_0)
{
  int __retres;
  if (node == (uip_sr_node_t const *)0) goto _LOR;
  else 
    if (addr_0 == (uip_ipaddr_t const *)0) goto _LOR;
    else 
      if (graph != node->graph) {
        _LOR: {
                __retres = 0;
                goto return_label;
              }
      }
      else {
        uip_ipaddr_t node_ipaddr;
        int tmp;
        (*(rpl_lite_driver.get_sr_node_ipaddr))(& node_ipaddr,node);
        tmp = memcmp((void const *)(& node_ipaddr),(void const *)addr_0,
                     sizeof(uip_ip6addr_t));
        __retres = tmp == 0;
        goto return_label;
      }
  return_label: return __retres;
}

uip_sr_node_t *uip_sr_get_node(void *graph, uip_ipaddr_t const *addr_0)
{
  uip_sr_node_t *__retres;
  uip_sr_node_t *l;
  l = (uip_sr_node_t *)list_head(nodelist);
  while (l != (uip_sr_node_t *)0) {
    {
      int tmp;
      tmp = node_matches_address(graph,(uip_sr_node_t const *)l,addr_0);
      if (tmp) {
        __retres = l;
        goto return_label;
      }
    }
    l = (uip_sr_node_t *)list_item_next((void *)l);
  }
  __retres = (uip_sr_node_t *)0;
  return_label: return __retres;
}

int uip_sr_is_addr_reachable(void *graph, uip_ipaddr_t const *addr_0)
{
  uip_ipaddr_t root_ipaddr;
  uip_sr_node_t *node;
  uip_sr_node_t *root_node;
  int tmp;
  int max_depth = 300;
  (*(rpl_lite_driver.get_root_ipaddr))(& root_ipaddr);
  node = uip_sr_get_node(graph,addr_0);
  root_node = uip_sr_get_node(graph,(uip_ipaddr_t const *)(& root_ipaddr));
  while (1) {
    if (node != (uip_sr_node_t *)0) 
      if (node != root_node) {
        if (! (max_depth > 0)) break;
      }
      else break;
    else break;
    node = node->parent;
    max_depth --;
  }
  if (node != (uip_sr_node_t *)0) 
    if (node == root_node) tmp = 1; else tmp = 0;
  else tmp = 0;
  return tmp;
}

void uip_sr_expire_parent(void *graph, uip_ipaddr_t const *child,
                          uip_ipaddr_t const *parent)
{
  uip_sr_node_t *l = uip_sr_get_node(graph,child);
  if (l != (uip_sr_node_t *)0) {
    int tmp_0;
    tmp_0 = node_matches_address(graph,(uip_sr_node_t const *)l->parent,
                                 parent);
    if (tmp_0) l->lifetime = (unsigned int)60;
  }
  return;
}

uip_sr_node_t *uip_sr_update_node(void *graph, uip_ipaddr_t const *child,
                                  uip_ipaddr_t const *parent,
                                  uint32_t lifetime)
{
  uip_sr_node_t *__retres;
  uip_sr_node_t *old_parent_node;
  int tmp_6;
  uip_sr_node_t *child_node = uip_sr_get_node(graph,child);
  uip_sr_node_t *parent_node = uip_sr_get_node(graph,parent);
  if (parent != (uip_ipaddr_t const *)0) 
    if (parent_node == (uip_sr_node_t *)0) {
      parent_node = uip_sr_update_node(graph,parent,(uip_ipaddr_t const *)0,
                                       0xFFFFFFFF);
      if (parent_node == (uip_sr_node_t *)0) {
        {
          int tmp_1;
          if (0 < curr_log_level_ipv6) tmp_1 = 0;
          else tmp_1 = curr_log_level_ipv6;
          if (1 <= tmp_1) {
            printf("[%-4s: %-10s] ","ERR","IPv6 SR");
            printf("NS: no space left for root node!\n");
          }
        }
        __retres = (uip_sr_node_t *)0;
        goto return_label;
      }
    }
  if (child_node == (uip_sr_node_t *)0) {
    child_node = (uip_sr_node_t *)memb_alloc(& nodememb);
    if (child_node == (uip_sr_node_t *)0) {
      {
        int tmp_2;
        if (0 < curr_log_level_ipv6) tmp_2 = 0;
        else tmp_2 = curr_log_level_ipv6;
        if (1 <= tmp_2) {
          printf("[%-4s: %-10s] ","ERR","IPv6 SR");
          printf("NS: no space left for child ");
        }
      }
      {
        int tmp_3;
        if (0 < curr_log_level_ipv6) tmp_3 = 0;
        else tmp_3 = curr_log_level_ipv6;
        if (1 <= tmp_3) log_6addr(child);
      }
      {
        int tmp_4;
        if (0 < curr_log_level_ipv6) tmp_4 = 0;
        else tmp_4 = curr_log_level_ipv6;
        if (1 <= tmp_4) printf("\n");
      }
      __retres = (uip_sr_node_t *)0;
      goto return_label;
    }
    child_node->parent = (struct uip_sr_node *)0;
    list_add(nodelist,(void *)child_node);
    num_nodes ++;
  }
  child_node->graph = graph;
  child_node->lifetime = lifetime;
  memcpy((void *)(child_node->link_identifier),
         (void const *)((unsigned char const *)child + 8),(unsigned long)8);
  tmp_6 = uip_sr_is_addr_reachable(graph,child);
  if (tmp_6) {
    int tmp_5;
    old_parent_node = child_node->parent;
    child_node->parent = parent_node;
    tmp_5 = uip_sr_is_addr_reachable(graph,child);
    if (! tmp_5) child_node->parent = old_parent_node;
  }
  else child_node->parent = parent_node;
  {
    int tmp_7;
    if (0 < curr_log_level_ipv6) tmp_7 = 0; else tmp_7 = curr_log_level_ipv6;
    if (3 <= tmp_7) {
      printf("[%-4s: %-10s] ","INFO","IPv6 SR");
      printf("NS: updating link, child ");
    }
  }
  {
    int tmp_8;
    if (0 < curr_log_level_ipv6) tmp_8 = 0; else tmp_8 = curr_log_level_ipv6;
    if (3 <= tmp_8) log_6addr(child);
  }
  {
    int tmp_9;
    if (0 < curr_log_level_ipv6) tmp_9 = 0; else tmp_9 = curr_log_level_ipv6;
    if (3 <= tmp_9) printf(", parent ");
  }
  {
    int tmp_10;
    if (0 < curr_log_level_ipv6) tmp_10 = 0;
    else tmp_10 = curr_log_level_ipv6;
    if (3 <= tmp_10) log_6addr(parent);
  }
  {
    int tmp_11;
    if (0 < curr_log_level_ipv6) tmp_11 = 0;
    else tmp_11 = curr_log_level_ipv6;
    if (3 <= tmp_11) printf(", lifetime %u, num_nodes %u\n",lifetime,
                            num_nodes);
  }
  __retres = child_node;
  return_label: return __retres;
}

void uip_sr_init(void)
{
  num_nodes = 0;
  memb_init(& nodememb);
  list_init(nodelist);
  return;
}

uip_sr_node_t *uip_sr_node_head(void)
{
  uip_sr_node_t *tmp;
  tmp = (uip_sr_node_t *)list_head(nodelist);
  return tmp;
}

uip_sr_node_t *uip_sr_node_next(uip_sr_node_t *item)
{
  uip_sr_node_t *tmp;
  tmp = (uip_sr_node_t *)list_item_next((void *)item);
  return tmp;
}

void uip_sr_periodic(unsigned int seconds)
{
  uip_sr_node_t *l;
  uip_sr_node_t *next;
  l = (uip_sr_node_t *)list_head(nodelist);
  while (l != (uip_sr_node_t *)0) {
    next = (uip_sr_node_t *)list_item_next((void *)l);
    if (l->lifetime == (uint32_t)0) {
      uip_sr_node_t *l2;
      int tmp_2;
      l2 = (uip_sr_node_t *)list_head(nodelist);
      while (l2 != (uip_sr_node_t *)0) {
        if (l2->parent == l) break;
        l2 = (uip_sr_node_t *)list_item_next((void *)l2);
      }
      if (0 < curr_log_level_ipv6) tmp_2 = 0;
      else tmp_2 = curr_log_level_ipv6;
      if (tmp_2 >= 3) {
        uip_ipaddr_t node_addr;
        (*(rpl_lite_driver.get_sr_node_ipaddr))(& node_addr,
                                                (uip_sr_node_t const *)l);
        {
          int tmp;
          if (0 < curr_log_level_ipv6) tmp = 0;
          else tmp = curr_log_level_ipv6;
          if (3 <= tmp) {
            printf("[%-4s: %-10s] ","INFO","IPv6 SR");
            printf("NS: removing expired node ");
          }
        }
        {
          int tmp_0;
          if (0 < curr_log_level_ipv6) tmp_0 = 0;
          else tmp_0 = curr_log_level_ipv6;
          if (3 <= tmp_0) log_6addr((uip_ipaddr_t const *)(& node_addr));
        }
        {
          int tmp_1;
          if (0 < curr_log_level_ipv6) tmp_1 = 0;
          else tmp_1 = curr_log_level_ipv6;
          if (3 <= tmp_1) printf("\n");
        }
      }
      list_remove(nodelist,(void *)l);
      memb_free(& nodememb,(void *)l);
      num_nodes --;
    }
    else 
      if (l->lifetime != 0xFFFFFFFF) 
        if (l->lifetime > seconds) l->lifetime -= seconds;
        else l->lifetime = (unsigned int)0;
    l = next;
  }
  return;
}

void uip_sr_free_all(void)
{
  uip_sr_node_t *l;
  uip_sr_node_t *next;
  l = (uip_sr_node_t *)list_head(nodelist);
  while (l != (uip_sr_node_t *)0) {
    next = (uip_sr_node_t *)list_item_next((void *)l);
    list_remove(nodelist,(void *)l);
    memb_free(& nodememb,(void *)l);
    num_nodes --;
    l = next;
  }
  return;
}

int uip_sr_link_snprint(char *buf_0, int buflen_0, uip_sr_node_t *link_0)
{
  int __retres;
  uip_ipaddr_t child_ipaddr;
  uip_ipaddr_t parent_ipaddr;
  int index_0 = 0;
  (*(rpl_lite_driver.get_sr_node_ipaddr))(& child_ipaddr,
                                          (uip_sr_node_t const *)link_0);
  (*(rpl_lite_driver.get_sr_node_ipaddr))(& parent_ipaddr,
                                          (uip_sr_node_t const *)link_0->parent);
  {
    int tmp_0;
    tmp_0 = uiplib_ipaddr_snprint(buf_0 + index_0,
                                  (unsigned long)(buflen_0 - index_0),
                                  (uip_ipaddr_t const *)(& child_ipaddr));
    index_0 += tmp_0;
  }
  if (index_0 >= buflen_0) {
    __retres = index_0;
    goto return_label;
  }
  if (link_0->parent == (struct uip_sr_node *)0) {
    int tmp_1;
    tmp_1 = snprintf(buf_0 + index_0,(unsigned long)(buflen_0 - index_0),
                     "  (DODAG root)");
    index_0 += tmp_1;
    if (index_0 >= buflen_0) {
      __retres = index_0;
      goto return_label;
    }
  }
  else {
    int tmp_2;
    tmp_2 = snprintf(buf_0 + index_0,(unsigned long)(buflen_0 - index_0),
                     "  to ");
    index_0 += tmp_2;
    if (index_0 >= buflen_0) {
      __retres = index_0;
      goto return_label;
    }
    {
      int tmp_4;
      tmp_4 = uiplib_ipaddr_snprint(buf_0 + index_0,
                                    (unsigned long)(buflen_0 - index_0),
                                    (uip_ipaddr_t const *)(& parent_ipaddr));
      index_0 += tmp_4;
    }
    if (index_0 >= buflen_0) {
      __retres = index_0;
      goto return_label;
    }
  }
  if (link_0->lifetime != 0xFFFFFFFF) {
    int tmp_5;
    tmp_5 = snprintf(buf_0 + index_0,(unsigned long)(buflen_0 - index_0),
                     " (lifetime: %lu seconds)",
                     (unsigned long)link_0->lifetime);
    index_0 += tmp_5;
    if (index_0 >= buflen_0) {
      __retres = index_0;
      goto return_label;
    }
  }
  else {
    int tmp_6;
    tmp_6 = snprintf(buf_0 + index_0,(unsigned long)(buflen_0 - index_0),
                     " (lifetime: infinite)");
    index_0 += tmp_6;
    if (index_0 >= buflen_0) {
      __retres = index_0;
      goto return_label;
    }
  }
  __retres = index_0;
  return_label: return __retres;
}

__inline static unsigned int __bswap_32_59(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_59(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

uip_ds6_netif_t uip_ds6_if;
struct etimer uip_ds6_timer_periodic;
uip_ds6_prefix_t uip_ds6_prefix_list[1 + 2];
struct stimer uip_ds6_timer_ra;
uint8_t uip_ds6_addr_size;
uint8_t uip_ds6_netif_addr_list_offset;
static uip_ipaddr_t loc_fipaddr;
static uip_ds6_addr_t *locaddr;
static uip_ds6_maddr_t *locmaddr;
static uip_ds6_aaddr_t *locaaddr;
static uip_ds6_prefix_t *locprefix;
static uip_ip6addr_t default_prefix =
  {.u16 = {(unsigned short)0,
           (unsigned short)0,
           (unsigned short)0,
           (unsigned short)0,
           (unsigned short)0,
           (unsigned short)0,
           (unsigned short)0,
           (unsigned short)0}};
uip_ip6addr_t const *uip_ds6_default_prefix(void)
{
  uip_ip6addr_t const *__retres;
  __retres = (uip_ip6addr_t const *)(& default_prefix);
  return __retres;
}

void uip_ds6_set_default_prefix(uip_ip6addr_t const *prefix)
{
  default_prefix = *((uip_ip6addr_t *)prefix);
  return;
}

void uip_ds6_init(void)
{
  if ((int)default_prefix.u16[0] == 0) 
    if ((int)default_prefix.u16[1] == 0) 
      if ((int)default_prefix.u16[2] == 0) 
        if ((int)default_prefix.u16[3] == 0) 
          if ((int)default_prefix.u16[4] == 0) 
            if ((int)default_prefix.u16[5] == 0) 
              if ((int)default_prefix.u16[6] == 0) 
                if ((int)default_prefix.u16[7] == 0) {
                  default_prefix.u16[0] = (unsigned short)(((int)((unsigned short)0xfd00) << 8) | (
                                                           (int)((unsigned short)0xfd00) >> 8));
                  default_prefix.u16[1] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                                           (int)((unsigned short)0) >> 8));
                  default_prefix.u16[2] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                                           (int)((unsigned short)0) >> 8));
                  default_prefix.u16[3] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                                           (int)((unsigned short)0) >> 8));
                  default_prefix.u16[4] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                                           (int)((unsigned short)0) >> 8));
                  default_prefix.u16[5] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                                           (int)((unsigned short)0) >> 8));
                  default_prefix.u16[6] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                                           (int)((unsigned short)0) >> 8));
                  default_prefix.u16[7] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                                           (int)((unsigned short)0) >> 8));
                }
  uip_ds6_neighbors_init();
  uip_ds6_route_init();
  {
    int tmp;
    if (0 < curr_log_level_ipv6) tmp = 0; else tmp = curr_log_level_ipv6;
    if (3 <= tmp) {
      printf("[%-4s: %-10s] ","INFO","IPv6 DS");
      printf("Init: %u neighbors\n",300);
    }
  }
  {
    int tmp_0;
    if (0 < curr_log_level_ipv6) tmp_0 = 0; else tmp_0 = curr_log_level_ipv6;
    if (3 <= tmp_0) {
      printf("[%-4s: %-10s] ","INFO","IPv6 DS");
      printf("%u default routers\n",0 + 2);
    }
  }
  {
    int tmp_1;
    if (0 < curr_log_level_ipv6) tmp_1 = 0; else tmp_1 = curr_log_level_ipv6;
    if (3 <= tmp_1) {
      printf("[%-4s: %-10s] ","INFO","IPv6 DS");
      printf("%u prefixes\n",1 + 2);
    }
  }
  {
    int tmp_2;
    if (0 < curr_log_level_ipv6) tmp_2 = 0; else tmp_2 = curr_log_level_ipv6;
    if (3 <= tmp_2) {
      printf("[%-4s: %-10s] ","INFO","IPv6 DS");
      printf("%u routes\n",0);
    }
  }
  {
    int tmp_3;
    if (0 < curr_log_level_ipv6) tmp_3 = 0; else tmp_3 = curr_log_level_ipv6;
    if (3 <= tmp_3) {
      printf("[%-4s: %-10s] ","INFO","IPv6 DS");
      printf("%u unicast addresses\n",1 + 2);
    }
  }
  {
    int tmp_4;
    if (0 < curr_log_level_ipv6) tmp_4 = 0; else tmp_4 = curr_log_level_ipv6;
    if (3 <= tmp_4) {
      printf("[%-4s: %-10s] ","INFO","IPv6 DS");
      printf("%u multicast addresses\n",((2 + 1) + 2) + 0);
    }
  }
  {
    int tmp_5;
    if (0 < curr_log_level_ipv6) tmp_5 = 0; else tmp_5 = curr_log_level_ipv6;
    if (3 <= tmp_5) {
      printf("[%-4s: %-10s] ","INFO","IPv6 DS");
      printf("%u anycast addresses\n",((1 + 2) - 1) + 0);
    }
  }
  memset((void *)(uip_ds6_prefix_list),0,sizeof(uip_ds6_prefix_list));
  memset((void *)(& uip_ds6_if),0,sizeof(uip_ds6_if));
  uip_ds6_addr_size = (unsigned char)sizeof(struct uip_ds6_addr);
  uip_ds6_netif_addr_list_offset = (unsigned char)((unsigned long)(& ((struct uip_ds6_netif *)0)->addr_list));
  uip_ds6_if.link_mtu = (unsigned int)1280;
  uip_ds6_if.cur_hop_limit = (unsigned char)64;
  uip_ds6_if.base_reachable_time = (unsigned int)60000;
  uip_ds6_if.reachable_time = uip_ds6_compute_reachable_time();
  uip_ds6_if.retrans_timer = (unsigned int)1000;
  uip_ds6_if.maxdadns = (unsigned char)0;
  loc_fipaddr.u16[0] = (unsigned short)(((int)((unsigned short)0xfe80) << 8) | (
                                        (int)((unsigned short)0xfe80) >> 8));
  loc_fipaddr.u16[1] = (unsigned short)0;
  loc_fipaddr.u16[2] = (unsigned short)0;
  loc_fipaddr.u16[3] = (unsigned short)0;
  uip_ds6_prefix_add(& loc_fipaddr,(unsigned char)64,(unsigned char)0,
                     (unsigned char)0,(unsigned long)0,(unsigned long)0);
  uip_ds6_set_addr_iid(& loc_fipaddr,& uip_lladdr);
  uip_ds6_addr_add(& loc_fipaddr,(unsigned long)0,(unsigned char)1);
  loc_fipaddr.u16[0] = (unsigned short)(((int)((unsigned short)0xff02) << 8) | (
                                        (int)((unsigned short)0xff02) >> 8));
  loc_fipaddr.u16[1] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                        (int)((unsigned short)0) >> 8));
  loc_fipaddr.u16[2] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                        (int)((unsigned short)0) >> 8));
  loc_fipaddr.u16[3] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                        (int)((unsigned short)0) >> 8));
  loc_fipaddr.u16[4] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                        (int)((unsigned short)0) >> 8));
  loc_fipaddr.u16[5] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                        (int)((unsigned short)0) >> 8));
  loc_fipaddr.u16[6] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                        (int)((unsigned short)0) >> 8));
  loc_fipaddr.u16[7] = (unsigned short)(((int)((unsigned short)0x0001) << 8) | (
                                        (int)((unsigned short)0x0001) >> 8));
  uip_ds6_maddr_add((uip_ipaddr_t const *)(& loc_fipaddr));
  loc_fipaddr.u16[0] = (unsigned short)(((int)((unsigned short)0xff02) << 8) | (
                                        (int)((unsigned short)0xff02) >> 8));
  loc_fipaddr.u16[1] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                        (int)((unsigned short)0) >> 8));
  loc_fipaddr.u16[2] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                        (int)((unsigned short)0) >> 8));
  loc_fipaddr.u16[3] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                        (int)((unsigned short)0) >> 8));
  loc_fipaddr.u16[4] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                        (int)((unsigned short)0) >> 8));
  loc_fipaddr.u16[5] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                        (int)((unsigned short)0) >> 8));
  loc_fipaddr.u16[6] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                        (int)((unsigned short)0) >> 8));
  loc_fipaddr.u16[7] = (unsigned short)(((int)((unsigned short)0x0002) << 8) | (
                                        (int)((unsigned short)0x0002) >> 8));
  uip_ds6_maddr_add((uip_ipaddr_t const *)(& loc_fipaddr));
  etimer_set(& uip_ds6_timer_periodic,(unsigned long)(1000 / 10));
  return;
}

void uip_ds6_periodic(void)
{
  locaddr = uip_ds6_if.addr_list;
  while (locaddr < & uip_ds6_if.addr_list[1] + 2) {
    if (locaddr->isused) 
      if (! locaddr->isinfinite) {
        int tmp;
        tmp = stimer_expired(& locaddr->vlifetime);
        if (tmp) uip_ds6_addr_rm(locaddr);
      }
    locaddr ++;
  }
  uip_ds6_defrt_periodic();
  etimer_reset(& uip_ds6_timer_periodic);
  return;
}

uint8_t uip_ds6_list_loop(uip_ds6_element_t *list, uint8_t size,
                          uint16_t elementsize, uip_ipaddr_t *ipaddr,
                          uint8_t ipaddrlen, uip_ds6_element_t **out_element)
{
  uint8_t __retres;
  uip_ds6_element_t *element;
  int tmp_0;
  if (list == (uip_ds6_element_t *)0) goto _LOR;
  else 
    if (ipaddr == (uip_ipaddr_t *)0) goto _LOR;
    else 
      if (out_element == (uip_ds6_element_t **)0) {
        _LOR: {
                __retres = (unsigned char)2;
                goto return_label;
              }
      }
  *out_element = (uip_ds6_element_t *)0;
  element = list;
  while (element < (uip_ds6_element_t *)((uint8_t *)list + (int)size * (int)elementsize)) {
    if (element->isused) {
      int tmp;
      tmp = memcmp((void const *)(& element->ipaddr),(void const *)ipaddr,
                   (unsigned long)((int)ipaddrlen >> 3));
      if (tmp == 0) {
        *out_element = element;
        __retres = (unsigned char)0;
        goto return_label;
      }
    }
    else *out_element = element;
    element = (uip_ds6_element_t *)((uint8_t *)element + (int)elementsize);
  }
  if (*out_element != (uip_ds6_element_t *)0) tmp_0 = 1; else tmp_0 = 2;
  __retres = (unsigned char)tmp_0;
  return_label: return __retres;
}

uip_ds6_prefix_t *uip_ds6_prefix_add(uip_ipaddr_t *ipaddr, uint8_t ipaddrlen,
                                     uint8_t advertise, uint8_t flags,
                                     unsigned long vtime, unsigned long ptime)
{
  uip_ds6_prefix_t *__retres;
  uint8_t tmp_3;
  tmp_3 = uip_ds6_list_loop((uip_ds6_element_t *)(uip_ds6_prefix_list),
                            (unsigned char)(1 + 2),
                            (unsigned short)sizeof(uip_ds6_prefix_t),ipaddr,
                            ipaddrlen,(uip_ds6_element_t **)(& locprefix));
  if ((int)tmp_3 == 1) {
    locprefix->isused = (unsigned char)1;
    locprefix->ipaddr = *ipaddr;
    locprefix->length = ipaddrlen;
    locprefix->advertise = advertise;
    locprefix->l_a_reserved = flags;
    locprefix->vlifetime = (unsigned int)vtime;
    locprefix->plifetime = (unsigned int)ptime;
    {
      int tmp;
      if (0 < curr_log_level_ipv6) tmp = 0; else tmp = curr_log_level_ipv6;
      if (3 <= tmp) {
        printf("[%-4s: %-10s] ","INFO","IPv6 DS");
        printf("Adding prefix ");
      }
    }
    {
      int tmp_0;
      if (0 < curr_log_level_ipv6) tmp_0 = 0;
      else tmp_0 = curr_log_level_ipv6;
      if (3 <= tmp_0) log_6addr((uip_ipaddr_t const *)(& locprefix->ipaddr));
    }
    {
      int tmp_1;
      if (0 < curr_log_level_ipv6) tmp_1 = 0;
      else tmp_1 = curr_log_level_ipv6;
      if (3 <= tmp_1) printf("length %u, flags %x, Valid lifetime %lx, Preffered lifetime %lx\n",
                             (int)ipaddrlen,(int)flags,vtime,ptime);
    }
    __retres = locprefix;
    goto return_label;
  }
  else {
    int tmp_2;
    if (0 < curr_log_level_ipv6) tmp_2 = 0; else tmp_2 = curr_log_level_ipv6;
    if (3 <= tmp_2) {
      printf("[%-4s: %-10s] ","INFO","IPv6 DS");
      printf("No more space in Prefix list\n");
    }
  }
  __retres = (uip_ds6_prefix_t *)0;
  return_label: return __retres;
}

void uip_ds6_prefix_rm(uip_ds6_prefix_t *prefix)
{
  if (prefix != (uip_ds6_prefix_t *)0) prefix->isused = (unsigned char)0;
  return;
}

uip_ds6_prefix_t *uip_ds6_prefix_lookup(uip_ipaddr_t *ipaddr,
                                        uint8_t ipaddrlen)
{
  uip_ds6_prefix_t *__retres;
  uint8_t tmp;
  tmp = uip_ds6_list_loop((uip_ds6_element_t *)(uip_ds6_prefix_list),
                          (unsigned char)(1 + 2),
                          (unsigned short)sizeof(uip_ds6_prefix_t),ipaddr,
                          ipaddrlen,(uip_ds6_element_t **)(& locprefix));
  if ((int)tmp == 0) {
    __retres = locprefix;
    goto return_label;
  }
  __retres = (uip_ds6_prefix_t *)0;
  return_label: return __retres;
}

uint8_t uip_ds6_is_addr_onlink(uip_ipaddr_t *ipaddr)
{
  uint8_t __retres;
  locprefix = uip_ds6_prefix_list;
  while (locprefix < & uip_ds6_prefix_list[1] + 2) {
    if (locprefix->isused) {
      int tmp;
      tmp = memcmp((void const *)(& locprefix->ipaddr),(void const *)ipaddr,
                   (unsigned long)((int)locprefix->length >> 3));
      if (tmp == 0) {
        __retres = (unsigned char)1;
        goto return_label;
      }
    }
    locprefix ++;
  }
  __retres = (unsigned char)0;
  return_label: return __retres;
}

uip_ds6_addr_t *uip_ds6_addr_add(uip_ipaddr_t *ipaddr,
                                 unsigned long vlifetime, uint8_t type)
{
  uip_ds6_addr_t *__retres;
  uint8_t tmp;
  tmp = uip_ds6_list_loop((uip_ds6_element_t *)(uip_ds6_if.addr_list),
                          (unsigned char)(1 + 2),
                          (unsigned short)sizeof(uip_ds6_addr_t),ipaddr,
                          (unsigned char)128,
                          (uip_ds6_element_t **)(& locaddr));
  if ((int)tmp == 1) {
    locaddr->isused = (unsigned char)1;
    locaddr->ipaddr = *ipaddr;
    locaddr->type = type;
    if (vlifetime == (unsigned long)0) locaddr->isinfinite = (unsigned char)1;
    else {
      locaddr->isinfinite = (unsigned char)0;
      stimer_set(& locaddr->vlifetime,vlifetime);
    }
    locaddr->state = (unsigned char)1;
    loc_fipaddr.u8[0] = (unsigned char)0xFF;
    loc_fipaddr.u8[1] = (unsigned char)0x02;
    loc_fipaddr.u16[1] = (unsigned short)0;
    loc_fipaddr.u16[2] = (unsigned short)0;
    loc_fipaddr.u16[3] = (unsigned short)0;
    loc_fipaddr.u16[4] = (unsigned short)0;
    loc_fipaddr.u8[10] = (unsigned char)0;
    loc_fipaddr.u8[11] = (unsigned char)0x01;
    loc_fipaddr.u8[12] = (unsigned char)0xFF;
    loc_fipaddr.u8[13] = ipaddr->u8[13];
    loc_fipaddr.u16[7] = ipaddr->u16[7];
    uip_ds6_maddr_add((uip_ipaddr_t const *)(& loc_fipaddr));
    __retres = locaddr;
    goto return_label;
  }
  __retres = (uip_ds6_addr_t *)0;
  return_label: return __retres;
}

void uip_ds6_addr_rm(uip_ds6_addr_t *addr_0)
{
  if (addr_0 != (uip_ds6_addr_t *)0) {
    loc_fipaddr.u8[0] = (unsigned char)0xFF;
    loc_fipaddr.u8[1] = (unsigned char)0x02;
    loc_fipaddr.u16[1] = (unsigned short)0;
    loc_fipaddr.u16[2] = (unsigned short)0;
    loc_fipaddr.u16[3] = (unsigned short)0;
    loc_fipaddr.u16[4] = (unsigned short)0;
    loc_fipaddr.u8[10] = (unsigned char)0;
    loc_fipaddr.u8[11] = (unsigned char)0x01;
    loc_fipaddr.u8[12] = (unsigned char)0xFF;
    loc_fipaddr.u8[13] = addr_0->ipaddr.u8[13];
    loc_fipaddr.u16[7] = addr_0->ipaddr.u16[7];
    locmaddr = uip_ds6_maddr_lookup((uip_ipaddr_t const *)(& loc_fipaddr));
    if (locmaddr != (uip_ds6_maddr_t *)0) uip_ds6_maddr_rm(locmaddr);
    addr_0->isused = (unsigned char)0;
  }
  return;
}

uip_ds6_addr_t *uip_ds6_addr_lookup(uip_ipaddr_t *ipaddr)
{
  uip_ds6_addr_t *__retres;
  uint8_t tmp;
  tmp = uip_ds6_list_loop((uip_ds6_element_t *)(uip_ds6_if.addr_list),
                          (unsigned char)(1 + 2),
                          (unsigned short)sizeof(uip_ds6_addr_t),ipaddr,
                          (unsigned char)128,
                          (uip_ds6_element_t **)(& locaddr));
  if ((int)tmp == 0) {
    __retres = locaddr;
    goto return_label;
  }
  __retres = (uip_ds6_addr_t *)0;
  return_label: return __retres;
}

uip_ds6_addr_t *uip_ds6_get_link_local(int8_t state)
{
  uip_ds6_addr_t *__retres;
  locaddr = uip_ds6_if.addr_list;
  while (locaddr < & uip_ds6_if.addr_list[1] + 2) {
    if (locaddr->isused) 
      if ((int)state == -1) goto _LOR;
      else 
        if ((int)locaddr->state == (int)state) {
          _LOR: ;
          if ((int)locaddr->ipaddr.u8[0] == 0xfe) 
            if ((int)locaddr->ipaddr.u8[1] == 0x80) {
              __retres = locaddr;
              goto return_label;
            }
        }
    locaddr ++;
  }
  __retres = (uip_ds6_addr_t *)0;
  return_label: return __retres;
}

uip_ds6_addr_t *uip_ds6_get_global(int8_t state)
{
  uip_ds6_addr_t *__retres;
  locaddr = uip_ds6_if.addr_list;
  while (locaddr < & uip_ds6_if.addr_list[1] + 2) {
    if (locaddr->isused) 
      if ((int)state == -1) goto _LOR;
      else 
        if ((int)locaddr->state == (int)state) {
          _LOR: ;
          if ((int)locaddr->ipaddr.u8[0] == 0xfe) {
            if (! ((int)locaddr->ipaddr.u8[1] == 0x80)) goto _LAND;
          }
          else {
            _LAND: {
                     __retres = locaddr;
                     goto return_label;
                   }
          }
        }
    locaddr ++;
  }
  __retres = (uip_ds6_addr_t *)0;
  return_label: return __retres;
}

uip_ds6_maddr_t *uip_ds6_maddr_add(uip_ipaddr_t const *ipaddr)
{
  uip_ds6_maddr_t *__retres;
  uint8_t tmp;
  tmp = uip_ds6_list_loop((uip_ds6_element_t *)(uip_ds6_if.maddr_list),
                          (unsigned char)(((2 + 1) + 2) + 0),
                          (unsigned short)sizeof(uip_ds6_maddr_t),
                          (uip_ipaddr_t *)ipaddr,(unsigned char)128,
                          (uip_ds6_element_t **)(& locmaddr));
  if ((int)tmp == 1) {
    locmaddr->isused = (unsigned char)1;
    locmaddr->ipaddr = *ipaddr;
    __retres = locmaddr;
    goto return_label;
  }
  __retres = (uip_ds6_maddr_t *)0;
  return_label: return __retres;
}

void uip_ds6_maddr_rm(uip_ds6_maddr_t *maddr)
{
  if (maddr != (uip_ds6_maddr_t *)0) maddr->isused = (unsigned char)0;
  return;
}

uip_ds6_maddr_t *uip_ds6_maddr_lookup(uip_ipaddr_t const *ipaddr)
{
  uip_ds6_maddr_t *__retres;
  uint8_t tmp;
  tmp = uip_ds6_list_loop((uip_ds6_element_t *)(uip_ds6_if.maddr_list),
                          (unsigned char)(((2 + 1) + 2) + 0),
                          (unsigned short)sizeof(uip_ds6_maddr_t),
                          (uip_ipaddr_t *)ipaddr,(unsigned char)128,
                          (uip_ds6_element_t **)(& locmaddr));
  if ((int)tmp == 0) {
    __retres = locmaddr;
    goto return_label;
  }
  __retres = (uip_ds6_maddr_t *)0;
  return_label: return __retres;
}

uip_ds6_aaddr_t *uip_ds6_aaddr_add(uip_ipaddr_t *ipaddr)
{
  uip_ds6_aaddr_t *__retres;
  uint8_t tmp;
  tmp = uip_ds6_list_loop((uip_ds6_element_t *)(uip_ds6_if.aaddr_list),
                          (unsigned char)(((1 + 2) - 1) + 0),
                          (unsigned short)sizeof(uip_ds6_aaddr_t),ipaddr,
                          (unsigned char)128,
                          (uip_ds6_element_t **)(& locaaddr));
  if ((int)tmp == 1) {
    locaaddr->isused = (unsigned char)1;
    locaaddr->ipaddr = *ipaddr;
    __retres = locaaddr;
    goto return_label;
  }
  __retres = (uip_ds6_aaddr_t *)0;
  return_label: return __retres;
}

void uip_ds6_aaddr_rm(uip_ds6_aaddr_t *aaddr)
{
  if (aaddr != (uip_ds6_aaddr_t *)0) aaddr->isused = (unsigned char)0;
  return;
}

uip_ds6_aaddr_t *uip_ds6_aaddr_lookup(uip_ipaddr_t *ipaddr)
{
  uip_ds6_aaddr_t *__retres;
  uint8_t tmp;
  tmp = uip_ds6_list_loop((uip_ds6_element_t *)(uip_ds6_if.aaddr_list),
                          (unsigned char)(((1 + 2) - 1) + 0),
                          (unsigned short)sizeof(uip_ds6_aaddr_t),ipaddr,
                          (unsigned char)128,
                          (uip_ds6_element_t **)(& locaaddr));
  if ((int)tmp == 0) {
    __retres = locaaddr;
    goto return_label;
  }
  __retres = (uip_ds6_aaddr_t *)0;
  return_label: return __retres;
}

void uip_ds6_select_src(uip_ipaddr_t *src, uip_ipaddr_t *dst)
{
  uint8_t best = (unsigned char)0;
  uint8_t n = (unsigned char)0;
  uip_ds6_addr_t *matchaddr = (uip_ds6_addr_t *)0;
  if ((int)dst->u8[0] == 0xfe) {
    if ((int)dst->u8[1] == 0x80) _LAND_0:
                                 matchaddr = uip_ds6_get_link_local((char)1);
    else goto _LAND_1;
  }
  else 
    _LAND_1:
    if (! ((int)dst->u8[0] == 0xFF)) {
      locaddr = uip_ds6_if.addr_list;
      while (locaddr < & uip_ds6_if.addr_list[1] + 2) {
        if (locaddr->isused) 
          if ((int)locaddr->state == 1) 
            if ((int)locaddr->ipaddr.u8[0] == 0xfe) {
              if (! ((int)locaddr->ipaddr.u8[1] == 0x80)) goto _LAND;
            }
            else {
              _LAND:
              {
                n = get_match_length(dst,& locaddr->ipaddr);
                if ((int)n >= (int)best) {
                  best = n;
                  matchaddr = locaddr;
                }
              }
            }
        locaddr ++;
      }
    }
    else goto _LAND_0;
  if (matchaddr == (uip_ds6_addr_t *)0) {
    src->u16[0] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                   (int)((unsigned short)0) >> 8));
    src->u16[1] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                   (int)((unsigned short)0) >> 8));
    src->u16[2] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                   (int)((unsigned short)0) >> 8));
    src->u16[3] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                   (int)((unsigned short)0) >> 8));
    src->u16[4] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                   (int)((unsigned short)0) >> 8));
    src->u16[5] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                   (int)((unsigned short)0) >> 8));
    src->u16[6] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                   (int)((unsigned short)0) >> 8));
    src->u16[7] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                   (int)((unsigned short)0) >> 8));
  }
  else *src = matchaddr->ipaddr;
  return;
}

void uip_ds6_set_addr_iid(uip_ipaddr_t *ipaddr, uip_lladdr_t *lladdr)
{
  memcpy((void *)(& ipaddr->u8[8]),(void const *)lladdr,(unsigned long)8);
  ipaddr->u8[8] = (unsigned char)((int)ipaddr->u8[8] ^ 0x02);
  return;
}

void uip_ds6_set_lladdr_from_iid(uip_lladdr_t *lladdr,
                                 uip_ipaddr_t const *ipaddr)
{
  memcpy((void *)lladdr,(void const *)(& ipaddr->u8[8]),(unsigned long)8);
  lladdr->addr[0] = (unsigned char)((int)lladdr->addr[0] ^ 0x02);
  return;
}

uint8_t get_match_length(uip_ipaddr_t *src, uip_ipaddr_t *dst)
{
  uint8_t j;
  uint8_t k;
  uint8_t x_or;
  uint8_t len = (unsigned char)0;
  j = (unsigned char)0;
  while ((int)j < 16) {
    if ((int)src->u8[j] == (int)dst->u8[j]) len = (unsigned char)((int)len + 8);
    else {
      x_or = (unsigned char)((int)src->u8[j] ^ (int)dst->u8[j]);
      k = (unsigned char)0;
      while ((int)k < 8) {
        if (((int)x_or & 0x80) == 0) {
          len = (uint8_t)((int)len + 1);
          x_or = (unsigned char)((int)x_or << 1);
        }
        else break;
        k = (uint8_t)((int)k + 1);
      }
      break;
    }
    j = (uint8_t)((int)j + 1);
  }
  return len;
}

uint32_t uip_ds6_compute_reachable_time(void)
{
  uint32_t __retres;
  unsigned short tmp;
  unsigned short tmp_0;
  tmp = random_rand();
  tmp_0 = random_rand();
  ;
  __retres = uip_ds6_if.base_reachable_time / (uint32_t)2 + (unsigned int)(
                                                            (int)((unsigned short)(
                                                            (int)tmp << 8)) + (int)tmp_0) % (
                                                            (uip_ds6_if.base_reachable_time + 
                                                             uip_ds6_if.base_reachable_time / (uint32_t)2) - 
                                                            uip_ds6_if.base_reachable_time / (uint32_t)2);
  return __retres;
}

__inline static unsigned int __bswap_32_60(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_60(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static char packets_memb_memb_count[2];
static struct uip_packetqueue_packet packets_memb_memb_mem[2];
static struct memb packets_memb =
  {.size = (unsigned short)sizeof(struct uip_packetqueue_packet),
   .num = (unsigned short)2,
   .count = packets_memb_memb_count,
   .mem = (void *)(packets_memb_memb_mem)};
static void packet_timedout(void *ptr)
{
  struct uip_packetqueue_handle *h = (struct uip_packetqueue_handle *)ptr;
  memb_free(& packets_memb,(void *)h->packet);
  h->packet = (struct uip_packetqueue_packet *)0;
  return;
}

void uip_packetqueue_new(struct uip_packetqueue_handle *handle)
{
  handle->packet = (struct uip_packetqueue_packet *)0;
  return;
}

struct uip_packetqueue_packet *uip_packetqueue_alloc(struct uip_packetqueue_handle *handle,
                                                     clock_time_t lifetime)
{
  struct uip_packetqueue_packet *__retres;
  if (handle->packet != (struct uip_packetqueue_packet *)0) {
    __retres = (struct uip_packetqueue_packet *)0;
    goto return_label;
  }
  handle->packet = (struct uip_packetqueue_packet *)memb_alloc(& packets_memb);
  if (handle->packet != (struct uip_packetqueue_packet *)0) ctimer_set
                                                            (& (handle->packet)->lifetimer,
                                                             lifetime,
                                                             & packet_timedout,
                                                             (void *)handle);
  __retres = handle->packet;
  return_label: return __retres;
}

void uip_packetqueue_free(struct uip_packetqueue_handle *handle)
{
  if (handle->packet != (struct uip_packetqueue_packet *)0) {
    ctimer_stop(& (handle->packet)->lifetimer);
    memb_free(& packets_memb,(void *)handle->packet);
    handle->packet = (struct uip_packetqueue_packet *)0;
  }
  return;
}

uint8_t *uip_packetqueue_buf(struct uip_packetqueue_handle *h)
{
  uint8_t *tmp;
  if (h->packet != (struct uip_packetqueue_packet *)0) tmp = (h->packet)->queue_buf;
  else tmp = (uint8_t *)0;
  return tmp;
}

uint16_t uip_packetqueue_buflen(struct uip_packetqueue_handle *h)
{
  uint16_t __retres;
  int tmp;
  if (h->packet != (struct uip_packetqueue_packet *)0) tmp = (int)(h->packet)->queue_buf_len;
  else tmp = 0;
  __retres = (unsigned short)tmp;
  return __retres;
}

void uip_packetqueue_set_buflen(struct uip_packetqueue_handle *h,
                                uint16_t len)
{
  if (h->packet != (struct uip_packetqueue_packet *)0) (h->packet)->queue_buf_len = len;
  return;
}

__inline static unsigned int __bswap_32_61(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_61(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static uip_ip6addr_t ip64_prefix =
  {.u8 = {(unsigned char)0,
          (unsigned char)0,
          (unsigned char)0,
          (unsigned char)0,
          (unsigned char)0,
          (unsigned char)0,
          (unsigned char)0,
          (unsigned char)0,
          (unsigned char)0,
          (unsigned char)0,
          (unsigned char)0xff,
          (unsigned char)0xff,
          (unsigned char)0,
          (unsigned char)0,
          (unsigned char)0,
          (unsigned char)0}};
static uint8_t ip64_prefix_len = (unsigned char)96;
void ip64_addr_copy4(uip_ip4addr_t *dest, uip_ip4addr_t const *src)
{
  memcpy((void *)dest,(void const *)src,sizeof(uip_ip4addr_t));
  return;
}

void ip64_addr_copy6(uip_ip6addr_t *dest, uip_ip6addr_t const *src)
{
  memcpy((void *)dest,(void const *)src,sizeof(uip_ip6addr_t));
  return;
}

int ip64_addr_4to6(uip_ip4addr_t const *ipv4addr, uip_ip6addr_t *ipv6addr)
{
  int __retres;
  *ipv6addr = ip64_prefix;
  ipv6addr->u8[12] = ipv4addr->u8[0];
  ipv6addr->u8[13] = ipv4addr->u8[1];
  ipv6addr->u8[14] = ipv4addr->u8[2];
  ipv6addr->u8[15] = ipv4addr->u8[3];
  __retres = 1;
  return __retres;
}

int ip64_addr_6to4(uip_ip6addr_t const *ipv6addr, uip_ip4addr_t *ipv4addr)
{
  int __retres;
  int tmp;
  tmp = ip64_addr_is_ip64(ipv6addr);
  if (tmp) {
    ipv4addr->u8[0] = ipv6addr->u8[12];
    ipv4addr->u8[1] = ipv6addr->u8[13];
    ipv4addr->u8[2] = ipv6addr->u8[14];
    ipv4addr->u8[3] = ipv6addr->u8[15];
    __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int ip64_addr_is_ip64(uip_ip6addr_t const *ipv6addr)
{
  int __retres;
  int tmp;
  tmp = memcmp((void const *)ipv6addr,(void const *)(& ip64_prefix),
               (unsigned long)((int)ip64_prefix_len >> 3));
  __retres = tmp == 0;
  return __retres;
}

void ip64_addr_set_prefix(uip_ip6addr_t const *prefix, uint8_t prefix_len)
{
  ip64_prefix = *prefix;
  ip64_prefix_len = prefix_len;
  return;
}

__inline static unsigned int __bswap_32_62(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_62(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

uint16_t uip_slen;

void uip_udp_packet_send(struct uip_udp_conn *c, void const *data, int len)
{
  if (data != (void const *)0) 
    if (len <= 1280 - (8 + 40)) {
      uip_udp_conn = c;
      uip_slen = (unsigned short)len;
      memmove((void *)(& uip_aligned_buf.u8[8 + 40]),data,(unsigned long)len);
      uip_process((unsigned char)4);
      tcpip_ipv6_output();
    }
  uip_slen = (unsigned short)0;
  return;
}

void uip_udp_packet_sendto(struct uip_udp_conn *c, void const *data, int len,
                           uip_ipaddr_t const *toaddr, uint16_t toport)
{
  uip_ipaddr_t curaddr;
  uint16_t curport;
  if (toaddr != (uip_ipaddr_t const *)0) {
    curaddr = c->ripaddr;
    curport = c->rport;
    c->ripaddr = *toaddr;
    c->rport = toport;
    uip_udp_packet_send(c,data,len);
    c->ripaddr = curaddr;
    c->rport = curport;
  }
  return;
}

__inline static unsigned int __bswap_32_63(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_63(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static void *defaultrouterlist_list = (void *)0;
static list_t defaultrouterlist = & defaultrouterlist_list;
static char defaultroutermemb_memb_count[0 + 2];
static uip_ds6_defrt_t defaultroutermemb_memb_mem[0 + 2];
static struct memb defaultroutermemb =
  {.size = (unsigned short)sizeof(uip_ds6_defrt_t),
   .num = (unsigned short)(0 + 2),
   .count = defaultroutermemb_memb_count,
   .mem = (void *)(defaultroutermemb_memb_mem)};
static void assert_nbr_routes_list_sane(void)
{
  uip_ds6_route_t *r;
  int count;
  r = uip_ds6_route_head();
  count = 0;
  while (1) {
    if (r != (uip_ds6_route_t *)0) {
      if (! (count < 0 * 2)) break;
    }
    else break;
    r = uip_ds6_route_next(r);
    count ++;
  }
  if (count > 0) printf("uip-ds6-route.c: assert_nbr_routes_list_sane route list is in infinite loop\n");
  return;
}

void uip_ds6_route_init(void)
{
  memb_init(& defaultroutermemb);
  list_init(defaultrouterlist);
  return;
}

uip_ipaddr_t const *uip_ds6_route_nexthop(uip_ds6_route_t *route)
{
  uip_ipaddr_t const *__retres;
  __retres = (uip_ipaddr_t const *)0;
  return __retres;
}

uip_ds6_route_t *uip_ds6_route_head(void)
{
  uip_ds6_route_t *__retres;
  __retres = (uip_ds6_route_t *)0;
  return __retres;
}

uip_ds6_route_t *uip_ds6_route_next(uip_ds6_route_t *r)
{
  uip_ds6_route_t *__retres;
  __retres = (uip_ds6_route_t *)0;
  return __retres;
}

int uip_ds6_route_is_nexthop(uip_ipaddr_t const *ipaddr)
{
  int __retres;
  __retres = 0;
  return __retres;
}

int uip_ds6_route_num_routes(void)
{
  int __retres;
  __retres = 0;
  return __retres;
}

uip_ds6_route_t *uip_ds6_route_lookup(uip_ipaddr_t const *addr_0)
{
  uip_ds6_route_t *__retres;
  __retres = (uip_ds6_route_t *)0;
  return __retres;
}

uip_ds6_route_t *uip_ds6_route_add(uip_ipaddr_t const *ipaddr,
                                   uint8_t length,
                                   uip_ipaddr_t const *nexthop)
{
  uip_ds6_route_t *__retres;
  __retres = (uip_ds6_route_t *)0;
  return __retres;
}

void uip_ds6_route_rm(uip_ds6_route_t *route)
{
  return;
}

void uip_ds6_route_rm_by_nexthop(uip_ipaddr_t const *nexthop)
{
  return;
}

uip_ds6_defrt_t *uip_ds6_defrt_head(void)
{
  uip_ds6_defrt_t *tmp;
  tmp = (uip_ds6_defrt_t *)list_head(defaultrouterlist);
  return tmp;
}

uip_ds6_defrt_t *uip_ds6_defrt_add(uip_ipaddr_t const *ipaddr,
                                   unsigned long interval)
{
  uip_ds6_defrt_t *__retres;
  uip_ds6_defrt_t *d;
  int tmp;
  int tmp_7;
  if (0 < curr_log_level_ipv6) tmp = 0; else tmp = curr_log_level_ipv6;
  if (tmp >= 4) assert_nbr_routes_list_sane();
  if (ipaddr == (uip_ipaddr_t const *)0) {
    __retres = (uip_ds6_defrt_t *)0;
    goto return_label;
  }
  {
    int tmp_0;
    if (0 < curr_log_level_ipv6) tmp_0 = 0; else tmp_0 = curr_log_level_ipv6;
    if (3 <= tmp_0) {
      printf("[%-4s: %-10s] ","INFO","IPv6 Route");
      printf("Add default\n");
    }
  }
  d = uip_ds6_defrt_lookup(ipaddr);
  if (d == (uip_ds6_defrt_t *)0) {
    d = (uip_ds6_defrt_t *)memb_alloc(& defaultroutermemb);
    if (d == (uip_ds6_defrt_t *)0) {
      {
        int tmp_1;
        if (0 < curr_log_level_ipv6) tmp_1 = 0;
        else tmp_1 = curr_log_level_ipv6;
        if (1 <= tmp_1) {
          printf("[%-4s: %-10s] ","ERR","IPv6 Route");
          printf("Add default: could not add default route to ");
        }
      }
      {
        int tmp_2;
        if (0 < curr_log_level_ipv6) tmp_2 = 0;
        else tmp_2 = curr_log_level_ipv6;
        if (1 <= tmp_2) log_6addr(ipaddr);
      }
      {
        int tmp_3;
        if (0 < curr_log_level_ipv6) tmp_3 = 0;
        else tmp_3 = curr_log_level_ipv6;
        if (1 <= tmp_3) printf(", out of memory\n");
      }
      __retres = (uip_ds6_defrt_t *)0;
      goto return_label;
    }
    else {
      {
        int tmp_4;
        if (0 < curr_log_level_ipv6) tmp_4 = 0;
        else tmp_4 = curr_log_level_ipv6;
        if (3 <= tmp_4) {
          printf("[%-4s: %-10s] ","INFO","IPv6 Route");
          printf("Add default: adding default route to ");
        }
      }
      {
        int tmp_5;
        if (0 < curr_log_level_ipv6) tmp_5 = 0;
        else tmp_5 = curr_log_level_ipv6;
        if (3 <= tmp_5) log_6addr(ipaddr);
      }
      {
        int tmp_6;
        if (0 < curr_log_level_ipv6) tmp_6 = 0;
        else tmp_6 = curr_log_level_ipv6;
        if (3 <= tmp_6) printf("\n");
      }
    }
    list_push(defaultrouterlist,(void *)d);
  }
  d->ipaddr = *ipaddr;
  if (interval != (unsigned long)0) {
    stimer_set(& d->lifetime,interval);
    d->isinfinite = (unsigned char)0;
  }
  else d->isinfinite = (unsigned char)1;
  if (0 < curr_log_level_ipv6) tmp_7 = 0; else tmp_7 = curr_log_level_ipv6;
  if (tmp_7 >= 4) assert_nbr_routes_list_sane();
  __retres = d;
  return_label: return __retres;
}

void uip_ds6_defrt_rm(uip_ds6_defrt_t *defrt)
{
  uip_ds6_defrt_t *d;
  int tmp;
  int tmp_1;
  if (0 < curr_log_level_ipv6) tmp = 0; else tmp = curr_log_level_ipv6;
  if (tmp >= 4) assert_nbr_routes_list_sane();
  d = (uip_ds6_defrt_t *)list_head(defaultrouterlist);
  while (d != (uip_ds6_defrt_t *)0) {
    if (d == defrt) {
      {
        int tmp_0;
        if (0 < curr_log_level_ipv6) tmp_0 = 0;
        else tmp_0 = curr_log_level_ipv6;
        if (3 <= tmp_0) {
          printf("[%-4s: %-10s] ","INFO","IPv6 Route");
          printf("Removing default\n");
        }
      }
      list_remove(defaultrouterlist,(void *)defrt);
      memb_free(& defaultroutermemb,(void *)defrt);
      goto return_label;
    }
    d = (uip_ds6_defrt_t *)list_item_next((void *)d);
  }
  if (0 < curr_log_level_ipv6) tmp_1 = 0; else tmp_1 = curr_log_level_ipv6;
  if (tmp_1 >= 4) assert_nbr_routes_list_sane();
  return_label: return;
}

uip_ds6_defrt_t *uip_ds6_defrt_lookup(uip_ipaddr_t const *ipaddr)
{
  uip_ds6_defrt_t *__retres;
  uip_ds6_defrt_t *d;
  if (ipaddr == (uip_ipaddr_t const *)0) {
    __retres = (uip_ds6_defrt_t *)0;
    goto return_label;
  }
  d = (uip_ds6_defrt_t *)list_head(defaultrouterlist);
  while (d != (uip_ds6_defrt_t *)0) {
    {
      int tmp;
      tmp = memcmp((void const *)(& d->ipaddr),(void const *)ipaddr,
                   sizeof(uip_ip6addr_t));
      if (tmp == 0) {
        __retres = d;
        goto return_label;
      }
    }
    d = (uip_ds6_defrt_t *)list_item_next((void *)d);
  }
  __retres = (uip_ds6_defrt_t *)0;
  return_label: return __retres;
}

uip_ipaddr_t const *uip_ds6_defrt_choose(void)
{
  uip_ipaddr_t const *__retres;
  uip_ds6_defrt_t *d;
  uip_ds6_nbr_t *bestnbr;
  uip_ipaddr_t *addr_0;
  addr_0 = (uip_ipaddr_t *)0;
  d = (uip_ds6_defrt_t *)list_head(defaultrouterlist);
  while (d != (uip_ds6_defrt_t *)0) {
    {
      int tmp;
      if (0 < curr_log_level_ipv6) tmp = 0; else tmp = curr_log_level_ipv6;
      if (3 <= tmp) {
        printf("[%-4s: %-10s] ","INFO","IPv6 Route");
        printf("Default route, IP address ");
      }
    }
    {
      int tmp_0;
      if (0 < curr_log_level_ipv6) tmp_0 = 0;
      else tmp_0 = curr_log_level_ipv6;
      if (3 <= tmp_0) log_6addr((uip_ipaddr_t const *)(& d->ipaddr));
    }
    {
      int tmp_1;
      if (0 < curr_log_level_ipv6) tmp_1 = 0;
      else tmp_1 = curr_log_level_ipv6;
      if (3 <= tmp_1) printf("\n");
    }
    bestnbr = uip_ds6_nbr_lookup((uip_ipaddr_t const *)(& d->ipaddr));
    if (bestnbr != (uip_ds6_nbr_t *)0) {
      if ((int)bestnbr->state != 0) {
        {
          int tmp_2;
          if (0 < curr_log_level_ipv6) tmp_2 = 0;
          else tmp_2 = curr_log_level_ipv6;
          if (3 <= tmp_2) {
            printf("[%-4s: %-10s] ","INFO","IPv6 Route");
            printf("Default route found, IP address ");
          }
        }
        {
          int tmp_3;
          if (0 < curr_log_level_ipv6) tmp_3 = 0;
          else tmp_3 = curr_log_level_ipv6;
          if (3 <= tmp_3) log_6addr((uip_ipaddr_t const *)(& d->ipaddr));
        }
        {
          int tmp_4;
          if (0 < curr_log_level_ipv6) tmp_4 = 0;
          else tmp_4 = curr_log_level_ipv6;
          if (3 <= tmp_4) printf("\n");
        }
        __retres = (uip_ipaddr_t const *)(& d->ipaddr);
        goto return_label;
      }
      else goto _LAND;
    }
    else {
      _LAND:
      {
        addr_0 = & d->ipaddr;
        {
          int tmp_5;
          if (0 < curr_log_level_ipv6) tmp_5 = 0;
          else tmp_5 = curr_log_level_ipv6;
          if (3 <= tmp_5) {
            printf("[%-4s: %-10s] ","INFO","IPv6 Route");
            printf("Default route Incomplete found, IP address ");
          }
        }
        {
          int tmp_6;
          if (0 < curr_log_level_ipv6) tmp_6 = 0;
          else tmp_6 = curr_log_level_ipv6;
          if (3 <= tmp_6) log_6addr((uip_ipaddr_t const *)(& d->ipaddr));
        }
        {
          int tmp_7;
          if (0 < curr_log_level_ipv6) tmp_7 = 0;
          else tmp_7 = curr_log_level_ipv6;
          if (3 <= tmp_7) printf("\n");
        }
      }
    }
    d = (uip_ds6_defrt_t *)list_item_next((void *)d);
  }
  __retres = (uip_ipaddr_t const *)addr_0;
  return_label: return __retres;
}

void uip_ds6_defrt_periodic(void)
{
  uip_ds6_defrt_t *d;
  d = (uip_ds6_defrt_t *)list_head(defaultrouterlist);
  while (d != (uip_ds6_defrt_t *)0) 
    if (! d->isinfinite) {
      int tmp_0;
      tmp_0 = stimer_expired(& d->lifetime);
      if (tmp_0) {
        {
          int tmp;
          if (0 < curr_log_level_ipv6) tmp = 0;
          else tmp = curr_log_level_ipv6;
          if (3 <= tmp) {
            printf("[%-4s: %-10s] ","INFO","IPv6 Route");
            printf("Default route periodic: defrt lifetime expired\n");
          }
        }
        uip_ds6_defrt_rm(d);
        d = (uip_ds6_defrt_t *)list_head(defaultrouterlist);
      }
      else goto _LAND;
    }
    else _LAND: d = (uip_ds6_defrt_t *)list_item_next((void *)d);
  return;
}

__inline static unsigned int __bswap_32_64(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_64(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static void buf_setup(struct psock_buf *buf_0, uint8_t *bufptr_0,
                      uint16_t bufsize)
{
  buf_0->ptr = bufptr_0;
  buf_0->left = bufsize;
  return;
}

static uint8_t buf_bufdata(struct psock_buf *buf_0, uint16_t len,
                           uint8_t **dataptr, uint16_t *datalen)
{
  uint8_t __retres;
  if ((int)*datalen < (int)buf_0->left) {
    memcpy((void *)buf_0->ptr,(void const *)*dataptr,(unsigned long)*datalen);
    buf_0->ptr += (int)*datalen;
    buf_0->left = (unsigned short)((int)buf_0->left - (int)*datalen);
    *dataptr += (int)*datalen;
    *datalen = (unsigned short)0;
    __retres = (unsigned char)0;
    goto return_label;
  }
  else 
    if ((int)*datalen == (int)buf_0->left) {
      memcpy((void *)buf_0->ptr,(void const *)*dataptr,
             (unsigned long)*datalen);
      buf_0->ptr += (int)*datalen;
      buf_0->left = (unsigned short)0;
      *dataptr += (int)*datalen;
      *datalen = (unsigned short)0;
      __retres = (unsigned char)1;
      goto return_label;
    }
    else {
      memcpy((void *)buf_0->ptr,(void const *)*dataptr,
             (unsigned long)buf_0->left);
      buf_0->ptr += (int)buf_0->left;
      *datalen = (unsigned short)((int)*datalen - (int)buf_0->left);
      *dataptr += (int)buf_0->left;
      buf_0->left = (unsigned short)0;
      __retres = (unsigned char)1;
      goto return_label;
    }
  return_label: return __retres;
}

static uint8_t buf_bufto(struct psock_buf *buf_0, uint8_t endmarker,
                         uint8_t **dataptr, uint16_t *datalen)
{
  uint8_t __retres;
  uint8_t c;
  while (1) {
    if ((int)buf_0->left > 0) {
      if (! ((int)*datalen > 0)) break;
    }
    else break;
    {
      uint8_t tmp;
      tmp = *(*dataptr);
      *(buf_0->ptr) = tmp;
      c = tmp;
      (*dataptr) ++;
      (buf_0->ptr) ++;
      *datalen = (uint16_t)((int)*datalen - 1);
      buf_0->left = (unsigned short)((int)buf_0->left - 1);
      if ((int)c == (int)endmarker) {
        __retres = (unsigned char)2;
        goto return_label;
      }
    }
  }
  if ((int)*datalen == 0) {
    __retres = (unsigned char)0;
    goto return_label;
  }
  __retres = (unsigned char)1;
  return_label: return __retres;
}

static char data_is_sent_and_acked(struct psock *s)
{
  char __retres;
  if ((int)s->state != 6) goto _LOR;
  else 
    if ((int)uip_flags & 4) {
      _LOR:
      {
        if ((int)s->sendlen > (int)uip_conn->mss) uip_send((void const *)s->sendptr,
                                                           (int)uip_conn->mss);
        else uip_send((void const *)s->sendptr,(int)s->sendlen);
        s->state = (unsigned char)6;
        __retres = (char)0;
        goto return_label;
      }
    }
    else 
      if ((int)s->state == 6) 
        if ((int)uip_flags & 1) {
          if ((int)s->sendlen > (int)uip_conn->mss) {
            s->sendlen = (unsigned short)((int)s->sendlen - (int)uip_conn->mss);
            s->sendptr += (int)uip_conn->mss;
          }
          else {
            s->sendptr += (int)s->sendlen;
            s->sendlen = (unsigned short)0;
          }
          s->state = (unsigned char)1;
          __retres = (char)1;
          goto return_label;
        }
  __retres = (char)0;
  return_label: return __retres;
}

char psock_send(struct psock *s, uint8_t const *buf_0, unsigned int len)
{
  char __retres;
  {
    char PT_YIELD_FLAG = (char)1;
    if (PT_YIELD_FLAG) ;
    switch ((int)s->psockpt.lc) {
      case 0: ;
      if (len == (unsigned int)0) {
        s->psockpt.lc = (unsigned short)0;
        __retres = (char)2;
        goto return_label;
      }
      s->sendptr = buf_0;
      s->sendlen = (unsigned short)len;
      s->state = (unsigned char)0;
      while ((int)s->sendlen > 0) {
        char tmp;
        s->psockpt.lc = (unsigned short)183;
        case 183: ;
        tmp = data_is_sent_and_acked(s);
        if (! tmp) {
          __retres = (char)0;
          goto return_label;
        }
      }
      s->state = (unsigned char)0;
    }
    PT_YIELD_FLAG = (char)0;
    s->psockpt.lc = (unsigned short)0;
    __retres = (char)3;
    goto return_label;
  }
  return_label: return __retres;
}

char psock_generator_send(struct psock *s,
                          unsigned short (*generate)(void *), void *arg)
{
  char __retres;
  {
    char PT_YIELD_FLAG = (char)1;
    if (PT_YIELD_FLAG) ;
    switch ((int)s->psockpt.lc) {
      case 0: ;
      if (generate == (unsigned short (*)(void *))0) {
        s->psockpt.lc = (unsigned short)0;
        __retres = (char)2;
        goto return_label;
      }
      s->state = (unsigned char)0;
      while (1) {
        s->sendlen = (*generate)(arg);
        s->sendptr = (uint8_t const *)uip_appdata;
        if ((int)s->sendlen > (int)uip_conn->mss) uip_send((void const *)s->sendptr,
                                                           (int)uip_conn->mss);
        else uip_send((void const *)s->sendptr,(int)s->sendlen);
        s->state = (unsigned char)6;
        PT_YIELD_FLAG = (char)0;
        s->psockpt.lc = (unsigned short)217;
        case 217: ;
        if ((int)PT_YIELD_FLAG == 0) goto _LOR;
        else 
          if (! ((int)uip_flags & 1)) 
            if (! ((int)uip_flags & 4)) {
              _LOR: {
                      __retres = (char)1;
                      goto return_label;
                    }
            }
        if (! (! ((int)uip_flags & 1))) break;
      }
      s->state = (unsigned char)0;
    }
    PT_YIELD_FLAG = (char)0;
    s->psockpt.lc = (unsigned short)0;
    __retres = (char)3;
    goto return_label;
  }
  return_label: return __retres;
}

uint16_t psock_datalen(struct psock *psock)
{
  uint16_t __retres;
  __retres = (unsigned short)(psock->bufsize - (unsigned int)psock->buf.left);
  return __retres;
}

char psock_newdata(struct psock *s)
{
  char __retres;
  if ((int)s->readlen > 0) {
    __retres = (char)1;
    goto return_label;
  }
  else 
    if ((int)s->state == 2) {
      s->state = (unsigned char)3;
      __retres = (char)0;
      goto return_label;
    }
    else 
      if ((int)uip_flags & 2) {
        __retres = (char)1;
        goto return_label;
      }
      else {
        __retres = (char)0;
        goto return_label;
      }
  return_label: return __retres;
}

char psock_readto(struct psock *psock, unsigned char c)
{
  char __retres;
  {
    char PT_YIELD_FLAG = (char)1;
    if (PT_YIELD_FLAG) ;
    switch ((int)psock->psockpt.lc) {
      uint16_t tmp_1;
      case 0: ;
      buf_setup(& psock->buf,psock->bufptr,(unsigned short)psock->bufsize);
      while (1) {
        uint8_t tmp_0;
        if ((int)psock->readlen == 0) {
          {
            char tmp;
            psock->psockpt.lc = (unsigned short)262;
            case 262: ;
            tmp = psock_newdata(psock);
            if (! tmp) {
              __retres = (char)0;
              goto return_label;
            }
          }
          psock->state = (unsigned char)2;
          psock->readptr = (uint8_t *)uip_appdata;
          psock->readlen = uip_len;
        }
        tmp_0 = buf_bufto(& psock->buf,c,& psock->readptr,& psock->readlen);
        if (! ((int)tmp_0 == 0)) break;
      }
      tmp_1 = psock_datalen(psock);
      if ((int)tmp_1 == 0) {
        psock->state = (unsigned char)0;
        psock->psockpt.lc = (unsigned short)0;
        __retres = (char)0;
        goto return_label;
      }
    }
    PT_YIELD_FLAG = (char)0;
    psock->psockpt.lc = (unsigned short)0;
    __retres = (char)3;
    goto return_label;
  }
  return_label: return __retres;
}

char psock_readbuf_len(struct psock *psock, uint16_t len)
{
  char __retres;
  {
    char PT_YIELD_FLAG = (char)1;
    if (PT_YIELD_FLAG) ;
    switch ((int)psock->psockpt.lc) {
      uint16_t tmp_2;
      case 0: ;
      buf_setup(& psock->buf,psock->bufptr,(unsigned short)psock->bufsize);
      while (1) {
        uint8_t tmp_0;
        if ((int)psock->readlen == 0) {
          {
            char tmp;
            psock->psockpt.lc = (unsigned short)290;
            case 290: ;
            tmp = psock_newdata(psock);
            if (! tmp) {
              __retres = (char)0;
              goto return_label;
            }
          }
          psock->state = (unsigned char)2;
          psock->readptr = (uint8_t *)uip_appdata;
          psock->readlen = uip_len;
        }
        tmp_0 = buf_bufdata(& psock->buf,(unsigned short)psock->bufsize,
                            & psock->readptr,& psock->readlen);
        if ((int)tmp_0 == 0) {
          uint16_t tmp_1;
          tmp_1 = psock_datalen(psock);
          ;
          if (! ((int)tmp_1 < (int)len)) break;
        }
        else break;
      }
      tmp_2 = psock_datalen(psock);
      if ((int)tmp_2 == 0) {
        psock->state = (unsigned char)0;
        psock->psockpt.lc = (unsigned short)0;
        __retres = (char)0;
        goto return_label;
      }
    }
    PT_YIELD_FLAG = (char)0;
    psock->psockpt.lc = (unsigned short)0;
    __retres = (char)3;
    goto return_label;
  }
  return_label: return __retres;
}

void psock_init(struct psock *psock, uint8_t *buffer, unsigned int buffersize)
{
  psock->state = (unsigned char)0;
  psock->readlen = (unsigned short)0;
  psock->bufptr = buffer;
  psock->bufsize = buffersize;
  buf_setup(& psock->buf,buffer,(unsigned short)buffersize);
  psock->pt.lc = (unsigned short)0;
  psock->psockpt.lc = (unsigned short)0;
  return;
}

__inline static unsigned int __bswap_32_65(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_65(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static uip_ds6_nbr_t _ds6_neighbors_mem[300];
static nbr_table_t ds6_neighbors_struct =
  {.index = 0,
   .item_size = (int)sizeof(uip_ds6_nbr_t),
   .callback = (nbr_table_callback *)0,
   .data = (nbr_table_item_t *)(_ds6_neighbors_mem)};
static nbr_table_t *ds6_neighbors = & ds6_neighbors_struct;
void uip_ds6_neighbors_init(void)
{
  link_stats_init();
  nbr_table_register(ds6_neighbors,
                     (void (*)(nbr_table_item_t *item))(& uip_ds6_nbr_rm));
  return;
}

uip_ds6_nbr_t *uip_ds6_nbr_add(uip_ipaddr_t const *ipaddr,
                               uip_lladdr_t const *lladdr, uint8_t isrouter,
                               uint8_t state, nbr_table_reason_t reason,
                               void *data)
{
  uip_ds6_nbr_t *__retres;
  uip_ds6_nbr_t *nbr_0;
  nbr_0 = (uip_ds6_nbr_t *)nbr_table_add_lladdr(ds6_neighbors,
                                                (linkaddr_t const *)lladdr,
                                                reason,data);
  if (nbr_0) {
    nbr_0->ipaddr = *ipaddr;
    nbr_0->state = state;
    uip_packetqueue_new(& nbr_0->packethandle);
    {
      int tmp;
      if (0 < curr_log_level_ipv6) tmp = 0; else tmp = curr_log_level_ipv6;
      if (3 <= tmp) {
        printf("[%-4s: %-10s] ","INFO","IPv6 Nbr");
        printf("Adding neighbor with ip addr ");
      }
    }
    {
      int tmp_0;
      if (0 < curr_log_level_ipv6) tmp_0 = 0;
      else tmp_0 = curr_log_level_ipv6;
      if (3 <= tmp_0) log_6addr(ipaddr);
    }
    {
      int tmp_1;
      if (0 < curr_log_level_ipv6) tmp_1 = 0;
      else tmp_1 = curr_log_level_ipv6;
      if (3 <= tmp_1) printf(" link addr ");
    }
    {
      int tmp_2;
      if (0 < curr_log_level_ipv6) tmp_2 = 0;
      else tmp_2 = curr_log_level_ipv6;
      if (3 <= tmp_2) log_lladdr((linkaddr_t const *)lladdr);
    }
    {
      int tmp_3;
      if (0 < curr_log_level_ipv6) tmp_3 = 0;
      else tmp_3 = curr_log_level_ipv6;
      if (3 <= tmp_3) printf(" state %u\n",(int)state);
    }
    (*(rpl_lite_driver.neighbor_state_changed))(nbr_0);
    __retres = nbr_0;
    goto return_label;
  }
  else {
    {
      int tmp_4;
      if (0 < curr_log_level_ipv6) tmp_4 = 0;
      else tmp_4 = curr_log_level_ipv6;
      if (3 <= tmp_4) {
        printf("[%-4s: %-10s] ","INFO","IPv6 Nbr");
        printf("Add drop ip addr ");
      }
    }
    {
      int tmp_5;
      if (0 < curr_log_level_ipv6) tmp_5 = 0;
      else tmp_5 = curr_log_level_ipv6;
      if (3 <= tmp_5) log_6addr(ipaddr);
    }
    {
      int tmp_6;
      if (0 < curr_log_level_ipv6) tmp_6 = 0;
      else tmp_6 = curr_log_level_ipv6;
      if (3 <= tmp_6) printf(" link addr (%p) ",lladdr);
    }
    {
      int tmp_7;
      if (0 < curr_log_level_ipv6) tmp_7 = 0;
      else tmp_7 = curr_log_level_ipv6;
      if (3 <= tmp_7) log_lladdr((linkaddr_t const *)lladdr);
    }
    {
      int tmp_8;
      if (0 < curr_log_level_ipv6) tmp_8 = 0;
      else tmp_8 = curr_log_level_ipv6;
      if (3 <= tmp_8) printf(" state %u\n",(int)state);
    }
    __retres = (uip_ds6_nbr_t *)0;
    goto return_label;
  }
  return_label: return __retres;
}

int uip_ds6_nbr_rm(uip_ds6_nbr_t *nbr_0)
{
  int __retres;
  if (nbr_0 != (uip_ds6_nbr_t *)0) {
    int tmp;
    uip_packetqueue_free(& nbr_0->packethandle);
    (*(rpl_lite_driver.neighbor_state_changed))(nbr_0);
    tmp = nbr_table_remove(ds6_neighbors,(nbr_table_item_t *)nbr_0);
    __retres = tmp;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int uip_ds6_nbr_update_ll(uip_ds6_nbr_t **nbr_pp,
                          uip_lladdr_t const *new_ll_addr)
{
  int __retres;
  uip_ds6_nbr_t nbr_backup;
  uip_ds6_nbr_t *tmp_3;
  int tmp_5;
  uip_ds6_nbr_t *tmp_7;
  if (nbr_pp == (uip_ds6_nbr_t **)0) goto _LOR;
  else 
    if (new_ll_addr == (uip_lladdr_t const *)0) {
      _LOR:
      {
        {
          int tmp;
          if (0 < curr_log_level_ipv6) tmp = 0;
          else tmp = curr_log_level_ipv6;
          if (1 <= tmp) {
            printf("[%-4s: %-10s] ","ERR","IPv6 Nbr");
            printf("%s: invalid argument\n","uip_ds6_nbr_update_ll");
          }
        }
        __retres = -1;
        goto return_label;
      }
    }
  tmp_3 = uip_ds6_nbr_ll_lookup(new_ll_addr);
  if (tmp_3 != (uip_ds6_nbr_t *)0) {
    {
      int tmp_0;
      if (0 < curr_log_level_ipv6) tmp_0 = 0;
      else tmp_0 = curr_log_level_ipv6;
      if (1 <= tmp_0) {
        printf("[%-4s: %-10s] ","ERR","IPv6 Nbr");
        printf("%s: new_ll_addr, ","uip_ds6_nbr_update_ll");
      }
    }
    {
      int tmp_1;
      if (0 < curr_log_level_ipv6) tmp_1 = 0;
      else tmp_1 = curr_log_level_ipv6;
      if (1 <= tmp_1) log_lladdr((linkaddr_t const *)new_ll_addr);
    }
    {
      int tmp_2;
      if (0 < curr_log_level_ipv6) tmp_2 = 0;
      else tmp_2 = curr_log_level_ipv6;
      if (1 <= tmp_2) printf(", is already used in another nbr\n");
    }
    __retres = -1;
    goto return_label;
  }
  memcpy((void *)(& nbr_backup),(void const *)*nbr_pp,sizeof(uip_ds6_nbr_t));
  tmp_5 = uip_ds6_nbr_rm(*nbr_pp);
  if (tmp_5 == 0) {
    {
      int tmp_4;
      if (0 < curr_log_level_ipv6) tmp_4 = 0;
      else tmp_4 = curr_log_level_ipv6;
      if (1 <= tmp_4) {
        printf("[%-4s: %-10s] ","ERR","IPv6 Nbr");
        printf("%s: input nbr cannot be removed\n","uip_ds6_nbr_update_ll");
      }
    }
    __retres = -1;
    goto return_label;
  }
  tmp_7 = uip_ds6_nbr_add((uip_ipaddr_t const *)(& nbr_backup.ipaddr),
                          new_ll_addr,nbr_backup.isrouter,nbr_backup.state,
                          NBR_TABLE_REASON_IPV6_ND,(void *)0);
  *nbr_pp = tmp_7;
  if (tmp_7 == (uip_ds6_nbr_t *)0) {
    {
      int tmp_6;
      if (0 < curr_log_level_ipv6) tmp_6 = 0;
      else tmp_6 = curr_log_level_ipv6;
      if (1 <= tmp_6) {
        printf("[%-4s: %-10s] ","ERR","IPv6 Nbr");
        printf("%s: cannot allocate a new nbr for new_ll_addr\n",
               "uip_ds6_nbr_update_ll");
      }
    }
    __retres = -1;
    goto return_label;
  }
  memcpy((void *)*nbr_pp,(void const *)(& nbr_backup),sizeof(uip_ds6_nbr_t));
  __retres = 0;
  return_label: return __retres;
}

uip_ipaddr_t const *uip_ds6_nbr_get_ipaddr(uip_ds6_nbr_t const *nbr_0)
{
  uip_ipaddr_t const *tmp;
  if (nbr_0 != (uip_ds6_nbr_t const *)0) tmp = & nbr_0->ipaddr;
  else tmp = (uip_ipaddr_t const *)0;
  return tmp;
}

uip_lladdr_t const *uip_ds6_nbr_get_ll(uip_ds6_nbr_t const *nbr_0)
{
  uip_lladdr_t const *tmp;
  tmp = (uip_lladdr_t const *)nbr_table_get_lladdr(ds6_neighbors,
                                                   (nbr_table_item_t const *)nbr_0);
  return tmp;
}

int uip_ds6_nbr_num(void)
{
  uip_ds6_nbr_t *nbr_0;
  int num = 0;
  nbr_0 = (uip_ds6_nbr_t *)nbr_table_head(ds6_neighbors);
  while (nbr_0 != (uip_ds6_nbr_t *)0) {
    num ++;
    nbr_0 = (uip_ds6_nbr_t *)nbr_table_next(ds6_neighbors,
                                            (nbr_table_item_t *)nbr_0);
  }
  return num;
}

uip_ds6_nbr_t *uip_ds6_nbr_head(void)
{
  uip_ds6_nbr_t *tmp;
  tmp = (uip_ds6_nbr_t *)nbr_table_head(ds6_neighbors);
  return tmp;
}

uip_ds6_nbr_t *uip_ds6_nbr_next(uip_ds6_nbr_t *nbr_0)
{
  uip_ds6_nbr_t *tmp;
  tmp = (uip_ds6_nbr_t *)nbr_table_next(ds6_neighbors,
                                        (nbr_table_item_t *)nbr_0);
  return tmp;
}

uip_ds6_nbr_t *uip_ds6_nbr_lookup(uip_ipaddr_t const *ipaddr)
{
  uip_ds6_nbr_t *__retres;
  uip_ds6_nbr_t *nbr_0;
  if (ipaddr == (uip_ipaddr_t const *)0) {
    __retres = (uip_ds6_nbr_t *)0;
    goto return_label;
  }
  nbr_0 = uip_ds6_nbr_head();
  while (nbr_0 != (uip_ds6_nbr_t *)0) {
    {
      int tmp;
      tmp = memcmp((void const *)(& nbr_0->ipaddr),(void const *)ipaddr,
                   sizeof(uip_ip6addr_t));
      if (tmp == 0) {
        __retres = nbr_0;
        goto return_label;
      }
    }
    nbr_0 = uip_ds6_nbr_next(nbr_0);
  }
  __retres = (uip_ds6_nbr_t *)0;
  return_label: return __retres;
}

uip_ds6_nbr_t *uip_ds6_nbr_ll_lookup(uip_lladdr_t const *lladdr)
{
  uip_ds6_nbr_t *tmp;
  tmp = (uip_ds6_nbr_t *)nbr_table_get_from_lladdr(ds6_neighbors,
                                                   (linkaddr_t const *)lladdr);
  return tmp;
}

uip_ipaddr_t *uip_ds6_nbr_ipaddr_from_lladdr(uip_lladdr_t const *lladdr)
{
  uip_ipaddr_t *tmp_0;
  uip_ds6_nbr_t *nbr_0 = uip_ds6_nbr_ll_lookup(lladdr);
  if (nbr_0) tmp_0 = & nbr_0->ipaddr; else tmp_0 = (uip_ipaddr_t *)0;
  return tmp_0;
}

uip_lladdr_t const *uip_ds6_nbr_lladdr_from_ipaddr(uip_ipaddr_t const *ipaddr)
{
  uip_lladdr_t const *tmp_1;
  uip_ds6_nbr_t *nbr_0 = uip_ds6_nbr_lookup(ipaddr);
  if (nbr_0) tmp_1 = uip_ds6_nbr_get_ll((uip_ds6_nbr_t const *)nbr_0);
  else tmp_1 = (uip_lladdr_t const *)0;
  return tmp_1;
}

void uip_ds6_link_callback(int status, int numtx)
{
  return;
}

__inline static unsigned int __bswap_32_66(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_66(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

process_event_t tcpip_event;
static struct etimer periodic_0;
static void init_appstate(uip_tcp_appstate_t *as, void *state)
{
  as->p = process_current;
  as->state = state;
  return;
}

uint8_t tcpip_output(uip_lladdr_t const *a)
{
  uint8_t __retres;
  int ret;
  enum netstack_ip_action tmp_0;
  tmp_0 = netstack_process_ip_callback((unsigned char)NETSTACK_IP_OUTPUT,
                                       (linkaddr_t const *)a);
  if (tmp_0 == (unsigned int)NETSTACK_IP_PROCESS) {
    uint8_t tmp;
    tmp = (*(tun6_net_driver.output))((linkaddr_t const *)a);
    ret = (int)tmp;
    __retres = (unsigned char)ret;
    goto return_label;
  }
  else {
    uipbuf_clear();
    __retres = (unsigned char)0;
    goto return_label;
  }
  return_label: return __retres;
}

static char process_thread_tcpip_process(struct pt *process_pt,
                                         process_event_t ev,
                                         process_data_t data);

struct process tcpip_process =
  {.next = (struct process *)0,
   .name = "TCP/IP stack",
   .thread = & process_thread_tcpip_process,
   .pt = {.lc = (unsigned short)0},
   .state = (unsigned char)0,
   .needspoll = (unsigned char)0};
static void check_for_tcp_syn(void)
{
  return;
}

static void packet_input_0(void)
{
  if ((int)uip_len > 0) {
    {
      int tmp;
      if (0 < curr_log_level_tcpip) tmp = 0; else tmp = curr_log_level_tcpip;
      if (3 <= tmp) {
        printf("[%-4s: %-10s] ","INFO","TCP/IP");
        printf("input: received %u bytes\n",(int)uip_len);
      }
    }
    check_for_tcp_syn();
    uip_process((unsigned char)1);
    if ((int)uip_len > 0) tcpip_ipv6_output();
  }
  return;
}

void udp_attach(struct uip_udp_conn *conn, void *appstate)
{
  init_appstate(& conn->appstate,appstate);
  return;
}

struct uip_udp_conn *udp_new(uip_ipaddr_t const *ripaddr, uint16_t port,
                             void *appstate)
{
  struct uip_udp_conn *__retres;
  struct uip_udp_conn *c = uip_udp_new(ripaddr,port);
  if (c == (struct uip_udp_conn *)0) {
    __retres = (struct uip_udp_conn *)0;
    goto return_label;
  }
  init_appstate(& c->appstate,appstate);
  __retres = c;
  return_label: return __retres;
}

struct uip_udp_conn *udp_broadcast_new(uint16_t port, void *appstate)
{
  uip_ipaddr_t addr_0;
  struct uip_udp_conn *conn;
  addr_0.u16[0] = (unsigned short)(((int)((unsigned short)0xff02) << 8) | (
                                   (int)((unsigned short)0xff02) >> 8));
  addr_0.u16[1] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                   (int)((unsigned short)0) >> 8));
  addr_0.u16[2] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                   (int)((unsigned short)0) >> 8));
  addr_0.u16[3] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                   (int)((unsigned short)0) >> 8));
  addr_0.u16[4] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                   (int)((unsigned short)0) >> 8));
  addr_0.u16[5] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                   (int)((unsigned short)0) >> 8));
  addr_0.u16[6] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                   (int)((unsigned short)0) >> 8));
  addr_0.u16[7] = (unsigned short)(((int)((unsigned short)0x0001) << 8) | (
                                   (int)((unsigned short)0x0001) >> 8));
  conn = udp_new((uip_ipaddr_t const *)(& addr_0),port,appstate);
  if (conn != (struct uip_udp_conn *)0) conn->lport = port;
  return conn;
}

static void eventhandler(process_event_t ev, process_data_t data)
{
  struct process *p;
  switch ((int)ev) {
    case 0x87: p = (struct process *)data;
    {
      struct uip_udp_conn *cptr;
      cptr = uip_udp_conns;
      while (cptr < & uip_udp_conns[8]) {
        if (cptr->appstate.p == p) cptr->lport = (unsigned short)0;
        cptr ++;
      }
    }
    break;
    case 0x88:
    {
      if (data == (void *)(& periodic_0)) {
        int tmp;
        tmp = etimer_expired(& periodic_0);
        if (tmp) ;
      }
      if (data == (void *)(& uip_ds6_timer_periodic)) {
        int tmp_0;
        tmp_0 = etimer_expired(& uip_ds6_timer_periodic);
        if (tmp_0) {
          uip_ds6_periodic();
          tcpip_ipv6_output();
        }
      }
    }
    break;
    case UDP_POLL: ;
    if (data != (void *)0) {
      uip_udp_conn = (struct uip_udp_conn *)data;
      uip_process((unsigned char)5);
      tcpip_ipv6_output();
    }
    break;
    case PACKET_INPUT: packet_input_0();
    break;
  }
  return;
}

void tcpip_input(void)
{
  enum netstack_ip_action tmp;
  tmp = netstack_process_ip_callback((unsigned char)NETSTACK_IP_INPUT,
                                     (linkaddr_t const *)0);
  if (tmp == (unsigned int)NETSTACK_IP_PROCESS) process_post_synch(& tcpip_process,
                                                                   (unsigned char)PACKET_INPUT,
                                                                   (void *)0);
  uipbuf_clear();
  return;
}

static void output_fallback(void)
{
  int tmp;
  if (0 < curr_log_level_tcpip) tmp = 0; else tmp = curr_log_level_tcpip;
  if (1 <= tmp) {
    printf("[%-4s: %-10s] ","ERR","TCP/IP");
    printf("output: destination off-link and no default route\n");
  }
  return;
}

static void annotate_transmission(uip_ipaddr_t const *nexthop)
{
  return;
}

static uip_ipaddr_t const *get_nexthop(uip_ipaddr_t *addr_0)
{
  uip_ipaddr_t const *__retres;
  uip_ipaddr_t const *nexthop;
  uip_ds6_route_t *route;
  int tmp_7;
  uint8_t tmp_9;
  {
    int tmp;
    if (0 < curr_log_level_tcpip) tmp = 0; else tmp = curr_log_level_tcpip;
    if (3 <= tmp) {
      printf("[%-4s: %-10s] ","INFO","TCP/IP");
      printf("output: processing %u bytes packet from ",(int)uip_len);
    }
  }
  {
    int tmp_0;
    if (0 < curr_log_level_tcpip) tmp_0 = 0;
    else tmp_0 = curr_log_level_tcpip;
    if (3 <= tmp_0) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr));
  }
  {
    int tmp_1;
    if (0 < curr_log_level_tcpip) tmp_1 = 0;
    else tmp_1 = curr_log_level_tcpip;
    if (3 <= tmp_1) printf(" to ");
  }
  {
    int tmp_2;
    if (0 < curr_log_level_tcpip) tmp_2 = 0;
    else tmp_2 = curr_log_level_tcpip;
    if (3 <= tmp_2) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
  }
  {
    int tmp_3;
    if (0 < curr_log_level_tcpip) tmp_3 = 0;
    else tmp_3 = curr_log_level_tcpip;
    if (3 <= tmp_3) printf("\n");
  }
  tmp_7 = (*(rpl_lite_driver.ext_header_srh_get_next_hop))(addr_0);
  if (tmp_7) {
    {
      int tmp_4;
      if (0 < curr_log_level_tcpip) tmp_4 = 0;
      else tmp_4 = curr_log_level_tcpip;
      if (3 <= tmp_4) {
        printf("[%-4s: %-10s] ","INFO","TCP/IP");
        printf("output: selected next hop from SRH: ");
      }
    }
    {
      int tmp_5;
      if (0 < curr_log_level_tcpip) tmp_5 = 0;
      else tmp_5 = curr_log_level_tcpip;
      if (3 <= tmp_5) log_6addr((uip_ipaddr_t const *)addr_0);
    }
    {
      int tmp_6;
      if (0 < curr_log_level_tcpip) tmp_6 = 0;
      else tmp_6 = curr_log_level_tcpip;
      if (3 <= tmp_6) printf("\n");
    }
    __retres = (uip_ipaddr_t const *)addr_0;
    goto return_label;
  }
  tmp_9 = uip_ds6_is_addr_onlink(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr);
  if (tmp_9) {
    {
      int tmp_8;
      if (0 < curr_log_level_tcpip) tmp_8 = 0;
      else tmp_8 = curr_log_level_tcpip;
      if (3 <= tmp_8) {
        printf("[%-4s: %-10s] ","INFO","TCP/IP");
        printf("output: destination is on link\n");
      }
    }
    __retres = (uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr);
    goto return_label;
  }
  route = uip_ds6_route_lookup((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
  if (route == (uip_ds6_route_t *)0) {
    nexthop = uip_ds6_defrt_choose();
    if (nexthop == (uip_ipaddr_t const *)0) output_fallback();
    else {
      {
        int tmp_10;
        if (0 < curr_log_level_tcpip) tmp_10 = 0;
        else tmp_10 = curr_log_level_tcpip;
        if (3 <= tmp_10) {
          printf("[%-4s: %-10s] ","INFO","TCP/IP");
          printf("output: no route found, using default route: ");
        }
      }
      {
        int tmp_11;
        if (0 < curr_log_level_tcpip) tmp_11 = 0;
        else tmp_11 = curr_log_level_tcpip;
        if (3 <= tmp_11) log_6addr(nexthop);
      }
      {
        int tmp_12;
        if (0 < curr_log_level_tcpip) tmp_12 = 0;
        else tmp_12 = curr_log_level_tcpip;
        if (3 <= tmp_12) printf("\n");
      }
    }
  }
  else {
    nexthop = uip_ds6_route_nexthop(route);
    if (nexthop == (uip_ipaddr_t const *)0) {
      {
        int tmp_13;
        if (0 < curr_log_level_tcpip) tmp_13 = 0;
        else tmp_13 = curr_log_level_tcpip;
        if (1 <= tmp_13) {
          printf("[%-4s: %-10s] ","ERR","TCP/IP");
          printf("output: found dead route\n");
        }
      }
      (*(rpl_lite_driver.drop_route))(route);
      uip_ds6_route_rm(route);
    }
    else {
      {
        int tmp_14;
        if (0 < curr_log_level_tcpip) tmp_14 = 0;
        else tmp_14 = curr_log_level_tcpip;
        if (3 <= tmp_14) {
          printf("[%-4s: %-10s] ","INFO","TCP/IP");
          printf("output: found next hop from routing table: ");
        }
      }
      {
        int tmp_15;
        if (0 < curr_log_level_tcpip) tmp_15 = 0;
        else tmp_15 = curr_log_level_tcpip;
        if (3 <= tmp_15) log_6addr(nexthop);
      }
      {
        int tmp_16;
        if (0 < curr_log_level_tcpip) tmp_16 = 0;
        else tmp_16 = curr_log_level_tcpip;
        if (3 <= tmp_16) printf("\n");
      }
    }
  }
  __retres = nexthop;
  return_label: return __retres;
}

static void send_queued(uip_ds6_nbr_t *nbr_0)
{
  uint16_t tmp_1;
  tmp_1 = uip_packetqueue_buflen(& nbr_0->packethandle);
  if ((int)tmp_1 != 0) {
    uint8_t *tmp;
    uip_lladdr_t const *tmp_0;
    uip_len = uip_packetqueue_buflen(& nbr_0->packethandle);
    ;
    tmp = uip_packetqueue_buf(& nbr_0->packethandle);
    ;
    memcpy((void *)(uip_aligned_buf.u8),(void const *)tmp,
           (unsigned long)uip_len);
    uip_packetqueue_free(& nbr_0->packethandle);
    tmp_0 = uip_ds6_nbr_get_ll((uip_ds6_nbr_t const *)nbr_0);
    tcpip_output(tmp_0);
  }
  return;
}

static int send_nd6_ns(uip_ipaddr_t const *nexthop)
{
  int err_0 = 1;
  {
    int tmp;
    if (0 < curr_log_level_tcpip) tmp = 0; else tmp = curr_log_level_tcpip;
    if (1 <= tmp) {
      printf("[%-4s: %-10s] ","ERR","TCP/IP");
      printf("output: neighbor not in cache: ");
    }
  }
  {
    int tmp_0;
    if (0 < curr_log_level_tcpip) tmp_0 = 0;
    else tmp_0 = curr_log_level_tcpip;
    if (1 <= tmp_0) log_6addr(nexthop);
  }
  {
    int tmp_1;
    if (0 < curr_log_level_tcpip) tmp_1 = 0;
    else tmp_1 = curr_log_level_tcpip;
    if (1 <= tmp_1) printf("\n");
  }
  return err_0;
}

void tcpip_ipv6_output(void)
{
  uip_ipaddr_t ipaddr;
  uip_lladdr_t const *linkaddr;
  uip_ipaddr_t const *nexthop;
  int tmp_2;
  uip_ds6_addr_t *tmp_4;
  uip_ds6_nbr_t *nbr_0 = (uip_ds6_nbr_t *)0;
  if ((int)uip_len == 0) goto return_label;
  if ((int)uip_len > 1280) {
    {
      int tmp;
      if (0 < curr_log_level_tcpip) tmp = 0; else tmp = curr_log_level_tcpip;
      if (1 <= tmp) {
        printf("[%-4s: %-10s] ","ERR","TCP/IP");
        printf("output: Packet too big");
      }
    }
    goto exit;
  }
  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[0] == 0) 
    if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[1] == 0) 
      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[2] == 0) 
        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[3] == 0) 
          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[4] == 0) 
            if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[5] == 0) 
              if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[6] == 0) 
                if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[7] == 0) {
                  {
                    int tmp_0;
                    if (0 < curr_log_level_tcpip) tmp_0 = 0;
                    else tmp_0 = curr_log_level_tcpip;
                    if (1 <= tmp_0) {
                      printf("[%-4s: %-10s] ","ERR","TCP/IP");
                      printf("output: Destination address unspecified");
                    }
                  }
                  goto exit;
                }
  tmp_2 = (*(rpl_lite_driver.ext_header_update))();
  if (! tmp_2) {
    {
      int tmp_1;
      if (0 < curr_log_level_tcpip) tmp_1 = 0;
      else tmp_1 = curr_log_level_tcpip;
      if (1 <= tmp_1) {
        printf("[%-4s: %-10s] ","ERR","TCP/IP");
        printf("output: routing protocol extension header update error\n");
      }
    }
    uipbuf_clear();
    goto return_label;
  }
  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[0] == 0xFF) {
    linkaddr = (uip_lladdr_t const *)0;
    goto send_packet;
  }
  tmp_4 = uip_ds6_addr_lookup(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr);
  if (tmp_4 != (uip_ds6_addr_t *)0) {
    {
      int tmp_3;
      if (0 < curr_log_level_tcpip) tmp_3 = 0;
      else tmp_3 = curr_log_level_tcpip;
      if (3 <= tmp_3) {
        printf("[%-4s: %-10s] ","INFO","TCP/IP");
        printf("output: sending to ourself\n");
      }
    }
    packet_input_0();
    goto return_label;
  }
  nexthop = get_nexthop(& ipaddr);
  if (nexthop == (uip_ipaddr_t const *)0) goto exit;
  annotate_transmission(nexthop);
  nbr_0 = uip_ds6_nbr_lookup(nexthop);
  if (nbr_0 == (uip_ds6_nbr_t *)0) {
    uip_lladdr_t lladdr;
    uip_ds6_set_lladdr_from_iid(& lladdr,nexthop);
    nbr_0 = uip_ds6_nbr_add(nexthop,(uip_lladdr_t const *)(& lladdr),
                            (unsigned char)0,(unsigned char)1,
                            NBR_TABLE_REASON_IPV6_ND_AUTOFILL,(void *)0);
    if (nbr_0 == (uip_ds6_nbr_t *)0) {
      {
        int tmp_5;
        if (0 < curr_log_level_tcpip) tmp_5 = 0;
        else tmp_5 = curr_log_level_tcpip;
        if (1 <= tmp_5) {
          printf("[%-4s: %-10s] ","ERR","TCP/IP");
          printf("output: failed to autofill neighbor cache for host ");
        }
      }
      {
        int tmp_6;
        if (0 < curr_log_level_tcpip) tmp_6 = 0;
        else tmp_6 = curr_log_level_tcpip;
        if (1 <= tmp_6) log_6addr(nexthop);
      }
      {
        int tmp_7;
        if (0 < curr_log_level_tcpip) tmp_7 = 0;
        else tmp_7 = curr_log_level_tcpip;
        if (1 <= tmp_7) printf(", link-layer addr ");
      }
      {
        int tmp_8;
        if (0 < curr_log_level_tcpip) tmp_8 = 0;
        else tmp_8 = curr_log_level_tcpip;
        if (1 <= tmp_8) log_lladdr((linkaddr_t const *)(& lladdr));
      }
      {
        int tmp_9;
        if (0 < curr_log_level_tcpip) tmp_9 = 0;
        else tmp_9 = curr_log_level_tcpip;
        if (1 <= tmp_9) printf("\n");
      }
      goto exit;
    }
  }
  if (nbr_0 == (uip_ds6_nbr_t *)0) {
    int tmp_11;
    tmp_11 = send_nd6_ns(nexthop);
    if (tmp_11) {
      {
        int tmp_10;
        if (0 < curr_log_level_tcpip) tmp_10 = 0;
        else tmp_10 = curr_log_level_tcpip;
        if (1 <= tmp_10) {
          printf("[%-4s: %-10s] ","ERR","TCP/IP");
          printf("output: failed to add neighbor to cache\n");
        }
      }
      goto exit;
    }
    else goto send_packet;
  }
  send_packet: ;
  if (nbr_0) linkaddr = uip_ds6_nbr_get_ll((uip_ds6_nbr_t const *)nbr_0);
  else linkaddr = (uip_lladdr_t const *)0;
  {
    int tmp_12;
    if (0 < curr_log_level_tcpip) tmp_12 = 0;
    else tmp_12 = curr_log_level_tcpip;
    if (3 <= tmp_12) {
      printf("[%-4s: %-10s] ","INFO","TCP/IP");
      printf("output: sending to ");
    }
  }
  {
    int tmp_13;
    if (0 < curr_log_level_tcpip) tmp_13 = 0;
    else tmp_13 = curr_log_level_tcpip;
    if (3 <= tmp_13) log_lladdr((linkaddr_t const *)linkaddr);
  }
  {
    int tmp_14;
    if (0 < curr_log_level_tcpip) tmp_14 = 0;
    else tmp_14 = curr_log_level_tcpip;
    if (3 <= tmp_14) printf("\n");
  }
  tcpip_output(linkaddr);
  if (nbr_0) send_queued(nbr_0);
  exit: uipbuf_clear();
  return_label: return;
}

void tcpip_poll_udp(struct uip_udp_conn *conn)
{
  process_post(& tcpip_process,(unsigned char)UDP_POLL,(void *)conn);
  return;
}

void tcpip_uipcall(void)
{
  uip_udp_appstate_t *ts;
  if (uip_conn != (struct uip_conn *)0) ts = & uip_conn->appstate;
  else ts = & uip_udp_conn->appstate;
  if (ts->p != (struct process *)0) process_post_synch(ts->p,tcpip_event,
                                                       ts->state);
  return;
}

static char process_thread_tcpip_process(struct pt *process_pt,
                                         process_event_t ev,
                                         process_data_t data)
{
  char __retres;
  {
    char PT_YIELD_FLAG = (char)1;
    if (PT_YIELD_FLAG) ;
    switch ((int)process_pt->lc) {
      case 0: ;
      tcpip_event = process_alloc_event();
      etimer_set(& periodic_0,(unsigned long)(1000 / 2));
      uip_init();
      (*(rpl_lite_driver.init))();
      while (1) {
        PT_YIELD_FLAG = (char)0;
        process_pt->lc = (unsigned short)831;
        case 831: ;
        if ((int)PT_YIELD_FLAG == 0) {
          __retres = (char)1;
          goto return_label;
        }
        eventhandler(ev,data);
      }
    }
    PT_YIELD_FLAG = (char)0;
    process_pt->lc = (unsigned short)0;
    __retres = (char)3;
    goto return_label;
  }
  return_label: return __retres;
}

__inline static unsigned int __bswap_32_67(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_67(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

uip_buf_t uip_aligned_buf;
void *uip_appdata;
uint16_t uip_len;
struct uip_conn *uip_conn;
struct uip_udp_conn *uip_udp_conn;
struct uip_udp_conn uip_udp_conns[8];
uint8_t uip_flags;
uip_lladdr_t uip_lladdr;
uint8_t uip_ext_bitmap = (unsigned char)0;
uint16_t uip_ext_len = (unsigned short)0;
uint8_t uip_last_proto = (unsigned char)0;
void *uip_sappdata;
uint16_t uip_slen;
static uint16_t lastport;
static uint16_t chksum(uint16_t sum, uint8_t const *data, uint16_t len)
{
  uint16_t t;
  uint8_t const *dataptr;
  uint8_t const *last_byte;
  dataptr = data;
  last_byte = (data + (int)len) - 1;
  while (dataptr < last_byte) {
    t = (unsigned short)(((int)*(dataptr + 0) << 8) + (int)*(dataptr + 1));
    sum = (unsigned short)((int)sum + (int)t);
    if ((int)sum < (int)t) sum = (uint16_t)((int)sum + 1);
    dataptr += 2;
  }
  if (dataptr == last_byte) {
    t = (unsigned short)(((int)*(dataptr + 0) << 8) + 0);
    sum = (unsigned short)((int)sum + (int)t);
    if ((int)sum < (int)t) sum = (uint16_t)((int)sum + 1);
  }
  return sum;
}

uint16_t uip_chksum(uint16_t *data, uint16_t len)
{
  uint16_t tmp_0;
  uint16_t tmp;
  tmp = chksum((unsigned short)0,(uint8_t const *)data,len);
  tmp_0 = uip_htons(tmp);
  return tmp_0;
}

static uint16_t upper_layer_chksum(uint8_t proto)
{
  uint16_t __retres;
  uint16_t upper_layer_len;
  uint16_t sum;
  uint16_t tmp;
  int tmp_2;
  tmp = uipbuf_get_len_field((struct uip_ip_hdr *)(uip_aligned_buf.u8));
  upper_layer_len = (unsigned short)((int)tmp - (int)uip_ext_len);
  {
    int tmp_0;
    if (0 < curr_log_level_ipv6) tmp_0 = 0; else tmp_0 = curr_log_level_ipv6;
    if (4 <= tmp_0) {
      printf("[%-4s: %-10s] ","DBG","IPv6");
      printf("Upper layer checksum len: %d from: %d\n",(int)upper_layer_len,
             (int)((& uip_aligned_buf.u8[40] + (int)uip_ext_len) - uip_aligned_buf.u8));
    }
  }
  sum = (unsigned short)((int)upper_layer_len + (int)proto);
  sum = chksum(sum,
               (uint8_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr),
               (unsigned short)((unsigned long)2 * sizeof(uip_ipaddr_t)));
  sum = chksum(sum,
               (uint8_t const *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len),
               upper_layer_len);
  if ((int)sum == 0) tmp_2 = 0xffff;
  else {
    uint16_t tmp_1;
    tmp_1 = uip_htons(sum);
    tmp_2 = (int)tmp_1;
  }
  __retres = (unsigned short)tmp_2;
  return __retres;
}

uint16_t uip_icmp6chksum(void)
{
  uint16_t tmp;
  tmp = upper_layer_chksum((unsigned char)58);
  return tmp;
}

uint16_t uip_udpchksum(void)
{
  uint16_t tmp;
  tmp = upper_layer_chksum((unsigned char)17);
  return tmp;
}

void uip_init(void)
{
  int c;
  uipbuf_init();
  uip_ds6_init();
  uip_icmp6_init();
  uip_nd6_init();
  lastport = (unsigned short)1024;
  c = 0;
  while (c < 8) {
    uip_udp_conns[c].lport = (unsigned short)0;
    c ++;
  }
  return;
}

_Bool uip_remove_ext_hdr(void)
{
  _Bool __retres;
  if ((int)uip_ext_len > 0) {
    _Bool tmp_1;
    {
      int tmp;
      if (0 < curr_log_level_ipv6) tmp = 0; else tmp = curr_log_level_ipv6;
      if (4 <= tmp) {
        printf("[%-4s: %-10s] ","DBG","IPv6");
        printf("Removing IPv6 extension headers (extlen: %d, uiplen: %d)\n",
               (int)uip_ext_len,(int)uip_len);
      }
    }
    if ((int)uip_len < 40 + (int)uip_ext_len) {
      {
        int tmp_0;
        if (0 < curr_log_level_ipv6) tmp_0 = 0;
        else tmp_0 = curr_log_level_ipv6;
        if (1 <= tmp_0) {
          printf("[%-4s: %-10s] ","ERR","IPv6");
          printf("uip_len too short compared to ext len\n");
        }
      }
      uipbuf_clear();
      __retres = (_Bool)0;
      goto return_label;
    }
    ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto = uip_last_proto;
    memmove((void *)(& uip_aligned_buf.u8[40] + 0),
            (void const *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len),
            (unsigned long)(((int)uip_len - 40) - (int)uip_ext_len));
    tmp_1 = uipbuf_add_ext_hdr((short)(- ((int)uip_ext_len)));
    if ((int)tmp_1 == 0) {
      __retres = (_Bool)0;
      goto return_label;
    }
    uipbuf_set_len_field((struct uip_ip_hdr *)(uip_aligned_buf.u8),
                         (unsigned short)((int)uip_len - 40));
  }
  __retres = (_Bool)1;
  return_label: return __retres;
}

struct uip_udp_conn *uip_udp_new(uip_ipaddr_t const *ripaddr, uint16_t rport)
{
  struct uip_udp_conn *__retres;
  int c;
  register struct uip_udp_conn *conn;
  again: lastport = (uint16_t)((int)lastport + 1);
  if ((int)lastport >= 32000) lastport = (unsigned short)4096;
  c = 0;
  while (c < 8) {
    {
      uint16_t tmp;
      tmp = uip_htons(lastport);
      ;
      if ((int)uip_udp_conns[c].lport == (int)tmp) goto again;
    }
    c ++;
  }
  conn = (struct uip_udp_conn *)0;
  c = 0;
  while (c < 8) {
    if ((int)uip_udp_conns[c].lport == 0) {
      conn = & uip_udp_conns[c];
      break;
    }
    c ++;
  }
  if (conn == (struct uip_udp_conn *)0) {
    __retres = (struct uip_udp_conn *)0;
    goto return_label;
  }
  conn->lport = (unsigned short)(((int)lastport << 8) | ((int)lastport >> 8));
  conn->rport = rport;
  if (ripaddr == (uip_ipaddr_t const *)0) memset((void *)(& conn->ripaddr),0,
                                                 sizeof(uip_ipaddr_t));
  else conn->ripaddr = *ripaddr;
  conn->ttl = uip_ds6_if.cur_hop_limit;
  __retres = conn;
  return_label: return __retres;
}

static uint8_t ext_hdr_options_process(uint8_t *ext_buf)
{
  uint8_t __retres;
  uint16_t opt_offset = (unsigned short)2;
  struct uip_hbho_hdr *ext_hdr = (struct uip_hbho_hdr *)ext_buf;
  uint16_t ext_hdr_len = (unsigned short)(((int)ext_hdr->len << 3) + 8);
  while ((int)opt_offset + 2 <= (int)ext_hdr_len) {
    struct uip_ext_hdr_opt *opt_hdr =
      (struct uip_ext_hdr_opt *)(ext_buf + (int)opt_offset);
    uint16_t opt_len = (unsigned short)((int)opt_hdr->len + 2);
    if ((int)opt_offset + (int)opt_len > (int)ext_hdr_len) {
      {
        int tmp;
        if (0 < curr_log_level_ipv6) tmp = 0; else tmp = curr_log_level_ipv6;
        if (1 <= tmp) {
          printf("[%-4s: %-10s] ","ERR","IPv6");
          printf("Extension header option too long: dropping packet\n");
        }
      }
      uip_icmp6_error_output((unsigned char)4,(unsigned char)2,
                             (unsigned int)((ext_buf + (int)opt_offset) - uip_aligned_buf.u8));
      __retres = (unsigned char)2;
      goto return_label;
    }
    switch ((int)opt_hdr->type) {
      int tmp_4;
      case 0:
      {
        int tmp_0;
        if (0 < curr_log_level_ipv6) tmp_0 = 0;
        else tmp_0 = curr_log_level_ipv6;
        if (4 <= tmp_0) {
          printf("[%-4s: %-10s] ","DBG","IPv6");
          printf("Processing PAD1 option\n");
        }
      }
      opt_offset = (unsigned short)((int)opt_offset + 1);
      break;
      case 1:
      {
        int tmp_1;
        if (0 < curr_log_level_ipv6) tmp_1 = 0;
        else tmp_1 = curr_log_level_ipv6;
        if (4 <= tmp_1) {
          printf("[%-4s: %-10s] ","DBG","IPv6");
          printf("Processing PADN option\n");
        }
      }
      opt_offset = (unsigned short)((int)opt_offset + (int)opt_len);
      break;
      case 0x63:
      {
        int tmp_2;
        if (0 < curr_log_level_ipv6) tmp_2 = 0;
        else tmp_2 = curr_log_level_ipv6;
        if (4 <= tmp_2) {
          printf("[%-4s: %-10s] ","DBG","IPv6");
          printf("Processing RPL option\n");
        }
      }
      tmp_4 = (*(rpl_lite_driver.ext_header_hbh_update))(ext_buf,
                                                         (int)opt_offset);
      if (! tmp_4) {
        {
          int tmp_3;
          if (0 < curr_log_level_ipv6) tmp_3 = 0;
          else tmp_3 = curr_log_level_ipv6;
          if (1 <= tmp_3) {
            printf("[%-4s: %-10s] ","ERR","IPv6");
            printf("RPL Option Error: Dropping Packet\n");
          }
        }
        __retres = (unsigned char)1;
        goto return_label;
      }
      opt_offset = (unsigned short)((int)opt_offset + (int)opt_len);
      break;
      default:
      {
        int tmp_5;
        if (0 < curr_log_level_ipv6) tmp_5 = 0;
        else tmp_5 = curr_log_level_ipv6;
        if (4 <= tmp_5) {
          printf("[%-4s: %-10s] ","DBG","IPv6");
          printf("Unrecognized option, MSB 0x%x\n",(int)opt_hdr->type);
        }
      }
      switch ((int)opt_hdr->type & 0xC0) {
        case 0: break;
        case 0x40: __retres = (unsigned char)1;
        goto return_label;
        case 0xC0: ;
        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[0] == 0xFF) {
          __retres = (unsigned char)1;
          goto return_label;
        }
        case 0x80:
        uip_icmp6_error_output((unsigned char)4,(unsigned char)2,
                               (unsigned int)((ext_buf + (int)opt_offset) - uip_aligned_buf.u8));
        __retres = (unsigned char)2;
        goto return_label;
      }
      opt_offset = (unsigned short)((int)opt_offset + (int)opt_len);
      break;
    }
  }
  __retres = (unsigned char)0;
  return_label: return __retres;
}

static _Bool uip_check_mtu(void)
{
  _Bool __retres;
  if ((int)uip_len > 1280) {
    uip_icmp6_error_output((unsigned char)2,(unsigned char)0,
                           (unsigned int)1280);
    __retres = (_Bool)0;
    goto return_label;
  }
  else {
    __retres = (_Bool)1;
    goto return_label;
  }
  return_label: return __retres;
}

static _Bool uip_update_ttl(void)
{
  _Bool __retres;
  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->ttl <= 1) {
    uip_icmp6_error_output((unsigned char)3,(unsigned char)0,(unsigned int)0);
    __retres = (_Bool)0;
    goto return_label;
  }
  else {
    ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->ttl = (unsigned char)(
    (int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->ttl - 1);
    __retres = (_Bool)1;
    goto return_label;
  }
  return_label: return __retres;
}

void uip_process(uint8_t flag)
{
  uint8_t *last_header;
  uint8_t protocol;
  uint8_t *next_header;
  struct uip_ext_hdr *ext_ptr;
  uint16_t tmp_2;
  uint16_t tmp_3;
  uip_ds6_addr_t *tmp_21;
  uint16_t tmp_39;
  uint8_t tmp_41;
  uint16_t tmp_51;
  if ((int)flag == 4) goto udp_send;
  uip_appdata = (void *)(& uip_aligned_buf.u8[20 + 40]);
  uip_sappdata = uip_appdata;
  if (! ((int)flag == 3)) 
    if ((int)flag == 2) ;
  if ((int)flag == 5) 
    if ((int)uip_udp_conn->lport != 0) {
      uip_conn = (struct uip_conn *)0;
      uip_appdata = (void *)(& uip_aligned_buf.u8[8 + 40]);
      uip_sappdata = uip_appdata;
      uip_slen = (unsigned short)0;
      uip_len = uip_slen;
      uip_flags = (unsigned char)8;
      tcpip_uipcall();
      goto udp_send;
    }
    else goto drop;
  if ((int)uip_len < 40) {
    {
      int tmp;
      if (0 < curr_log_level_ipv6) tmp = 0; else tmp = curr_log_level_ipv6;
      if (2 <= tmp) {
        printf("[%-4s: %-10s] ","WARN","IPv6");
        printf("incomplete IPv6 header received (%d bytes)\n",(int)uip_len);
      }
    }
    goto drop;
  }
  if (((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->vtc & 0xf0) != 0x60) {
    {
      int tmp_0;
      if (0 < curr_log_level_ipv6) tmp_0 = 0;
      else tmp_0 = curr_log_level_ipv6;
      if (1 <= tmp_0) {
        printf("[%-4s: %-10s] ","ERR","IPv6");
        printf("invalid version\n");
      }
    }
    goto drop;
  }
  tmp_2 = uipbuf_get_len_field((struct uip_ip_hdr *)(uip_aligned_buf.u8));
  ;
  if ((int)uip_len < (int)tmp_2) {
    {
      int tmp_1;
      if (0 < curr_log_level_ipv6) tmp_1 = 0;
      else tmp_1 = curr_log_level_ipv6;
      if (1 <= tmp_1) {
        printf("[%-4s: %-10s] ","ERR","IPv6");
        printf("packet shorter than reported in IP header\n");
      }
    }
    goto drop;
  }
  tmp_3 = uipbuf_get_len_field((struct uip_ip_hdr *)(uip_aligned_buf.u8));
  uip_len = (unsigned short)((int)tmp_3 + 40);
  if ((unsigned long)uip_len > sizeof(uip_aligned_buf.u8)) {
    {
      int tmp_4;
      if (0 < curr_log_level_ipv6) tmp_4 = 0;
      else tmp_4 = curr_log_level_ipv6;
      if (2 <= tmp_4) {
        printf("[%-4s: %-10s] ","WARN","IPv6");
        printf("dropping packet with length %d > %d\n",(int)uip_len,
               (int)sizeof(uip_aligned_buf.u8));
      }
    }
    goto drop;
  }
  uip_last_proto = (unsigned char)0;
  last_header = uipbuf_get_last_header(uip_aligned_buf.u8,uip_len,
                                       & uip_last_proto);
  if (last_header == (uint8_t *)0) {
    {
      int tmp_5;
      if (0 < curr_log_level_ipv6) tmp_5 = 0;
      else tmp_5 = curr_log_level_ipv6;
      if (1 <= tmp_5) {
        printf("[%-4s: %-10s] ","ERR","IPv6");
        printf("invalid extension header chain\n");
      }
    }
    goto drop;
  }
  uip_ext_len = (unsigned short)(last_header - (& uip_aligned_buf.u8[40] + 0));
  {
    int tmp_6;
    if (0 < curr_log_level_ipv6) tmp_6 = 0; else tmp_6 = curr_log_level_ipv6;
    if (3 <= tmp_6) {
      printf("[%-4s: %-10s] ","INFO","IPv6");
      printf("packet received from ");
    }
  }
  {
    int tmp_7;
    if (0 < curr_log_level_ipv6) tmp_7 = 0; else tmp_7 = curr_log_level_ipv6;
    if (3 <= tmp_7) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr));
  }
  {
    int tmp_8;
    if (0 < curr_log_level_ipv6) tmp_8 = 0; else tmp_8 = curr_log_level_ipv6;
    if (3 <= tmp_8) printf(" to ");
  }
  {
    int tmp_9;
    if (0 < curr_log_level_ipv6) tmp_9 = 0; else tmp_9 = curr_log_level_ipv6;
    if (3 <= tmp_9) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
  }
  {
    int tmp_10;
    if (0 < curr_log_level_ipv6) tmp_10 = 0;
    else tmp_10 = curr_log_level_ipv6;
    if (3 <= tmp_10) printf("\n");
  }
  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u8[0] == 0xFF) {
    {
      int tmp_11;
      if (0 < curr_log_level_ipv6) tmp_11 = 0;
      else tmp_11 = curr_log_level_ipv6;
      if (1 <= tmp_11) {
        printf("[%-4s: %-10s] ","ERR","IPv6");
        printf("Dropping packet, src is mcast\n");
      }
    }
    goto drop;
  }
  next_header = uipbuf_get_next_header(uip_aligned_buf.u8,uip_len,& protocol,
                                       (_Bool)1);
  if (next_header != (uint8_t *)0) 
    if ((int)protocol == 0) {
      uint8_t tmp_12;
      tmp_12 = ext_hdr_options_process(next_header);
      switch ((int)tmp_12) {
        case 0: break;
        case 1: goto drop;
        case 2: goto send;
      }
    }
  tmp_21 = uip_ds6_addr_lookup(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr);
  if (! (tmp_21 != (uip_ds6_addr_t *)0)) {
    uip_ds6_maddr_t *tmp_22;
    tmp_22 = uip_ds6_maddr_lookup((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
    if (! (tmp_22 != (uip_ds6_maddr_t *)0)) 
      if (! ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[0] == 0xFF)) 
        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[0] == 0xfe) {
          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[1] == 0x80) 
            goto _LAND_34;
          else goto _LAND_35;
        }
        else {
          _LAND_35: ;
          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u8[0] == 0xfe) {
            if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u8[1] == 0x80) 
              goto _LAND_34;
            else goto _LAND_33;
          }
          else {
            _LAND_33: ;
            if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[0] == 0) {
              if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[1] == 0) {
                if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[2] == 0) {
                  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[3] == 0) {
                    if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[4] == 0) {
                      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[5] == 0) {
                        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[6] == 0) {
                          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[7] == 0) 
                            goto _LAND_34;
                          else goto _LAND_31;
                        }
                        else goto _LAND_31;
                      }
                      else goto _LAND_31;
                    }
                    else goto _LAND_31;
                  }
                  else goto _LAND_31;
                }
                else goto _LAND_31;
              }
              else goto _LAND_31;
            }
            else {
              _LAND_31: ;
              if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[0] == 0) {
                if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[1] == 0) {
                  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[2] == 0) {
                    if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[3] == 0) {
                      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[4] == 0) {
                        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[5] == 0) {
                          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[6] == 0) {
                            if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[14] == 0) {
                              if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[15] == 0x01) 
                                goto _LAND_34;
                              else goto _LAND_23;
                            }
                            else goto _LAND_23;
                          }
                          else goto _LAND_23;
                        }
                        else goto _LAND_23;
                      }
                      else goto _LAND_23;
                    }
                    else goto _LAND_23;
                  }
                  else goto _LAND_23;
                }
                else goto _LAND_23;
              }
              else {
                _LAND_23:
                {
                  _Bool tmp_13;
                  tmp_13 = uip_check_mtu();
                  if (tmp_13) {
                    _Bool tmp_14;
                    tmp_14 = uip_update_ttl();
                    if (! tmp_14) goto _LAND;
                  }
                  else _LAND: goto send;
                  {
                    int tmp_15;
                    if (0 < curr_log_level_ipv6) tmp_15 = 0;
                    else tmp_15 = curr_log_level_ipv6;
                    if (3 <= tmp_15) {
                      printf("[%-4s: %-10s] ","INFO","IPv6");
                      printf("Forwarding packet to next hop ");
                    }
                  }
                  {
                    int tmp_16;
                    if (0 < curr_log_level_ipv6) tmp_16 = 0;
                    else tmp_16 = curr_log_level_ipv6;
                    if (3 <= tmp_16) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
                  }
                  {
                    int tmp_17;
                    if (0 < curr_log_level_ipv6) tmp_17 = 0;
                    else tmp_17 = curr_log_level_ipv6;
                    if (3 <= tmp_17) printf("\n");
                  }
                  goto send;
                }
              }
            }
          }
        }
      else {
        _LAND_34:
        {
          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u8[0] == 0xfe) 
            if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u8[1] == 0x80) 
              if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[0] == 0) {
                if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[1] == 0) {
                  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[2] == 0) {
                    if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[3] == 0) {
                      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[4] == 0) {
                        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[5] == 0) {
                          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[6] == 0) {
                            if (! ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[7] == 0)) 
                              goto _LAND_14;
                          }
                          else goto _LAND_14;
                        }
                        else goto _LAND_14;
                      }
                      else goto _LAND_14;
                    }
                    else goto _LAND_14;
                  }
                  else goto _LAND_14;
                }
                else goto _LAND_14;
              }
              else {
                _LAND_14: ;
                if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[0] == 0) {
                  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[1] == 0) {
                    if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[2] == 0) {
                      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[3] == 0) {
                        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[4] == 0) {
                          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[5] == 0) {
                            if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[6] == 0) {
                              if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[14] == 0) {
                                if (! ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[15] == 0x01)) 
                                  goto _LAND_7;
                              }
                              else goto _LAND_7;
                            }
                            else goto _LAND_7;
                          }
                          else goto _LAND_7;
                        }
                        else goto _LAND_7;
                      }
                      else goto _LAND_7;
                    }
                    else goto _LAND_7;
                  }
                  else goto _LAND_7;
                }
                else 
                  _LAND_7:
                  if (! ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[0] == 0xFF)) {
                    uint8_t tmp_19;
                    tmp_19 = uip_ds6_is_addr_onlink(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr);
                    if (! tmp_19) {
                      {
                        int tmp_18;
                        if (0 < curr_log_level_ipv6) tmp_18 = 0;
                        else tmp_18 = curr_log_level_ipv6;
                        if (1 <= tmp_18) {
                          printf("[%-4s: %-10s] ","ERR","IPv6");
                          printf("LL source address with off link destination, dropping\n");
                        }
                      }
                      uip_icmp6_error_output((unsigned char)1,
                                             (unsigned char)2,
                                             (unsigned int)0);
                      goto send;
                    }
                  }
              }
          {
            int tmp_20;
            if (0 < curr_log_level_ipv6) tmp_20 = 0;
            else tmp_20 = curr_log_level_ipv6;
            if (1 <= tmp_20) {
              printf("[%-4s: %-10s] ","ERR","IPv6");
              printf("Dropping packet, not for me and link local or multicast\n");
            }
          }
          goto drop;
        }
      }
  }
  uip_ext_bitmap = (unsigned char)0;
  next_header = uipbuf_get_next_header(uip_aligned_buf.u8,uip_len,& protocol,
                                       (_Bool)1);
  while (1) {
    if (next_header != (uint8_t *)0) 
      if ((int)protocol != 6) 
        if ((int)protocol != 17) {
          if (! ((int)protocol != 58)) break;
        }
        else break;
      else break;
    else break;
    ext_ptr = (struct uip_ext_hdr *)next_header;
    switch ((int)protocol) {
      uint8_t tmp_24;
      uint8_t tmp_26;
      case 0:
      {
        int tmp_23;
        if (0 < curr_log_level_ipv6) tmp_23 = 0;
        else tmp_23 = curr_log_level_ipv6;
        if (4 <= tmp_23) {
          printf("[%-4s: %-10s] ","DBG","IPv6");
          printf("Processing hbh header\n");
        }
      }
      if ((int)uip_ext_bitmap & 0x01) goto bad_hdr;
      else uip_ext_bitmap = (unsigned char)((int)uip_ext_bitmap | 0x01);
      tmp_24 = ext_hdr_options_process(next_header);
      switch ((int)tmp_24) {
        case 0: break;
        case 1: goto drop;
        case 2: goto send;
      }
      break;
      case 60:
      {
        int tmp_25;
        if (0 < curr_log_level_ipv6) tmp_25 = 0;
        else tmp_25 = curr_log_level_ipv6;
        if (4 <= tmp_25) {
          printf("[%-4s: %-10s] ","DBG","IPv6");
          printf("Processing desto header\n");
        }
      }
      if ((int)uip_ext_bitmap & 0x02) {
        if ((int)uip_ext_bitmap & 0x40) goto bad_hdr;
        else uip_ext_bitmap = (unsigned char)((int)uip_ext_bitmap | 0x40);
      }
      else uip_ext_bitmap = (unsigned char)((int)uip_ext_bitmap | 0x02);
      tmp_26 = ext_hdr_options_process(next_header);
      switch ((int)tmp_26) {
        case 0: break;
        case 1: goto drop;
        case 2: goto send;
      }
      break;
      case 43: ;
      if ((int)uip_ext_bitmap & 0x04) goto bad_hdr;
      else uip_ext_bitmap = (unsigned char)((int)uip_ext_bitmap | 0x04);
      {
        int tmp_27;
        if (0 < curr_log_level_ipv6) tmp_27 = 0;
        else tmp_27 = curr_log_level_ipv6;
        if (4 <= tmp_27) {
          printf("[%-4s: %-10s] ","DBG","IPv6");
          printf("Processing Routing header\n");
        }
      }
      if ((int)((struct uip_routing_hdr *)ext_ptr)->seg_left > 0) {
        int tmp_34;
        tmp_34 = (*(rpl_lite_driver.ext_header_srh_update))();
        if (tmp_34) {
          _Bool tmp_28;
          tmp_28 = uip_check_mtu();
          if (tmp_28) {
            _Bool tmp_29;
            tmp_29 = uip_update_ttl();
            if (! tmp_29) goto _LAND_36;
          }
          else _LAND_36: goto send;
          {
            int tmp_30;
            if (0 < curr_log_level_ipv6) tmp_30 = 0;
            else tmp_30 = curr_log_level_ipv6;
            if (3 <= tmp_30) {
              printf("[%-4s: %-10s] ","INFO","IPv6");
              printf("Forwarding packet to next hop ");
            }
          }
          {
            int tmp_31;
            if (0 < curr_log_level_ipv6) tmp_31 = 0;
            else tmp_31 = curr_log_level_ipv6;
            if (3 <= tmp_31) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
          }
          {
            int tmp_32;
            if (0 < curr_log_level_ipv6) tmp_32 = 0;
            else tmp_32 = curr_log_level_ipv6;
            if (3 <= tmp_32) printf("\n");
          }
          goto send;
        }
        else {
          {
            int tmp_33;
            if (0 < curr_log_level_ipv6) tmp_33 = 0;
            else tmp_33 = curr_log_level_ipv6;
            if (1 <= tmp_33) {
              printf("[%-4s: %-10s] ","ERR","IPv6");
              printf("Unrecognized routing type\n");
            }
          }
          goto bad_hdr;
        }
      }
      break;
      case 44: ;
      {
        int tmp_35;
        if (0 < curr_log_level_ipv6) tmp_35 = 0;
        else tmp_35 = curr_log_level_ipv6;
        if (1 <= tmp_35) {
          printf("[%-4s: %-10s] ","ERR","IPv6");
          printf("fragment dropped.");
        }
      }
      goto drop;
      case 59: goto drop;
      default: goto bad_hdr;
    }
    next_header = uipbuf_get_next_header(next_header,
                                         (unsigned short)((long)uip_len - (
                                                          next_header - uip_aligned_buf.u8)),
                                         & protocol,(_Bool)0);
  }
  if (next_header != (uint8_t *)0) 
    switch ((int)protocol) {
      case 17: goto udp_input;
      case 58: goto icmp6_input;
    }
  bad_hdr:
  uip_icmp6_error_output((unsigned char)4,(unsigned char)1,
                         (unsigned int)(next_header - uip_aligned_buf.u8));
  {
    int tmp_36;
    if (0 < curr_log_level_ipv6) tmp_36 = 0;
    else tmp_36 = curr_log_level_ipv6;
    if (1 <= tmp_36) {
      printf("[%-4s: %-10s] ","ERR","IPv6");
      printf("unrecognized header\n");
    }
  }
  goto send;
  icmp6_input:
  {
    int tmp_37;
    if (0 < curr_log_level_ipv6) tmp_37 = 0;
    else tmp_37 = curr_log_level_ipv6;
    if (3 <= tmp_37) {
      printf("[%-4s: %-10s] ","INFO","IPv6");
      printf("icmpv6 input length %d type: %d \n",(int)uip_len,
             (int)((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->type);
    }
  }
  tmp_39 = uip_icmp6chksum();
  if ((int)tmp_39 != 0xffff) {
    {
      int tmp_38;
      if (0 < curr_log_level_ipv6) tmp_38 = 0;
      else tmp_38 = curr_log_level_ipv6;
      if (1 <= tmp_38) {
        printf("[%-4s: %-10s] ","ERR","IPv6");
        printf("icmpv6 bad checksum\n");
      }
    }
    goto drop;
  }
  tmp_41 = uip_icmp6_input(((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->type,
                           ((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->icode);
  if ((int)tmp_41 == 1) {
    {
      int tmp_40;
      if (0 < curr_log_level_ipv6) tmp_40 = 0;
      else tmp_40 = curr_log_level_ipv6;
      if (1 <= tmp_40) {
        printf("[%-4s: %-10s] ","ERR","IPv6");
        printf("Unknown ICMPv6 message type/code %d\n",
               (int)((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->type);
      }
    }
    uipbuf_clear();
  }
  if ((int)uip_len > 0) goto send; else goto drop;
  udp_input: uip_remove_ext_hdr();
  {
    int tmp_42;
    if (0 < curr_log_level_ipv6) tmp_42 = 0;
    else tmp_42 = curr_log_level_ipv6;
    if (3 <= tmp_42) {
      printf("[%-4s: %-10s] ","INFO","IPv6");
      printf("Receiving UDP packet\n");
    }
  }
  if ((int)((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->udpchksum != 0) {
    uint16_t tmp_45;
    tmp_45 = uip_udpchksum();
    if ((int)tmp_45 != 0xffff) {
      {
        int tmp_44;
        if (0 < curr_log_level_ipv6) tmp_44 = 0;
        else tmp_44 = curr_log_level_ipv6;
        if (1 <= tmp_44) {
          uint16_t tmp_43;
          printf("[%-4s: %-10s] ","ERR","IPv6");
          tmp_43 = uip_udpchksum();
          ;
          printf("udp: bad checksum 0x%04x 0x%04x\n",
                 (int)((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->udpchksum,
                 (int)tmp_43);
        }
      }
      goto drop;
    }
  }
  if ((int)((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->destport == 0) {
    {
      int tmp_46;
      if (0 < curr_log_level_ipv6) tmp_46 = 0;
      else tmp_46 = curr_log_level_ipv6;
      if (1 <= tmp_46) {
        printf("[%-4s: %-10s] ","ERR","IPv6");
        printf("udp: zero port.\n");
      }
    }
    goto drop;
  }
  uip_udp_conn = uip_udp_conns;
  while (uip_udp_conn < & uip_udp_conns[8]) {
    if ((int)uip_udp_conn->lport != 0) 
      if ((int)((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->destport == (int)uip_udp_conn->lport) 
        if ((int)uip_udp_conn->rport == 0) goto _LOR_0;
        else 
          if ((int)((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->srcport == (int)uip_udp_conn->rport) {
            _LOR_0: ;
            if ((int)uip_udp_conn->ripaddr.u16[0] == 0) {
              if ((int)uip_udp_conn->ripaddr.u16[1] == 0) {
                if ((int)uip_udp_conn->ripaddr.u16[2] == 0) {
                  if ((int)uip_udp_conn->ripaddr.u16[3] == 0) {
                    if ((int)uip_udp_conn->ripaddr.u16[4] == 0) {
                      if ((int)uip_udp_conn->ripaddr.u16[5] == 0) {
                        if ((int)uip_udp_conn->ripaddr.u16[6] == 0) {
                          if ((int)uip_udp_conn->ripaddr.u16[7] == 0) 
                            goto _LOR;
                          else goto _LAND_43;
                        }
                        else goto _LAND_43;
                      }
                      else goto _LAND_43;
                    }
                    else goto _LAND_43;
                  }
                  else goto _LAND_43;
                }
                else goto _LAND_43;
              }
              else goto _LAND_43;
            }
            else {
              int tmp_47;
              _LAND_43:
              tmp_47 = memcmp((void const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr),
                              (void const *)(& uip_udp_conn->ripaddr),
                              sizeof(uip_ip6addr_t));
              if (tmp_47 == 0) _LOR: goto udp_found;
            }
          }
    uip_udp_conn ++;
  }
  {
    int tmp_48;
    if (0 < curr_log_level_ipv6) tmp_48 = 0;
    else tmp_48 = curr_log_level_ipv6;
    if (1 <= tmp_48) {
      printf("[%-4s: %-10s] ","ERR","IPv6");
      printf("udp: no matching connection found\n");
    }
  }
  uip_icmp6_error_output((unsigned char)1,(unsigned char)4,(unsigned int)0);
  goto send;
  udp_found:
  {
    int tmp_49;
    if (0 < curr_log_level_ipv6) tmp_49 = 0;
    else tmp_49 = curr_log_level_ipv6;
    if (4 <= tmp_49) {
      printf("[%-4s: %-10s] ","DBG","IPv6");
      printf("In udp_found\n");
    }
  }
  uip_len = (unsigned short)((int)uip_len - (8 + 40));
  uip_appdata = (void *)(& uip_aligned_buf.u8[8 + 40]);
  uip_conn = (struct uip_conn *)0;
  uip_flags = (unsigned char)2;
  uip_appdata = (void *)(& uip_aligned_buf.u8[8 + 40]);
  uip_sappdata = uip_appdata;
  uip_slen = (unsigned short)0;
  tcpip_uipcall();
  udp_send:
  {
    int tmp_50;
    if (0 < curr_log_level_ipv6) tmp_50 = 0;
    else tmp_50 = curr_log_level_ipv6;
    if (4 <= tmp_50) {
      printf("[%-4s: %-10s] ","DBG","IPv6");
      printf("In udp_send\n");
    }
  }
  if ((int)uip_slen == 0) goto drop;
  uip_len = (unsigned short)((int)uip_slen + (8 + 40));
  uipbuf_set_len_field((struct uip_ip_hdr *)(uip_aligned_buf.u8),
                       (unsigned short)((int)uip_len - 40));
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->vtc = (unsigned char)0x60;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->tcflow = (unsigned char)0x00;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->ttl = uip_udp_conn->ttl;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto = (unsigned char)17;
  ((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->udplen = (unsigned short)(
  ((int)((unsigned short)((int)uip_slen + 8)) << 8) | ((int)((unsigned short)(
                                                       (int)uip_slen + 8)) >> 8));
  ((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->udpchksum = (unsigned short)0;
  ((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->srcport = uip_udp_conn->lport;
  ((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->destport = uip_udp_conn->rport;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr = uip_udp_conn->ripaddr;
  uip_ds6_select_src(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr,
                     & ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr);
  uip_appdata = (void *)(& uip_aligned_buf.u8[20 + 40]);
  tmp_51 = uip_udpchksum();
  ((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->udpchksum = (unsigned short)(~ ((int)tmp_51));
  if ((int)((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->udpchksum == 0) 
    ((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->udpchksum = (unsigned short)0xffff;
  goto ip_send_nolen;
  ip_send_nolen:
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->flow = (unsigned short)0x00;
  send:
  {
    int tmp_53;
    if (0 < curr_log_level_ipv6) tmp_53 = 0;
    else tmp_53 = curr_log_level_ipv6;
    if (3 <= tmp_53) {
      uint16_t tmp_52;
      printf("[%-4s: %-10s] ","INFO","IPv6");
      tmp_52 = uipbuf_get_len_field((struct uip_ip_hdr *)(uip_aligned_buf.u8));
      ;
      printf("Sending packet with length %d (%d)\n",(int)uip_len,(int)tmp_52);
    }
  }
  uip_flags = (unsigned char)0;
  goto return_label;
  drop: uipbuf_clear();
  uip_ext_bitmap = (unsigned char)0;
  uip_flags = (unsigned char)0;
  return_label: return;
}

uint16_t uip_htons(uint16_t val)
{
  uint16_t __retres;
  __retres = (unsigned short)(((int)val << 8) | ((int)val >> 8));
  return __retres;
}

uint32_t uip_htonl(uint32_t val)
{
  uint32_t __retres;
  __retres = ((unsigned int)((unsigned short)(((int)((unsigned short)val) << 8) | (
                                              (int)((unsigned short)val) >> 8))) << 16) | (unsigned int)((unsigned short)(
             ((int)((unsigned short)(val >> 16)) << 8) | ((int)((unsigned short)(
                                                          val >> 16)) >> 8)));
  return __retres;
}

void uip_send(void const *data, int len)
{
  int copylen;
  if (uip_sappdata != (void *)0) 
    if (len < (1280 - (20 + 40)) - (int)((char *)uip_sappdata - (char *)(
                                         (& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 20))) 
      copylen = len;
    else copylen = (1280 - (20 + 40)) - (int)((char *)uip_sappdata - (char *)(
                                              (& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 20));
  else 
    if (len < 1280 - (20 + 40)) copylen = len;
    else copylen = 1280 - (20 + 40);
  if (copylen > 0) {
    uip_slen = (unsigned short)copylen;
    if ((void *)data != uip_sappdata) 
      if (uip_sappdata == (void *)0) memcpy((void *)((& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 20),
                                            data,(unsigned long)uip_slen);
      else memcpy(uip_sappdata,data,(unsigned long)uip_slen);
  }
  return;
}

__inline static unsigned int __bswap_32_68(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_68(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

process_event_t resolv_event_found;
static struct namemap names[4];
static uint8_t seqno;
static struct uip_udp_conn *resolv_conn = (struct uip_udp_conn *)0;
static struct etimer retry;
static char process_thread_resolv_process(struct pt *process_pt,
                                          process_event_t ev,
                                          process_data_t data);

struct process resolv_process =
  {.next = (struct process *)0,
   .name = "DNS resolver",
   .thread = & process_thread_resolv_process,
   .pt = {.lc = (unsigned short)0},
   .state = (unsigned char)0,
   .needspoll = (unsigned char)0};
static void resolv_found(char *name, uip_ipaddr_t *ipaddr);

static char resolv_hostname[32 + 1];
static uint8_t mdns_state;
static uip_ipaddr_t const resolv_mdns_addr =
  {.u8 = {(unsigned char)0xff,
          (unsigned char)0x02,
          (unsigned char)0x00,
          (unsigned char)0x00,
          (unsigned char)0x00,
          (unsigned char)0x00,
          (unsigned char)0x00,
          (unsigned char)0x00,
          (unsigned char)0x00,
          (unsigned char)0x00,
          (unsigned char)0x00,
          (unsigned char)0x00,
          (unsigned char)0x00,
          (unsigned char)0x00,
          (unsigned char)0x00,
          (unsigned char)0xfb}};
static int mdns_needs_host_announce;
static char process_thread_mdns_probe_process(struct pt *process_pt,
                                              process_event_t ev,
                                              process_data_t data);

struct process mdns_probe_process =
  {.next = (struct process *)0,
   .name = "mDNS probe",
   .thread = & process_thread_mdns_probe_process,
   .pt = {.lc = (unsigned short)0},
   .state = (unsigned char)0,
   .needspoll = (unsigned char)0};
static uint8_t decode_name(unsigned char const *query, char *dest,
                           unsigned char const *packet)
{
  uint8_t __retres;
  unsigned char const *tmp;
  int len = 32;
  tmp = query;
  query ++;
  unsigned char n = *tmp;
  while (1) {
    if (len) {
      if (! n) break;
    }
    else break;
    {
      unsigned char const *tmp_3;
      if ((int)n & 0xc0) {
        unsigned char const *tmp_0;
        uint16_t const offset =
          (unsigned short)((int)*(query + 0) + (((int)n & ~ 0xC0) << 8));
        query = packet + (int)offset;
        tmp_0 = query;
        query ++;
        n = *tmp_0;
      }
      if (! n) break;
      while (n) {
        {
          char *tmp_1;
          unsigned char const *tmp_2;
          tmp_1 = dest;
          dest ++;
          tmp_2 = query;
          query ++;
          *tmp_1 = (char)*tmp_2;
          len --;
          if (! len) {
            *dest = (char)0;
            __retres = (unsigned char)0;
            goto return_label;
          }
        }
        n = (unsigned char)((int)n - 1);
      }
      tmp_3 = query;
      query ++;
      n = *tmp_3;
      if (n) {
        char *tmp_4;
        tmp_4 = dest;
        dest ++;
        *tmp_4 = (char)'.';
        len --;
      }
    }
  }
  *dest = (char)0;
  __retres = (unsigned char)(len != 0);
  return_label: return __retres;
}

static uint8_t dns_name_isequal(unsigned char const *queryptr,
                                char const *name, unsigned char const *packet)
{
  uint8_t __retres;
  unsigned char const *tmp;
  tmp = queryptr;
  queryptr ++;
  unsigned char n = *tmp;
  if ((int)*name == 0) {
    __retres = (unsigned char)0;
    goto return_label;
  }
  while (n) {
    unsigned char const *tmp_5;
    if ((int)n & 0xc0) {
      unsigned char const *tmp_0;
      queryptr = (packet + (int)*(queryptr + 0)) + (((int)n & ~ 0xC0) << 8);
      tmp_0 = queryptr;
      queryptr ++;
      n = *tmp_0;
    }
    while (n) {
      {
        int tmp_2;
        char const *tmp_1;
        int tmp_4;
        unsigned char const *tmp_3;
        if (! *name) {
          __retres = (unsigned char)0;
          goto return_label;
        }
        tmp_1 = name;
        name ++;
        ;
        tmp_2 = tolower((int)((unsigned int)*tmp_1));
        tmp_3 = queryptr;
        queryptr ++;
        ;
        tmp_4 = tolower((int)((unsigned int)*tmp_3));
        if (tmp_2 != tmp_4) {
          __retres = (unsigned char)0;
          goto return_label;
        }
      }
      n = (unsigned char)((int)n - 1);
    }
    tmp_5 = queryptr;
    queryptr ++;
    n = *tmp_5;
    if ((int)n != 0) {
      char const *tmp_6;
      tmp_6 = name;
      name ++;
      ;
      if ((int)*tmp_6 != '.') {
        __retres = (unsigned char)0;
        goto return_label;
      }
    }
  }
  if ((int)*name == '.') name ++;
  __retres = (unsigned char)((int)*(name + 0) == 0);
  return_label: return __retres;
}

static unsigned char *skip_name(unsigned char *query)
{
  unsigned char *__retres;
  unsigned char n;
  while (1) {
    n = *query;
    if ((int)n & 0xc0) {
      query ++;
      break;
    }
    query ++;
    while ((int)n > 0) {
      query ++;
      n = (unsigned char)((int)n - 1);
    }
    if (! ((int)*query != 0)) break;
  }
  __retres = query + 1;
  return __retres;
}

static unsigned char *encode_name(unsigned char *query, char const *nameptr)
{
  char *nptr;
  unsigned char *tmp;
  nameptr --;
  while (1) {
    {
      uint8_t n = (unsigned char)0;
      nameptr ++;
      nptr = (char *)query;
      query ++;
      n = (unsigned char)0;
      while (1) {
        if ((int)*nameptr != '.') {
          if (! ((int)*nameptr != 0)) break;
        }
        else break;
        *query = (unsigned char)*nameptr;
        query ++;
        n = (uint8_t)((int)n + 1);
        nameptr ++;
      }
      *nptr = (char)n;
    }
    if (! ((int)*nameptr != 0)) break;
  }
  tmp = query;
  query ++;
  *tmp = (unsigned char)0;
  return query;
}

static void mdns_announce_requested(void)
{
  mdns_needs_host_announce = 1;
  return;
}

static void start_name_collision_check(clock_time_t after)
{
  process_exit(& mdns_probe_process);
  process_start(& mdns_probe_process,(void *)(& after));
  return;
}

static unsigned char *mdns_write_announce_records(unsigned char *queryptr,
                                                  uint8_t *count)
{
  uint8_t i;
  i = (unsigned char)0;
  while ((int)i < 1 + 2) {
    if (uip_ds6_if.addr_list[i].isused) 
      if ((int)uip_ds6_if.addr_list[i].ipaddr.u8[0] == 0xfe) 
        if ((int)uip_ds6_if.addr_list[i].ipaddr.u8[1] == 0x80) {
          unsigned char *tmp_1;
          unsigned char *tmp_2;
          unsigned char *tmp_3;
          unsigned char *tmp_4;
          unsigned char *tmp_5;
          unsigned char *tmp_6;
          unsigned char *tmp_7;
          unsigned char *tmp_8;
          unsigned char *tmp_9;
          unsigned char *tmp_10;
          if (! *count) queryptr = encode_name(queryptr,
                                               (char const *)(resolv_hostname));
          else {
            unsigned char *tmp;
            unsigned char *tmp_0;
            tmp = queryptr;
            queryptr ++;
            *tmp = (unsigned char)0xc0;
            tmp_0 = queryptr;
            queryptr ++;
            *tmp_0 = (unsigned char)sizeof(struct dns_hdr);
          }
          tmp_1 = queryptr;
          queryptr ++;
          *tmp_1 = (unsigned char)(28 >> 8);
          tmp_2 = queryptr;
          queryptr ++;
          *tmp_2 = (unsigned char)28;
          tmp_3 = queryptr;
          queryptr ++;
          *tmp_3 = (unsigned char)((1 | 0x8000) >> 8);
          tmp_4 = queryptr;
          queryptr ++;
          *tmp_4 = (unsigned char)(1 | 0x8000);
          tmp_5 = queryptr;
          queryptr ++;
          *tmp_5 = (unsigned char)0;
          tmp_6 = queryptr;
          queryptr ++;
          *tmp_6 = (unsigned char)0;
          tmp_7 = queryptr;
          queryptr ++;
          *tmp_7 = (unsigned char)0;
          tmp_8 = queryptr;
          queryptr ++;
          *tmp_8 = (unsigned char)120;
          tmp_9 = queryptr;
          queryptr ++;
          *tmp_9 = (unsigned char)0;
          tmp_10 = queryptr;
          queryptr ++;
          *tmp_10 = (unsigned char)sizeof(uip_ipaddr_t);
          *((uip_ipaddr_t *)queryptr) = uip_ds6_if.addr_list[i].ipaddr;
          queryptr += sizeof(uip_ipaddr_t);
          *count = (uint8_t)((int)*count + 1);
        }
    i = (uint8_t)((int)i + 1);
  }
  return queryptr;
}

static size_t mdns_prep_host_announce_packet(void);

static struct __anonstruct_nsec_record_27 const mdns_prep_host_announce_packet_nsec_record =
  {.type = (unsigned short)(((int)((unsigned short)47) << 8) | ((int)((unsigned short)47) >> 8)),
   .class = (unsigned short)(((int)((unsigned short)(1 | 0x8000)) << 8) | (
                             (int)((unsigned short)(1 | 0x8000)) >> 8)),
   .ttl = {(unsigned short)0,
           (unsigned short)(((int)((unsigned short)120) << 8) | ((int)((unsigned short)120) >> 8))},
   .len = (unsigned short)(((int)((unsigned short)8) << 8) | ((int)((unsigned short)8) >> 8)),
   .data = {(unsigned char)0xc0,
            (unsigned char)sizeof(struct dns_hdr),
            (unsigned char)0x00,
            (unsigned char)0x04,
            (unsigned char)0x00,
            (unsigned char)0x00,
            (unsigned char)0x00,
            (unsigned char)0x08}};
static size_t mdns_prep_host_announce_packet(void)
{
  size_t __retres;
  unsigned char *queryptr;
  uint8_t total_answers = (unsigned char)0;
  struct dns_hdr *hdr = (struct dns_hdr *)uip_appdata;
  memset((void *)hdr,0,sizeof(*hdr));
  hdr->flags1 = (unsigned char)((int)hdr->flags1 | (0x80 | 0x04));
  queryptr = (unsigned char *)uip_appdata + sizeof(*hdr);
  queryptr = mdns_write_announce_records(queryptr,& total_answers);
  if (! total_answers) queryptr = encode_name(queryptr,
                                              (char const *)(resolv_hostname));
  else {
    unsigned char *tmp;
    unsigned char *tmp_0;
    tmp = queryptr;
    queryptr ++;
    *tmp = (unsigned char)0xc0;
    tmp_0 = queryptr;
    queryptr ++;
    *tmp_0 = (unsigned char)sizeof(*hdr);
  }
  memcpy((void *)queryptr,
         (void const *)(& mdns_prep_host_announce_packet_nsec_record),
         sizeof(mdns_prep_host_announce_packet_nsec_record));
  queryptr += sizeof(mdns_prep_host_announce_packet_nsec_record);
  *((uint8_t *)(& hdr->numanswers) + 1) = total_answers;
  *((uint8_t *)(& hdr->numextrarr) + 1) = (unsigned char)1;
  __retres = (unsigned long)(queryptr - (unsigned char *)uip_appdata);
  return __retres;
}

static char try_next_server(struct namemap *namemapptr)
{
  char __retres;
  uip_ipaddr_t *tmp;
  namemapptr->server = (uint8_t)((int)namemapptr->server + 1);
  tmp = uip_nameserver_get(namemapptr->server);
  if (tmp != (uip_ipaddr_t *)0) {
    namemapptr->retries = (unsigned char)0;
    __retres = (char)1;
    goto return_label;
  }
  namemapptr->server = (unsigned char)0;
  __retres = (char)0;
  return_label: return __retres;
}

static void check_entries(void)
{
  uint8_t volatile i;
  uint8_t *query;
  register struct dns_hdr *hdr;
  register struct namemap *namemapptr;
  i = (unsigned char)0;
  while ((int)i < 4) {
    namemapptr = & names[i];
    if ((int)namemapptr->state == 2) goto _LOR_0;
    else 
      if ((int)namemapptr->state == 3) {
        _LOR_0:
        {
          uint8_t *tmp_6;
          uint8_t *tmp_7;
          etimer_set(& retry,(unsigned long)(1000 / 4));
          if ((int)namemapptr->state == 3) {
            namemapptr->tmr = (uint8_t)((int)namemapptr->tmr - 1);
            if ((int)namemapptr->tmr == 0) {
              int tmp_1;
              namemapptr->retries = (uint8_t)((int)namemapptr->retries + 1);
              if (namemapptr->is_mdns) tmp_1 = 3; else tmp_1 = 4;
              if ((int)namemapptr->retries == tmp_1) {
                char tmp_0;
                tmp_0 = try_next_server(namemapptr);
                if ((int)tmp_0 == 0) {
                  unsigned long tmp;
                  namemapptr->state = (unsigned char)1;
                  tmp = clock_seconds();
                  namemapptr->expiration = tmp + (unsigned long)30;
                  resolv_found(namemapptr->name,(uip_ipaddr_t *)0);
                  goto __Cont;
                }
              }
              namemapptr->tmr = (unsigned char)(((int)namemapptr->retries * (int)namemapptr->retries) * 3);
              if (namemapptr->is_probe) namemapptr->tmr = (unsigned char)2;
            }
            else goto __Cont;
          }
          else {
            namemapptr->state = (unsigned char)3;
            namemapptr->tmr = (unsigned char)1;
            namemapptr->retries = (unsigned char)0;
          }
          hdr = (struct dns_hdr *)uip_appdata;
          memset((void *)hdr,0,sizeof(struct dns_hdr));
          hdr->id = random_rand();
          namemapptr->id = hdr->id;
          if (! namemapptr->is_mdns) goto _LOR;
          else 
            if (namemapptr->is_probe) _LOR:
                                      hdr->flags1 = (unsigned char)0x01;
          if (namemapptr->is_mdns) hdr->id = (unsigned short)0;
          hdr->numquestions = (unsigned short)(((int)((unsigned short)1) << 8) | (
                                               (int)((unsigned short)1) >> 8));
          query = (unsigned char *)uip_appdata + sizeof(*hdr);
          query = encode_name(query,(char const *)(namemapptr->name));
          if (namemapptr->is_probe) {
            uint8_t *tmp_2;
            uint8_t *tmp_3;
            tmp_2 = query;
            query ++;
            *tmp_2 = (unsigned char)(255 >> 8);
            tmp_3 = query;
            query ++;
            *tmp_3 = (unsigned char)255;
          }
          else {
            uint8_t *tmp_4;
            uint8_t *tmp_5;
            tmp_4 = query;
            query ++;
            *tmp_4 = (unsigned char)(28 >> 8);
            tmp_5 = query;
            query ++;
            *tmp_5 = (unsigned char)28;
          }
          tmp_6 = query;
          query ++;
          *tmp_6 = (unsigned char)(1 >> 8);
          tmp_7 = query;
          query ++;
          *tmp_7 = (unsigned char)1;
          if (namemapptr->is_mdns) {
            if (namemapptr->is_probe) {
              uint8_t count = (unsigned char)0;
              query = mdns_write_announce_records(query,& count);
              hdr->numauthrr = (unsigned short)(((int)((unsigned short)count) << 8) | (
                                                (int)((unsigned short)count) >> 8));
            }
            uip_udp_packet_sendto(resolv_conn,(void const *)uip_appdata,
                                  (int)(query - (uint8_t *)uip_appdata),
                                  & resolv_mdns_addr,
                                  (unsigned short)(((int)((unsigned short)5353) << 8) | (
                                                   (int)((unsigned short)5353) >> 8)));
          }
          else {
            uip_ipaddr_t *tmp_8;
            tmp_8 = uip_nameserver_get(namemapptr->server);
            ;
            ;
            ;
            uip_udp_packet_sendto(resolv_conn,(void const *)uip_appdata,
                                  (int)(query - (uint8_t *)uip_appdata),
                                  (uip_ipaddr_t const *)tmp_8,
                                  (unsigned short)(((int)((unsigned short)53) << 8) | (
                                                   (int)((unsigned short)53) >> 8)));
          }
          break;
        }
      }
    __Cont: i = (uint8_t)((int)i + 1);
  }
  return;
}

static struct dns_question newdata_aligned;
static struct dns_answer newdata_aligned_0;
static void newdata(void)
{
  uint8_t nquestions;
  uint8_t nanswers;
  int8_t i;
  struct dns_answer *ans;
  int tmp;
  uint16_t tmp_0;
  uint16_t tmp_1;
  register struct namemap *namemapptr = (struct namemap *)0;
  register struct dns_hdr const *hdr = (struct dns_hdr const *)uip_appdata;
  unsigned char *queryptr = (unsigned char *)hdr + sizeof(*hdr);
  if (((int)hdr->flags1 & ~ 1) == 0) 
    if ((int)hdr->flags2 == 0) tmp = 1; else tmp = 0;
  else tmp = 0;
  uint8_t const is_request = (unsigned char)tmp;
  tmp_0 = uip_htons(hdr->numquestions);
  nquestions = (unsigned char)tmp_0;
  tmp_1 = uip_htons(hdr->numanswers);
  nanswers = (unsigned char)tmp_1;
  queryptr = (unsigned char *)hdr + sizeof(*hdr);
  i = (signed char)0;
  if (is_request) 
    if ((int)nquestions == 0) goto return_label;
  while ((int)nquestions > 0) {
    unsigned char *tmp_2;
    if (! is_request) goto __Cont;
    {
      uint16_t tmp_4;
      uint8_t tmp_5;
      struct dns_question *question = skip_name(queryptr);
      memcpy((void *)(& newdata_aligned),(void const *)question,
             sizeof(newdata_aligned));
      question = & newdata_aligned;
      tmp_4 = uip_htons(question->class);
      if (((int)tmp_4 & 0x7FFF) != 1) goto _LOR;
      else 
        if ((int)question->type != (int)((unsigned short)(((int)((unsigned short)255) << 8) | (
                                                          (int)((unsigned short)255) >> 8)))) 
          if ((int)question->type != (int)((unsigned short)(((int)((unsigned short)28) << 8) | (
                                                            (int)((unsigned short)28) >> 8)))) 
            _LOR:
            goto __Cont;
      tmp_5 = dns_name_isequal((unsigned char const *)queryptr,
                               (char const *)(resolv_hostname),
                               (unsigned char const *)uip_appdata);
      if (! tmp_5) goto __Cont;
      if ((int)mdns_state == MDNS_STATE_READY) {
        if ((int)((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->srcport == (int)((unsigned short)(
            ((int)((unsigned short)5353) << 8) | ((int)((unsigned short)5353) >> 8)))) 
          mdns_announce_requested();
        else {
          size_t tmp_6;
          ;
          ;
          tmp_6 = mdns_prep_host_announce_packet();
          ;
          ;
          uip_udp_packet_sendto(resolv_conn,(void const *)uip_appdata,
                                (int)tmp_6,
                                (uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr),
                                ((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->srcport);
        }
        goto return_label;
      }
      else {
        uint8_t nauthrr;
        uint16_t tmp_7;
        tmp_7 = uip_htons(hdr->numauthrr);
        nauthrr = (unsigned char)tmp_7;
        if (nauthrr) start_name_collision_check((unsigned long)1000);
      }
    }
    __Cont:
    { /* sequence */
      tmp_2 = skip_name(queryptr);
      queryptr = tmp_2 + sizeof(struct dns_question);
    }
    nquestions = (uint8_t)((int)nquestions - 1);
  }
  if ((int)nanswers == 0) goto return_label;
  if ((int)((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->srcport == (int)((unsigned short)(
      ((int)((unsigned short)5353) << 8) | ((int)((unsigned short)5353) >> 8)))) {
    if ((int)hdr->id == 0) {
      i = (signed char)(-1);
      namemapptr = (struct namemap *)0;
    }
    else goto _LAND;
  }
  else {
    _LAND:
    {
      unsigned long tmp_8;
      i = (signed char)0;
      while ((int)i < 4) {
        namemapptr = & names[i];
        if ((int)namemapptr->state == 3) 
          if ((int)namemapptr->id == (int)hdr->id) break;
        i = (int8_t)((int)i + 1);
      }
      if ((int)i >= 4) goto _LOR_0;
      else 
        if ((int)i < 0) goto _LOR_0;
        else 
          if ((int)namemapptr->state != 3) _LOR_0: goto return_label;
      namemapptr->state = (unsigned char)1;
      namemapptr->err = (unsigned char)((int)hdr->flags2 & 0x0f);
      tmp_8 = clock_seconds();
      namemapptr->expiration = tmp_8 + (unsigned long)30;
      if ((int)namemapptr->err != 0) {
        namemapptr->state = (unsigned char)1;
        resolv_found(namemapptr->name,(uip_ipaddr_t *)0);
        goto return_label;
      }
    }
  }
  i = (signed char)0;
  while ((int)nanswers > 0) {
    uint16_t tmp_10;
    uint16_t tmp_15;
    uint16_t tmp_16;
    unsigned long tmp_17;
    unsigned char *tmp_18;
    uint16_t tmp_19;
    ans = (struct dns_answer *)skip_name(queryptr);
    memcpy((void *)(& newdata_aligned_0),(void const *)ans,
           sizeof(newdata_aligned_0));
    ans = & newdata_aligned_0;
    tmp_10 = uip_htons(ans->class);
    if (((int)tmp_10 & 0x7FFF) != 1) goto _LOR_1;
    else 
      if ((int)ans->len != (int)((unsigned short)(((int)((unsigned short)sizeof(uip_ipaddr_t)) << 8) | (
                                                  (int)((unsigned short)sizeof(uip_ipaddr_t)) >> 8)))) 
        _LOR_1:
        goto skip_to_next_answer;
    if ((int)ans->type != (int)((unsigned short)(((int)((unsigned short)28) << 8) | (
                                                 (int)((unsigned short)28) >> 8)))) 
      goto skip_to_next_answer;
    if ((int)((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->srcport == (int)((unsigned short)(
        ((int)((unsigned short)5353) << 8) | ((int)((unsigned short)5353) >> 8)))) {
      if ((int)hdr->id == 0) {
        int8_t available_i = (signed char)4;
        i = (signed char)0;
        while ((int)i < 4) {
          {
            uint8_t tmp_11;
            namemapptr = & names[i];
            tmp_11 = dns_name_isequal((unsigned char const *)queryptr,
                                      (char const *)(namemapptr->name),
                                      (unsigned char const *)uip_appdata);
            if (tmp_11) break;
            if ((int)namemapptr->state == 0) goto _LOR_2;
            else 
              if ((int)namemapptr->state == 4) {
                unsigned long tmp_12;
                tmp_12 = clock_seconds();
                ;
                if (tmp_12 > namemapptr->expiration) _LOR_2: available_i = i;
              }
          }
          i = (int8_t)((int)i + 1);
        }
        if ((int)i == 4) {
          uint8_t tmp_13;
          i = available_i;
          namemapptr = & names[i];
          tmp_13 = decode_name((unsigned char const *)queryptr,
                               namemapptr->name,
                               (unsigned char const *)uip_appdata);
          if (! tmp_13) {
            namemapptr = (struct namemap *)0;
            goto skip_to_next_answer;
          }
        }
        if ((int)i == 4) {
          uint8_t tmp_14;
          tmp_14 = dns_name_isequal((unsigned char const *)queryptr,
                                    (char const *)(resolv_hostname),
                                    (unsigned char const *)uip_appdata);
          if (tmp_14) resolv_found(resolv_hostname,
                                   (uip_ipaddr_t *)(ans->ipaddr));
          namemapptr = (struct namemap *)0;
          goto skip_to_next_answer;
        }
        namemapptr = & names[i];
      }
      else goto _LAND_0;
    }
    else _LAND_0: nanswers = (unsigned char)1;
    namemapptr->state = (unsigned char)4;
    tmp_15 = uip_htons(ans->ttl[0]);
    tmp_16 = uip_htons(ans->ttl[1]);
    namemapptr->expiration = (unsigned long)(((unsigned int)tmp_15 << 16) | (unsigned int)tmp_16);
    tmp_17 = clock_seconds();
    namemapptr->expiration += tmp_17;
    namemapptr->ipaddr = *((uip_ipaddr_t *)(ans->ipaddr));
    resolv_found(namemapptr->name,& namemapptr->ipaddr);
    break;
    skip_to_next_answer:
    { /* sequence */
      tmp_18 = skip_name(queryptr);
      tmp_19 = uip_htons(ans->len);
      queryptr = (tmp_18 + 10) + (int)tmp_19;
    }
    nanswers = (uint8_t)((int)nanswers - 1);
  }
  if ((int)nanswers == 0) 
    if ((int)((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->srcport != (int)((unsigned short)(
        ((int)((unsigned short)5353) << 8) | ((int)((unsigned short)5353) >> 8)))) 
      if ((int)hdr->id != 0) {
        char tmp_20;
        tmp_20 = try_next_server(namemapptr);
        if (tmp_20) {
          namemapptr->state = (unsigned char)3;
          process_post(& resolv_process,(unsigned char)0x88,(void *)0);
        }
      }
  return_label: return;
}

void resolv_set_hostname(char const *hostname)
{
  size_t tmp_0;
  strncpy(resolv_hostname,hostname,(unsigned long)32);
  tmp_0 = strlen((char const *)(resolv_hostname));
  if (tmp_0 < (size_t)7) goto _LOR;
  else {
    int tmp_2;
    size_t tmp_1;
    tmp_1 = strlen((char const *)(resolv_hostname));
    tmp_2 = strcasecmp((char const *)(& resolv_hostname[tmp_1] - 6),".local");
    if (tmp_2 != 0) {
      _LOR:
      {
        size_t tmp;
        tmp = strlen((char const *)(resolv_hostname));
        strncat(resolv_hostname,".local",(size_t)32 - tmp);
      }
    }
  }
  start_name_collision_check((unsigned long)0);
  return;
}

char const *resolv_get_hostname(void)
{
  char const *__retres;
  __retres = (char const *)(resolv_hostname);
  return __retres;
}

static struct etimer process_thread_mdns_probe_process_delay;
static char process_thread_mdns_probe_process(struct pt *process_pt,
                                              process_event_t ev,
                                              process_data_t data)
{
  char __retres;
  {
    char PT_YIELD_FLAG = (char)1;
    if (PT_YIELD_FLAG) ;
    switch ((int)process_pt->lc) {
      unsigned short tmp;
      case 0: ;
      mdns_state = (unsigned char)MDNS_STATE_WAIT_BEFORE_PROBE;
      if ((void *)0 != data) {
        etimer_set(& process_thread_mdns_probe_process_delay,
                   *((clock_time_t *)data));
        PT_YIELD_FLAG = (char)0;
        process_pt->lc = (unsigned short)1098;
        case 1098: ;
        if ((int)PT_YIELD_FLAG == 0) goto _LOR;
        else 
          if (! ((int)ev == 0x88)) {
            _LOR: {
                    __retres = (char)1;
                    goto return_label;
                  }
          }
      }
      tmp = random_rand();
      etimer_set(& process_thread_mdns_probe_process_delay,
                 (unsigned long)((1000 * ((int)tmp & 0xFF)) / 1024));
      PT_YIELD_FLAG = (char)0;
      process_pt->lc = (unsigned short)1104;
      case 1104: ;
      if ((int)PT_YIELD_FLAG == 0) goto _LOR_0;
      else 
        if (! ((int)ev == 0x88)) {
          _LOR_0: {
                    __retres = (char)1;
                    goto return_label;
                  }
        }
      mdns_state = (unsigned char)MDNS_STATE_PROBING;
      resolv_query((char const *)(resolv_hostname));
      while (1) {
        int tmp_0;
        PT_YIELD_FLAG = (char)0;
        process_pt->lc = (unsigned short)1111;
        case 1111: ;
        if ((int)PT_YIELD_FLAG == 0) goto _LOR_1;
        else 
          if (! ((int)ev == (int)resolv_event_found)) {
            _LOR_1: {
                      __retres = (char)1;
                      goto return_label;
                    }
          }
        tmp_0 = strcasecmp((char const *)(resolv_hostname),
                           (char const *)data);
        if (! (tmp_0 != 0)) break;
      }
      mdns_state = (unsigned char)MDNS_STATE_READY;
      mdns_announce_requested();
    }
    PT_YIELD_FLAG = (char)0;
    process_pt->lc = (unsigned short)0;
    __retres = (char)3;
    goto return_label;
  }
  return_label: return __retres;
}

static char process_thread_resolv_process(struct pt *process_pt,
                                          process_event_t ev,
                                          process_data_t data)
{
  char __retres;
  {
    char PT_YIELD_FLAG = (char)1;
    if (PT_YIELD_FLAG) ;
    switch ((int)process_pt->lc) {
      case 0: ;
      memset((void *)(names),0,sizeof(names));
      resolv_event_found = process_alloc_event();
      resolv_conn = udp_new((uip_ipaddr_t const *)0,(unsigned short)0,
                            (void *)0);
      resolv_conn->lport = (unsigned short)(((int)((unsigned short)5353) << 8) | (
                                            (int)((unsigned short)5353) >> 8));
      uip_ds6_maddr_add(& resolv_mdns_addr);
      resolv_set_hostname("contiki");
      while (1) {
        PT_YIELD_FLAG = (char)0;
        process_pt->lc = (unsigned short)1148;
        case 1148: ;
        if ((int)PT_YIELD_FLAG == 0) {
          __retres = (char)1;
          goto return_label;
        }
        if ((int)ev == 0x88) tcpip_poll_udp(resolv_conn);
        else 
          if ((int)ev == (int)tcpip_event) 
            if (uip_udp_conn == resolv_conn) {
              if ((int)uip_flags & 2) newdata();
              if ((int)uip_flags & 8) 
                if (mdns_needs_host_announce) {
                  size_t len;
                  memset(uip_appdata,0,sizeof(struct dns_hdr));
                  len = mdns_prep_host_announce_packet();
                  uip_udp_packet_sendto(resolv_conn,
                                        (void const *)uip_appdata,(int)len,
                                        & resolv_mdns_addr,
                                        (unsigned short)(((int)((unsigned short)5353) << 8) | (
                                                         (int)((unsigned short)5353) >> 8)));
                  mdns_needs_host_announce = 0;
                  tcpip_poll_udp(resolv_conn);
                }
                else check_entries();
            }
        if (mdns_needs_host_announce) tcpip_poll_udp(resolv_conn);
      }
    }
    PT_YIELD_FLAG = (char)0;
    process_pt->lc = (unsigned short)0;
    __retres = (char)3;
    goto return_label;
  }
  return_label: return __retres;
}

static void init_1(void);

static uint8_t init_initialized = (unsigned char)0;
static void init_1(void)
{
  if (! init_initialized) {
    process_start(& resolv_process,(void *)0);
    init_initialized = (unsigned char)1;
  }
  return;
}

static char remove_trailing_dots_dns_name_without_dots[33];
static char const *remove_trailing_dots(char const *name)
{
  size_t len = strlen(name);
  if (len) 
    if ((int)*(name + (len - (size_t)1)) == '.') {
      strncpy(remove_trailing_dots_dns_name_without_dots,name,
              (unsigned long)32);
      while (1) {
        if (len) {
          if (! ((int)remove_trailing_dots_dns_name_without_dots[len - (size_t)1] == '.')) 
            break;
        }
        else break;
        len --;
        remove_trailing_dots_dns_name_without_dots[len] = (char)0;
      }
      name = (char const *)(remove_trailing_dots_dns_name_without_dots);
    }
  return name;
}

void resolv_query(char const *name)
{
  uint8_t i;
  uint8_t lseq;
  uint8_t lseqi;
  int tmp_4;
  register struct namemap *nameptr = (struct namemap *)0;
  init_1();
  lseqi = (unsigned char)0;
  lseq = lseqi;
  name = remove_trailing_dots(name);
  i = (unsigned char)0;
  while ((int)i < 4) {
    {
      int tmp;
      nameptr = & names[i];
      tmp = strcasecmp((char const *)(nameptr->name),name);
      if (0 == tmp) break;
      if ((int)nameptr->state == 0) goto _LOR;
      else 
        if ((int)nameptr->state == 4) {
          unsigned long tmp_0;
          tmp_0 = clock_seconds();
          ;
          if (tmp_0 > nameptr->expiration) {
            _LOR: {
                    lseqi = i;
                    lseq = (unsigned char)255;
                  }
          }
          else goto _LAND;
        }
        else {
          _LAND: ;
          if ((int)seqno - (int)nameptr->seqno > (int)lseq) {
            lseq = (unsigned char)((int)seqno - (int)nameptr->seqno);
            lseqi = i;
          }
        }
    }
    i = (uint8_t)((int)i + 1);
  }
  if ((int)i == 4) {
    i = lseqi;
    nameptr = & names[i];
  }
  memset((void *)nameptr,0,sizeof(*nameptr));
  strncpy(nameptr->name,name,sizeof(nameptr->name) - (unsigned long)1);
  nameptr->state = (unsigned char)2;
  nameptr->seqno = seqno;
  seqno = (uint8_t)((int)seqno + 1);
  {
    size_t name_len = strlen(name);
    char const local_suffix[6] =
      {(char)'l', (char)'o', (char)'c', (char)'a', (char)'l', (char)'\000'};
    if (name_len > sizeof(local_suffix) - (unsigned long)1) {
      int tmp_2;
      tmp_2 = strcasecmp((name + name_len) - (sizeof(local_suffix) - (unsigned long)1),
                         local_suffix);
      if (0 == tmp_2) nameptr->is_mdns = (int)1; else goto _LAND_0;
    }
    else _LAND_0: nameptr->is_mdns = (int)0;
  }
  if ((int)mdns_state == MDNS_STATE_PROBING) {
    int tmp_3;
    tmp_3 = strcmp((char const *)(nameptr->name),
                   (char const *)(resolv_hostname));
    if (0 == tmp_3) tmp_4 = 1; else tmp_4 = 0;
  }
  else tmp_4 = 0;
  nameptr->is_probe = (int)tmp_4;
  process_post(& resolv_process,(unsigned char)0x88,(void *)0);
  return;
}

resolv_status_t resolv_lookup(char const *name, uip_ipaddr_t **ipaddr)
{
  uint8_t i;
  struct namemap *nameptr;
  resolv_status_t ret = (unsigned char)RESOLV_STATUS_UNCACHED;
  name = remove_trailing_dots(name);
  i = (unsigned char)0;
  while ((int)i < 4) {
    {
      int tmp_1;
      nameptr = & names[i];
      tmp_1 = strcasecmp(name,(char const *)(nameptr->name));
      if (tmp_1 == 0) {
        switch ((int)nameptr->state) {
          unsigned long tmp;
          unsigned long tmp_0;
          case 4: ret = (unsigned char)RESOLV_STATUS_CACHED;
          tmp = clock_seconds();
          ;
          if (tmp > nameptr->expiration) ret = (unsigned char)RESOLV_STATUS_EXPIRED;
          break;
          case 2: case 3: ret = (unsigned char)RESOLV_STATUS_RESOLVING;
          break;
          case 1: ret = (unsigned char)RESOLV_STATUS_NOT_FOUND;
          tmp_0 = clock_seconds();
          ;
          if (tmp_0 > nameptr->expiration) ret = (unsigned char)RESOLV_STATUS_UNCACHED;
          break;
        }
        if (ipaddr) *ipaddr = & nameptr->ipaddr;
        break;
      }
    }
    i = (uint8_t)((int)i + 1);
  }
  return ret;
}

static void resolv_found(char *name, uip_ipaddr_t *ipaddr)
{
  int tmp_5;
  size_t tmp_4;
  tmp_4 = strlen((char const *)(resolv_hostname));
  ;
  tmp_5 = strncasecmp((char const *)(resolv_hostname),(char const *)name,
                      tmp_4);
  if (tmp_5 == 0) 
    if (ipaddr) {
      uip_ds6_addr_t *tmp_6;
      tmp_6 = uip_ds6_addr_lookup(ipaddr);
      if (tmp_6 != (uip_ds6_addr_t *)0) process_post((struct process *)0,
                                                     resolv_event_found,
                                                     (void *)name);
      else {
        uint8_t i;
        if ((int)mdns_state == MDNS_STATE_PROBING) {
          size_t tmp;
          size_t tmp_3;
          tmp = strlen((char const *)(resolv_hostname));
          resolv_hostname[tmp - (size_t)6] = (char)0;
          i = (unsigned char)0;
          while ((int)i < 3) {
            {
              int tmp_0;
              int tmp_1;
              size_t tmp_2;
              uint8_t val = uip_lladdr.addr[(8 - 3) + (int)i];
              char append_str[4] =
                {(char)'-', (char)'X', (char)'X', (char)'\000'};
              if (((int)val & 0xF) > 9) tmp_0 = 'a'; else tmp_0 = '0';
              append_str[2] = (char)(tmp_0 + ((int)val & 0xF));
              val = (unsigned char)((int)val >> 4);
              if (((int)val & 0xF) > 9) tmp_1 = 'a'; else tmp_1 = '0';
              append_str[1] = (char)(tmp_1 + ((int)val & 0xF));
              tmp_2 = strlen((char const *)(resolv_hostname));
              strncat(resolv_hostname,(char const *)(append_str),
                      (sizeof(resolv_hostname) - tmp_2) - (unsigned long)1);
            }
            i = (uint8_t)((int)i + 1);
          }
          tmp_3 = strlen((char const *)(resolv_hostname));
          strncat(resolv_hostname,".local",(size_t)32 - tmp_3);
          start_name_collision_check((unsigned long)(1000 * 5));
        }
        else 
          if ((int)mdns_state == MDNS_STATE_READY) start_name_collision_check
                                                   ((unsigned long)0);
      }
    }
    else process_post((struct process *)0,resolv_event_found,(void *)name);
  else process_post((struct process *)0,resolv_event_found,(void *)name);
  return;
}

__inline static unsigned int __bswap_32_69(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_69(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static uip_ipaddr_t serveraddr;
static uint32_t serverlifetime;
void uip_nameserver_update(uip_ipaddr_t const *nameserver, uint32_t lifetime)
{
  serveraddr = *nameserver;
  serverlifetime = lifetime;
  return;
}

uip_ipaddr_t *uip_nameserver_get(uint8_t num)
{
  uip_ipaddr_t *__retres;
  if ((int)num > 0) {
    __retres = (uip_ipaddr_t *)0;
    goto return_label;
  }
  __retres = & serveraddr;
  return_label: return __retres;
}

uint32_t uip_nameserver_next_expiration(void)
{
  return serverlifetime;
}

uint16_t uip_nameserver_count(void)
{
  uint16_t __retres;
  if ((int)serveraddr.u16[0] == 0) {
    if ((int)serveraddr.u16[1] == 0) {
      if ((int)serveraddr.u16[2] == 0) {
        if ((int)serveraddr.u16[3] == 0) {
          if ((int)serveraddr.u16[4] == 0) {
            if ((int)serveraddr.u16[5] == 0) {
              if ((int)serveraddr.u16[6] == 0) {
                if ((int)serveraddr.u16[7] == 0) {
                  __retres = (unsigned short)0;
                  goto return_label;
                }
                else goto _LAND_5;
              }
              else goto _LAND_5;
            }
            else goto _LAND_5;
          }
          else goto _LAND_5;
        }
        else goto _LAND_5;
      }
      else goto _LAND_5;
    }
    else goto _LAND_5;
  }
  else {
    _LAND_5: {
               __retres = (unsigned short)1;
               goto return_label;
             }
  }
  return_label: return __retres;
}

__inline static unsigned int __bswap_32_70(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_70(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static uint8_t nd6_opt_offset;
static uint8_t *nd6_opt_llao;
static uip_ds6_nbr_t *nbr;
static uip_ds6_addr_t *addr;
static int extract_lladdr_from_llao_aligned(uip_lladdr_t *dest)
{
  int __retres;
  if (dest != (uip_lladdr_t *)0) 
    if (nd6_opt_llao != (uint8_t *)0) {
      memcpy((void *)dest,(void const *)(nd6_opt_llao + 2),(unsigned long)8);
      __retres = 1;
      goto return_label;
    }
  __retres = 0;
  return_label: return __retres;
}

static void create_llao(uint8_t *llao, uint8_t type)
{
  *(llao + 0) = type;
  *(llao + 1) = (unsigned char)(16 >> 3);
  memcpy((void *)(llao + 2),(void const *)(& uip_lladdr),(unsigned long)8);
  memset((void *)(llao + (2 + 8)),0,(unsigned long)((16 - 2) - 8));
  return;
}

static void ns_input(void)
{
  uint8_t flags;
  uint16_t tmp_17;
  {
    int tmp;
    if (0 < curr_log_level_ipv6) tmp = 0; else tmp = curr_log_level_ipv6;
    if (3 <= tmp) {
      printf("[%-4s: %-10s] ","INFO","IPv6 NDP");
      printf("Received NS from ");
    }
  }
  {
    int tmp_0;
    if (0 < curr_log_level_ipv6) tmp_0 = 0; else tmp_0 = curr_log_level_ipv6;
    if (3 <= tmp_0) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr));
  }
  {
    int tmp_1;
    if (0 < curr_log_level_ipv6) tmp_1 = 0; else tmp_1 = curr_log_level_ipv6;
    if (3 <= tmp_1) printf(" to ");
  }
  {
    int tmp_2;
    if (0 < curr_log_level_ipv6) tmp_2 = 0; else tmp_2 = curr_log_level_ipv6;
    if (3 <= tmp_2) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
  }
  {
    int tmp_3;
    if (0 < curr_log_level_ipv6) tmp_3 = 0; else tmp_3 = curr_log_level_ipv6;
    if (3 <= tmp_3) printf(" with target address ");
  }
  {
    int tmp_4;
    if (0 < curr_log_level_ipv6) tmp_4 = 0; else tmp_4 = curr_log_level_ipv6;
    if (3 <= tmp_4) log_6addr((uip_ipaddr_t const *)(& ((uip_nd6_ns *)(
                              (& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4))->tgtipaddr));
  }
  {
    int tmp_5;
    if (0 < curr_log_level_ipv6) tmp_5 = 0; else tmp_5 = curr_log_level_ipv6;
    if (3 <= tmp_5) printf("\n");
  }
  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->ttl != 255) goto _LOR;
  else 
    if ((int)((uip_nd6_ns *)((& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4))->tgtipaddr.u8[0] == 0xFF) 
      goto _LOR;
    else 
      if ((int)((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->icode != 0) {
        _LOR:
        {
          {
            int tmp_6;
            if (0 < curr_log_level_ipv6) tmp_6 = 0;
            else tmp_6 = curr_log_level_ipv6;
            if (1 <= tmp_6) {
              printf("[%-4s: %-10s] ","ERR","IPv6 NDP");
              printf("NS received is bad\n");
            }
          }
          goto discard;
        }
      }
  nd6_opt_llao = (uint8_t *)0;
  nd6_opt_offset = (unsigned char)20;
  while (((40 + (int)uip_ext_len) + 4) + (int)nd6_opt_offset < (int)uip_len) {
    if ((int)((uip_nd6_opt_hdr *)(((& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4) + (int)nd6_opt_offset))->len == 0) {
      {
        int tmp_7;
        if (0 < curr_log_level_ipv6) tmp_7 = 0;
        else tmp_7 = curr_log_level_ipv6;
        if (1 <= tmp_7) {
          printf("[%-4s: %-10s] ","ERR","IPv6 NDP");
          printf("NS received is bad\n");
        }
      }
      goto discard;
    }
    switch ((int)((uip_nd6_opt_hdr *)(((& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4) + (int)nd6_opt_offset))->type) {
      case 1:
      nd6_opt_llao = & uip_aligned_buf.u8[((40 + (int)uip_ext_len) + 4) + (int)nd6_opt_offset];
      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[0] == 0) {
        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[1] == 0) {
          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[2] == 0) {
            if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[3] == 0) {
              if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[4] == 0) {
                if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[5] == 0) {
                  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[6] == 0) {
                    if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[7] == 0) {
                      {
                        int tmp_8;
                        if (0 < curr_log_level_ipv6) tmp_8 = 0;
                        else tmp_8 = curr_log_level_ipv6;
                        if (1 <= tmp_8) {
                          printf("[%-4s: %-10s] ","ERR","IPv6 NDP");
                          printf("NS received is bad\n");
                        }
                      }
                      goto discard;
                    }
                    else goto _LAND_5;
                  }
                  else goto _LAND_5;
                }
                else goto _LAND_5;
              }
              else goto _LAND_5;
            }
            else goto _LAND_5;
          }
          else goto _LAND_5;
        }
        else goto _LAND_5;
      }
      else {
        _LAND_5:
        {
          uip_lladdr_t lladdr_aligned;
          extract_lladdr_from_llao_aligned(& lladdr_aligned);
          nbr = uip_ds6_nbr_lookup((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr));
          if (nbr == (uip_ds6_nbr_t *)0) uip_ds6_nbr_add((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr),
                                                         (uip_lladdr_t const *)(& lladdr_aligned),
                                                         (unsigned char)0,
                                                         (unsigned char)2,
                                                         NBR_TABLE_REASON_IPV6_ND,
                                                         (void *)0);
          else {
            int tmp_11;
            uip_lladdr_t const *lladdr =
              uip_ds6_nbr_get_ll((uip_ds6_nbr_t const *)nbr);
            if (lladdr == (uip_lladdr_t const *)0) goto discard;
            tmp_11 = memcmp((void const *)(nd6_opt_llao + 2),
                            (void const *)lladdr,(unsigned long)8);
            if (tmp_11 != 0) {
              int tmp_10;
              tmp_10 = uip_ds6_nbr_update_ll(& nbr,
                                             (uip_lladdr_t const *)(& lladdr_aligned));
              if (tmp_10 < 0) goto discard;
              nbr->state = (unsigned char)2;
            }
            else 
              if ((int)nbr->state == 0) nbr->state = (unsigned char)2;
          }
        }
      }
      break;
      default:
      {
        int tmp_12;
        if (0 < curr_log_level_ipv6) tmp_12 = 0;
        else tmp_12 = curr_log_level_ipv6;
        if (2 <= tmp_12) {
          printf("[%-4s: %-10s] ","WARN","IPv6 NDP");
          printf("ND option not supported in NS");
        }
      }
      break;
    }
    nd6_opt_offset = (unsigned char)((int)nd6_opt_offset + ((int)((uip_nd6_opt_hdr *)(
                                                            ((& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4) + (int)nd6_opt_offset))->len << 3));
  }
  addr = uip_ds6_addr_lookup(& ((uip_nd6_ns *)((& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4))->tgtipaddr);
  if (addr != (uip_ds6_addr_t *)0) {
    uip_ds6_addr_t *tmp_14;
    uip_ds6_addr_t *tmp_16;
    if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[0] == 0) 
      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[1] == 0) 
        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[2] == 0) 
          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[3] == 0) 
            if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[4] == 0) 
              if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[5] == 0) 
                if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[6] == 0) 
                  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[7] == 0) 
                    goto discard;
    tmp_14 = uip_ds6_addr_lookup(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr);
    if (tmp_14 != (uip_ds6_addr_t *)0) {
      {
        int tmp_13;
        if (0 < curr_log_level_ipv6) tmp_13 = 0;
        else tmp_13 = curr_log_level_ipv6;
        if (1 <= tmp_13) {
          printf("[%-4s: %-10s] ","ERR","IPv6 NDP");
          printf("NS received is bad\n");
        }
      }
      goto discard;
    }
    if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[0] == 0xFF) 
      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[1] == 0x02) 
        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[1] == 0x00) 
          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[2] == 0x00) 
            if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[3] == 0x00) 
              if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[4] == 0x00) 
                if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[10] == 0x00) 
                  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[11] == 0x01) 
                    if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[12] == 0xFF) {
                      ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr;
                      ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr = ((uip_nd6_ns *)(
                      (& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4))->tgtipaddr;
                      flags = (unsigned char)(0x40 | 0x20);
                      goto create_na;
                    }
    tmp_16 = uip_ds6_addr_lookup(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr);
    ;
    if (tmp_16 == addr) {
      ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr;
      ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr = ((uip_nd6_ns *)(
      (& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4))->tgtipaddr;
      flags = (unsigned char)(0x40 | 0x20);
      goto create_na;
    }
    else {
      {
        int tmp_15;
        if (0 < curr_log_level_ipv6) tmp_15 = 0;
        else tmp_15 = curr_log_level_ipv6;
        if (1 <= tmp_15) {
          printf("[%-4s: %-10s] ","ERR","IPv6 NDP");
          printf("NS received is bad\n");
        }
      }
      goto discard;
    }
  }
  else goto discard;
  create_na: flags = (unsigned char)((int)flags | 0x80);
  uipbuf_clear();
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->vtc = (unsigned char)0x60;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->tcflow = (unsigned char)0;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->flow = (unsigned short)0;
  uipbuf_set_len_field((struct uip_ip_hdr *)(uip_aligned_buf.u8),
                       (unsigned short)((4 + 20) + 16));
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto = (unsigned char)58;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->ttl = (unsigned char)255;
  ((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->type = (unsigned char)136;
  ((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->icode = (unsigned char)0;
  ((uip_nd6_na *)((& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4))->flagsreserved = flags;
  memcpy((void *)(& ((uip_nd6_na *)((& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4))->tgtipaddr),
         (void const *)(& addr->ipaddr),sizeof(uip_ipaddr_t));
  create_llao(& uip_aligned_buf.u8[((40 + (int)uip_ext_len) + 4) + 20],
              (unsigned char)2);
  ((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->icmpchksum = (unsigned short)0;
  tmp_17 = uip_icmp6chksum();
  ((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->icmpchksum = (unsigned short)(~ ((int)tmp_17));
  uipbuf_set_len((unsigned short)(((40 + 4) + 20) + 16));
  {
    int tmp_18;
    if (0 < curr_log_level_ipv6) tmp_18 = 0;
    else tmp_18 = curr_log_level_ipv6;
    if (3 <= tmp_18) {
      printf("[%-4s: %-10s] ","INFO","IPv6 NDP");
      printf("Sending NA to ");
    }
  }
  {
    int tmp_19;
    if (0 < curr_log_level_ipv6) tmp_19 = 0;
    else tmp_19 = curr_log_level_ipv6;
    if (3 <= tmp_19) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
  }
  {
    int tmp_20;
    if (0 < curr_log_level_ipv6) tmp_20 = 0;
    else tmp_20 = curr_log_level_ipv6;
    if (3 <= tmp_20) printf(" from ");
  }
  {
    int tmp_21;
    if (0 < curr_log_level_ipv6) tmp_21 = 0;
    else tmp_21 = curr_log_level_ipv6;
    if (3 <= tmp_21) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr));
  }
  {
    int tmp_22;
    if (0 < curr_log_level_ipv6) tmp_22 = 0;
    else tmp_22 = curr_log_level_ipv6;
    if (3 <= tmp_22) printf(" with target address ");
  }
  {
    int tmp_23;
    if (0 < curr_log_level_ipv6) tmp_23 = 0;
    else tmp_23 = curr_log_level_ipv6;
    if (3 <= tmp_23) log_6addr((uip_ipaddr_t const *)(& ((uip_nd6_na *)(
                               (& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4))->tgtipaddr));
  }
  {
    int tmp_24;
    if (0 < curr_log_level_ipv6) tmp_24 = 0;
    else tmp_24 = curr_log_level_ipv6;
    if (3 <= tmp_24) printf("\n");
  }
  goto return_label;
  discard: uipbuf_clear();
  return_label: return;
}

static uip_icmp6_input_handler_t ns_input_handler =
  {.next = (struct uip_icmp6_input_handler *)0,
   .type = (unsigned char)135,
   .icode = (unsigned char)0xFF,
   .handler = & ns_input};
void uip_nd6_init(void)
{
  uip_icmp6_register_input_handler(& ns_input_handler);
  return;
}

__inline static unsigned int __bswap_32_71(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_71(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static char process_thread_udp_socket_process(struct pt *process_pt,
                                              process_event_t ev,
                                              process_data_t data);

struct process udp_socket_process =
  {.next = (struct process *)0,
   .name = "UDP socket process",
   .thread = & process_thread_udp_socket_process,
   .pt = {.lc = (unsigned short)0},
   .state = (unsigned char)0,
   .needspoll = (unsigned char)0};
static uint8_t buf[1280];
static void init_2(void);

static uint8_t init_inited = (unsigned char)0;
static void init_2(void)
{
  if (! init_inited) {
    init_inited = (unsigned char)1;
    process_start(& udp_socket_process,(void *)0);
  }
  return;
}

int udp_socket_register(struct udp_socket *c, void *ptr,
                        void (*input_callback)(struct udp_socket *c,
                                               void *ptr,
                                               uip_ipaddr_t const *source_addr,
                                               uint16_t source_port,
                                               uip_ipaddr_t const *dest_addr,
                                               uint16_t dest_port,
                                               uint8_t const *data,
                                               uint16_t datalen))
{
  int __retres;
  init_2();
  if (c == (struct udp_socket *)0) {
    __retres = -1;
    goto return_label;
  }
  c->ptr = ptr;
  c->input_callback = input_callback;
  c->p = process_current;
  {
    struct process *tmp_current = process_current;
    process_current = & udp_socket_process;
    c->udp_conn = udp_new((uip_ipaddr_t const *)0,(unsigned short)0,
                          (void *)c);
    process_current = tmp_current;
  }
  if (c->udp_conn == (struct uip_udp_conn *)0) {
    __retres = -1;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

int udp_socket_close(struct udp_socket *c)
{
  int __retres;
  if (c == (struct udp_socket *)0) {
    __retres = -1;
    goto return_label;
  }
  if (c->udp_conn != (struct uip_udp_conn *)0) {
    (c->udp_conn)->lport = (unsigned short)0;
    __retres = 1;
    goto return_label;
  }
  __retres = -1;
  return_label: return __retres;
}

int udp_socket_bind(struct udp_socket *c, uint16_t local_port)
{
  int __retres;
  if (c == (struct udp_socket *)0) goto _LOR;
  else 
    if (c->udp_conn == (struct uip_udp_conn *)0) {
      _LOR: {
              __retres = -1;
              goto return_label;
            }
    }
  (c->udp_conn)->lport = (unsigned short)(((int)local_port << 8) | ((int)local_port >> 8));
  __retres = 1;
  return_label: return __retres;
}

int udp_socket_connect(struct udp_socket *c, uip_ipaddr_t *remote_addr,
                       uint16_t remote_port)
{
  int __retres;
  if (c == (struct udp_socket *)0) goto _LOR;
  else 
    if (c->udp_conn == (struct uip_udp_conn *)0) {
      _LOR: {
              __retres = -1;
              goto return_label;
            }
    }
  if (remote_addr != (uip_ipaddr_t *)0) (c->udp_conn)->ripaddr = *remote_addr;
  (c->udp_conn)->rport = (unsigned short)(((int)remote_port << 8) | (
                                          (int)remote_port >> 8));
  __retres = 1;
  return_label: return __retres;
}

int udp_socket_send(struct udp_socket *c, void const *data, uint16_t datalen)
{
  int __retres;
  if (c == (struct udp_socket *)0) goto _LOR;
  else 
    if (c->udp_conn == (struct uip_udp_conn *)0) {
      _LOR: {
              __retres = -1;
              goto return_label;
            }
    }
  uip_udp_packet_send(c->udp_conn,data,(int)datalen);
  __retres = (int)datalen;
  return_label: return __retres;
}

int udp_socket_sendto(struct udp_socket *c, void const *data,
                      uint16_t datalen, uip_ipaddr_t const *to, uint16_t port)
{
  int __retres;
  if (c == (struct udp_socket *)0) goto _LOR;
  else 
    if (c->udp_conn == (struct uip_udp_conn *)0) {
      _LOR: {
              __retres = -1;
              goto return_label;
            }
    }
  if (c->udp_conn != (struct uip_udp_conn *)0) {
    uip_udp_packet_sendto(c->udp_conn,data,(int)datalen,to,
                          (unsigned short)(((int)port << 8) | ((int)port >> 8)));
    __retres = (int)datalen;
    goto return_label;
  }
  __retres = -1;
  return_label: return __retres;
}

static char process_thread_udp_socket_process(struct pt *process_pt,
                                              process_event_t ev,
                                              process_data_t data)
{
  char __retres;
  struct udp_socket *c;
  {
    char PT_YIELD_FLAG = (char)1;
    if (PT_YIELD_FLAG) ;
    switch ((int)process_pt->lc) {
      case 0: ;
      while (1) {
        PT_YIELD_FLAG = (char)0;
        process_pt->lc = (unsigned short)153;
        case 153: ;
        if ((int)PT_YIELD_FLAG == 0) {
          __retres = (char)1;
          goto return_label;
        }
        if ((int)ev == (int)tcpip_event) {
          c = (struct udp_socket *)data;
          if (c != (struct udp_socket *)0) 
            if ((int)uip_flags & 2) {
              memcpy((void *)(buf),(void const *)uip_appdata,
                     (unsigned long)uip_len);
              if (c->input_callback != (void (*)(struct udp_socket *c,
                                                 void *ptr,
                                                 uip_ipaddr_t const *source_addr,
                                                 uint16_t source_port,
                                                 uip_ipaddr_t const *dest_addr,
                                                 uint16_t dest_port,
                                                 uint8_t const *data,
                                                 uint16_t datalen))0) {
                {
                  struct process *tmp_current = process_current;
                  process_current = c->p;
                  (*(c->input_callback))(c,c->ptr,
                                         (uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr),
                                         (unsigned short)(((int)((struct uip_udp_hdr *)(
                                                           & uip_aligned_buf.u8[40] + (int)uip_ext_len))->srcport << 8) | (
                                                          (int)((struct uip_udp_hdr *)(
                                                          & uip_aligned_buf.u8[40] + (int)uip_ext_len))->srcport >> 8)),
                                         (uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr),
                                         (unsigned short)(((int)((struct uip_udp_hdr *)(
                                                           & uip_aligned_buf.u8[40] + (int)uip_ext_len))->destport << 8) | (
                                                          (int)((struct uip_udp_hdr *)(
                                                          & uip_aligned_buf.u8[40] + (int)uip_ext_len))->destport >> 8)),
                                         (uint8_t const *)(buf),uip_len);
                  process_current = tmp_current;
                }
              }
            }
        }
      }
    }
    PT_YIELD_FLAG = (char)0;
    process_pt->lc = (unsigned short)0;
    __retres = (char)3;
    goto return_label;
  }
  return_label: return __retres;
}

__inline static unsigned int __bswap_32_72(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_72(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static char process_thread_simple_udp_process(struct pt *process_pt,
                                              process_event_t ev,
                                              process_data_t data);

struct process simple_udp_process =
  {.next = (struct process *)0,
   .name = "Simple UDP process",
   .thread = & process_thread_simple_udp_process,
   .pt = {.lc = (unsigned short)0},
   .state = (unsigned char)0,
   .needspoll = (unsigned char)0};
static uint8_t started = (unsigned char)0;
static uint8_t databuffer[1280];
static void init_simple_udp(void)
{
  if ((int)started == 0) {
    process_start(& simple_udp_process,(void *)0);
    started = (unsigned char)1;
  }
  return;
}

int simple_udp_send(struct simple_udp_connection *c, void const *data,
                    uint16_t datalen)
{
  int __retres;
  if (c->udp_conn != (struct uip_udp_conn *)0) uip_udp_packet_sendto(c->udp_conn,
                                                                    data,
                                                                    (int)datalen,
                                                                    (uip_ipaddr_t const *)(& c->remote_addr),
                                                                    (unsigned short)(
                                                                    (
                                                                    (int)c->remote_port << 8) | (
                                                                    (int)c->remote_port >> 8)));
  __retres = 0;
  return __retres;
}

int simple_udp_sendto(struct simple_udp_connection *c, void const *data,
                      uint16_t datalen, uip_ipaddr_t const *to)
{
  int __retres;
  if (c->udp_conn != (struct uip_udp_conn *)0) uip_udp_packet_sendto(c->udp_conn,
                                                                    data,
                                                                    (int)datalen,
                                                                    to,
                                                                    (unsigned short)(
                                                                    (
                                                                    (int)c->remote_port << 8) | (
                                                                    (int)c->remote_port >> 8)));
  __retres = 0;
  return __retres;
}

int simple_udp_sendto_port(struct simple_udp_connection *c, void const *data,
                           uint16_t datalen, uip_ipaddr_t const *to,
                           uint16_t port)
{
  int __retres;
  if (c->udp_conn != (struct uip_udp_conn *)0) uip_udp_packet_sendto(c->udp_conn,
                                                                    data,
                                                                    (int)datalen,
                                                                    to,
                                                                    (unsigned short)(
                                                                    (
                                                                    (int)port << 8) | (
                                                                    (int)port >> 8)));
  __retres = 0;
  return __retres;
}

int simple_udp_register(struct simple_udp_connection *c, uint16_t local_port,
                        uip_ipaddr_t *remote_addr, uint16_t remote_port,
                        void (*receive_callback)(struct simple_udp_connection *c,
                                                 uip_ipaddr_t const *source_addr,
                                                 uint16_t source_port,
                                                 uip_ipaddr_t const *dest_addr,
                                                 uint16_t dest_port,
                                                 uint8_t const *data,
                                                 uint16_t datalen))
{
  int __retres;
  init_simple_udp();
  c->local_port = local_port;
  c->remote_port = remote_port;
  if (remote_addr != (uip_ipaddr_t *)0) c->remote_addr = *remote_addr;
  c->receive_callback = receive_callback;
  {
    struct process *tmp_current = process_current;
    process_current = & simple_udp_process;
    c->udp_conn = udp_new((uip_ipaddr_t const *)remote_addr,
                          (unsigned short)(((int)remote_port << 8) | (
                                           (int)remote_port >> 8)),(void *)c);
    if (c->udp_conn != (struct uip_udp_conn *)0) 
      if (local_port) (c->udp_conn)->lport = (unsigned short)(((int)local_port << 8) | (
                                                              (int)local_port >> 8));
    process_current = tmp_current;
  }
  if (c->udp_conn == (struct uip_udp_conn *)0) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static char process_thread_simple_udp_process(struct pt *process_pt,
                                              process_event_t ev,
                                              process_data_t data)
{
  char __retres;
  struct simple_udp_connection *c;
  {
    char PT_YIELD_FLAG = (char)1;
    if (PT_YIELD_FLAG) ;
    switch ((int)process_pt->lc) {
      case 0: ;
      while (1) {
        PT_YIELD_FLAG = (char)0;
        process_pt->lc = (unsigned short)137;
        case 137: ;
        if ((int)PT_YIELD_FLAG == 0) {
          __retres = (char)1;
          goto return_label;
        }
        if ((int)ev == (int)tcpip_event) {
          c = (struct simple_udp_connection *)data;
          if (c != (struct simple_udp_connection *)0) 
            if ((int)uip_flags & 2) {
              memcpy((void *)(databuffer),(void const *)uip_appdata,
                     (unsigned long)uip_len);
              if (c->receive_callback != (void (*)(struct simple_udp_connection *c,
                                                   uip_ipaddr_t const *source_addr,
                                                   uint16_t source_port,
                                                   uip_ipaddr_t const *dest_addr,
                                                   uint16_t dest_port,
                                                   uint8_t const *data,
                                                   uint16_t datalen))0) {
                {
                  struct process *tmp_current = process_current;
                  process_current = c->client_process;
                  (*(c->receive_callback))(c,
                                           (uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr),
                                           (unsigned short)(((int)((struct uip_udp_hdr *)(
                                                             & uip_aligned_buf.u8[40] + (int)uip_ext_len))->srcport << 8) | (
                                                            (int)((struct uip_udp_hdr *)(
                                                            & uip_aligned_buf.u8[40] + (int)uip_ext_len))->srcport >> 8)),
                                           (uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr),
                                           (unsigned short)(((int)((struct uip_udp_hdr *)(
                                                             & uip_aligned_buf.u8[40] + (int)uip_ext_len))->destport << 8) | (
                                                            (int)((struct uip_udp_hdr *)(
                                                            & uip_aligned_buf.u8[40] + (int)uip_ext_len))->destport >> 8)),
                                           (uint8_t const *)(databuffer),
                                           uip_len);
                  process_current = tmp_current;
                }
              }
            }
        }
      }
    }
    PT_YIELD_FLAG = (char)0;
    process_pt->lc = (unsigned short)0;
    __retres = (char)3;
    goto return_label;
  }
  return_label: return __retres;
}

__inline static unsigned int __bswap_32_73(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_73(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

int sicslowpan_get_last_rssi(void);

struct network_driver const sicslowpan_driver;

static uint8_t *packetbuf_ptr;
static uint8_t packetbuf_hdr_len;
static int packetbuf_payload_len;
static uint8_t uncomp_hdr_len;
static int mac_max_payload;
static uint8_t curr_page;
static int last_tx_status;
static int last_rssi;
static uint16_t my_tag;
static struct sicslowpan_frag_info frag_info[2];
static struct sicslowpan_frag_buf frag_buf[12];
static int clear_fragments(uint8_t frag_info_index)
{
  int i;
  int clear_count;
  clear_count = 0;
  frag_info[frag_info_index].len = (unsigned short)0;
  i = 0;
  while (i < 12) {
    if ((int)frag_buf[i].len > 0) 
      if ((int)frag_buf[i].index == (int)frag_info_index) {
        frag_buf[i].len = (unsigned char)0;
        clear_count ++;
      }
    i ++;
  }
  return clear_count;
}

static int timeout_fragments(int not_context)
{
  int i;
  int count = 0;
  i = 0;
  while (i < 2) {
    if ((int)frag_info[i].len > 0) 
      if (i != not_context) {
        int tmp_0;
        tmp_0 = timer_expired(& frag_info[i].reass_timer);
        if (tmp_0) {
          int tmp;
          tmp = clear_fragments((unsigned char)i);
          count += tmp;
        }
      }
    i ++;
  }
  return count;
}

static int store_fragment(uint8_t index_0, uint8_t offset)
{
  int __retres;
  int i;
  i = 0;
  while (i < 12) {
    if ((int)frag_buf[i].len == 0) {
      uint16_t tmp;
      uint16_t tmp_0;
      frag_buf[i].offset = offset;
      tmp = packetbuf_datalen();
      frag_buf[i].len = (unsigned char)((int)tmp - (int)packetbuf_hdr_len);
      frag_buf[i].index = index_0;
      tmp_0 = packetbuf_datalen();
      ;
      ;
      ;
      memcpy((void *)(frag_buf[i].data),
             (void const *)(packetbuf_ptr + (int)packetbuf_hdr_len),
             (unsigned long)((int)tmp_0 - (int)packetbuf_hdr_len));
      __retres = (int)frag_buf[i].len;
      goto return_label;
    }
    i ++;
  }
  __retres = -1;
  return_label: return __retres;
}

static int8_t add_fragment(uint16_t tag, uint16_t frag_size, uint8_t offset)
{
  int8_t __retres;
  int i;
  int len;
  int8_t found = (signed char)(-1);
  if ((int)offset == 0) {
    linkaddr_t const *tmp_1;
    i = 0;
    while (i < 2) {
      if ((int)frag_info[i].len > 0) {
        int tmp;
        tmp = timer_expired(& frag_info[i].reass_timer);
        if (tmp) clear_fragments((unsigned char)i);
      }
      if ((int)found < 0) 
        if ((int)frag_info[i].len == 0) found = (signed char)i;
      i ++;
    }
    if ((int)found < 0) {
      {
        int tmp_0;
        if (0 < curr_log_level_6lowpan) tmp_0 = 0;
        else tmp_0 = curr_log_level_6lowpan;
        if (2 <= tmp_0) {
          printf("[%-4s: %-10s] ","WARN","6LoWPAN");
          printf("reassembly: failed to store new fragment session - tag: %d\n",
                 (int)tag);
        }
      }
      __retres = (signed char)(-1);
      goto return_label;
    }
    frag_info[found].len = frag_size;
    frag_info[found].tag = tag;
    tmp_1 = packetbuf_addr((unsigned char)PACKETBUF_ADDR_SENDER);
    ;
    linkaddr_copy(& frag_info[found].sender,tmp_1);
    timer_set(& frag_info[found].reass_timer,
              (unsigned long)((8 * 1000) / 16));
    __retres = found;
    goto return_label;
  }
  i = 0;
  while (i < 2) {
    if ((int)frag_info[i].tag == (int)tag) 
      if ((int)frag_info[i].len > 0) {
        int tmp_3;
        linkaddr_t const *tmp_2;
        tmp_2 = packetbuf_addr((unsigned char)PACKETBUF_ADDR_SENDER);
        ;
        tmp_3 = linkaddr_cmp((linkaddr_t const *)(& frag_info[i].sender),
                             tmp_2);
        if (tmp_3) {
          found = (signed char)i;
          break;
        }
      }
    i ++;
  }
  if ((int)found < 0) {
    {
      int tmp_4;
      if (0 < curr_log_level_6lowpan) tmp_4 = 0;
      else tmp_4 = curr_log_level_6lowpan;
      if (2 <= tmp_4) {
        printf("[%-4s: %-10s] ","WARN","6LoWPAN");
        printf("reassembly: failed to store N-fragment - could not find session - tag: %d offset: %d\n",
               (int)tag,(int)offset);
      }
    }
    __retres = (signed char)(-1);
    goto return_label;
  }
  len = store_fragment((unsigned char)i,offset);
  if (len < 0) {
    int tmp_5;
    tmp_5 = timeout_fragments(i);
    if (tmp_5 > 0) len = store_fragment((unsigned char)i,offset);
  }
  if (len > 0) {
    frag_info[i].reassembled_len = (unsigned short)((int)frag_info[i].reassembled_len + len);
    __retres = (signed char)i;
    goto return_label;
  }
  else {
    {
      int tmp_6;
      if (0 < curr_log_level_6lowpan) tmp_6 = 0;
      else tmp_6 = curr_log_level_6lowpan;
      if (2 <= tmp_6) {
        printf("[%-4s: %-10s] ","WARN","6LoWPAN");
        printf("reassembly: failed to store fragment - packet reassembly will fail tag:%d l\n",
               (int)frag_info[i].tag);
      }
    }
    __retres = (signed char)(-1);
    goto return_label;
  }
  return_label: return __retres;
}

static void copy_frags2uip(int context_0)
{
  int i;
  memcpy((void *)(uip_aligned_buf.u8),
         (void const *)(frag_info[context_0].first_frag),
         (unsigned long)frag_info[context_0].first_frag_len);
  i = 0;
  while (i < 12) {
    if ((int)frag_buf[i].len > 0) 
      if ((int)frag_buf[i].index == context_0) memcpy((void *)(& uip_aligned_buf.u8[(unsigned short)(
                                                      (int)frag_buf[i].offset << 3)]),
                                                      (void const *)(frag_buf[i].data),
                                                      (unsigned long)frag_buf[i].len);
    i ++;
  }
  clear_fragments((unsigned char)context_0);
  return;
}

static struct netstack_sniffer *callback = (struct netstack_sniffer *)0;
void netstack_sniffer_add(struct netstack_sniffer *s)
{
  callback = s;
  return;
}

void netstack_sniffer_remove(struct netstack_sniffer *s)
{
  callback = (struct netstack_sniffer *)0;
  return;
}

static void set_packet_attrs(void)
{
  int c = 0;
  packetbuf_set_attr((unsigned char)PACKETBUF_ATTR_NETWORK_ID,
                     (unsigned short)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto);
  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto == 17) {
    c = (int)((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40 + 0]))->srcport;
    if ((int)((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40 + 0]))->destport < c) 
      c = (int)((struct uip_udp_hdr *)(& uip_aligned_buf.u8[40 + 0]))->destport;
  }
  else 
    if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto == 6) {
      c = (int)((struct uip_tcp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->srcport;
      if ((int)((struct uip_tcp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->destport < c) 
        c = (int)((struct uip_tcp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->destport;
    }
    else 
      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto == 58) 
        c = ((int)((struct uip_icmp_hdr *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len))->type << 8) | (int)((struct uip_icmp_hdr *)(
            & uip_aligned_buf.u8[40] + (int)uip_ext_len))->icode;
  packetbuf_set_attr((unsigned char)PACKETBUF_ATTR_CHANNEL,(unsigned short)c);
  return;
}

static struct sicslowpan_addr_context addr_contexts[1];
static struct sicslowpan_addr_context *context;
static uint8_t *hc06_ptr;
uint8_t const unc_llconf[4] =
  {(unsigned char)0x0f,
   (unsigned char)0x28,
   (unsigned char)0x22,
   (unsigned char)0x20};
uint8_t const unc_ctxconf[4] =
  {(unsigned char)0x00,
   (unsigned char)0x88,
   (unsigned char)0x82,
   (unsigned char)0x80};
uint8_t const unc_mxconf[4] =
  {(unsigned char)0x0f,
   (unsigned char)0x25,
   (unsigned char)0x23,
   (unsigned char)0x21};
uint8_t const llprefix[2] = {(unsigned char)0xfe, (unsigned char)0x80};
static uint8_t const ttl_values[4] =
  {(unsigned char)0, (unsigned char)1, (unsigned char)64, (unsigned char)255};
static struct sicslowpan_addr_context *addr_context_lookup_by_prefix(
uip_ipaddr_t *ipaddr)
{
  struct sicslowpan_addr_context *__retres;
  int i;
  i = 0;
  while (i < 1) {
    if ((int)addr_contexts[i].used == 1) {
      int tmp;
      tmp = memcmp((void const *)(& addr_contexts[i].prefix),
                   (void const *)ipaddr,(unsigned long)(64 >> 3));
      if (tmp == 0) {
        __retres = & addr_contexts[i];
        goto return_label;
      }
    }
    i ++;
  }
  __retres = (struct sicslowpan_addr_context *)0;
  return_label: return __retres;
}

static struct sicslowpan_addr_context *addr_context_lookup_by_number(
uint8_t number)
{
  struct sicslowpan_addr_context *__retres;
  int i;
  i = 0;
  while (i < 1) {
    if ((int)addr_contexts[i].used == 1) 
      if ((int)addr_contexts[i].number == (int)number) {
        __retres = & addr_contexts[i];
        goto return_label;
      }
    i ++;
  }
  __retres = (struct sicslowpan_addr_context *)0;
  return_label: return __retres;
}

static uint8_t compress_addr_64(uint8_t bitpos, uip_ipaddr_t *ipaddr,
                                uip_lladdr_t *lladdr)
{
  uint8_t __retres;
  if ((int)ipaddr->u8[8] == ((int)lladdr->addr[0] ^ 0x02)) {
    if ((int)ipaddr->u8[9] == (int)lladdr->addr[1]) {
      if ((int)ipaddr->u8[10] == (int)lladdr->addr[2]) {
        if ((int)ipaddr->u8[11] == (int)lladdr->addr[3]) {
          if ((int)ipaddr->u8[12] == (int)lladdr->addr[4]) {
            if ((int)ipaddr->u8[13] == (int)lladdr->addr[5]) {
              if ((int)ipaddr->u8[14] == (int)lladdr->addr[6]) {
                if ((int)ipaddr->u8[15] == (int)lladdr->addr[7]) {
                  __retres = (unsigned char)(3 << (int)bitpos);
                  goto return_label;
                }
                else goto _LAND_9;
              }
              else goto _LAND_9;
            }
            else goto _LAND_9;
          }
          else goto _LAND_9;
        }
        else goto _LAND_9;
      }
      else goto _LAND_9;
    }
    else goto _LAND_9;
  }
  else {
    _LAND_9: ;
    if ((int)ipaddr->u16[4] == 0) {
      if ((int)ipaddr->u8[10] == 0) {
        if ((int)ipaddr->u8[11] == 0xff) {
          if ((int)ipaddr->u8[12] == 0xfe) {
            if ((int)ipaddr->u8[13] == 0) {
              memcpy((void *)hc06_ptr,(void const *)(& ipaddr->u16[7]),
                     (unsigned long)2);
              hc06_ptr += 2;
              __retres = (unsigned char)(2 << (int)bitpos);
              goto return_label;
            }
            else goto _LAND_2;
          }
          else goto _LAND_2;
        }
        else goto _LAND_2;
      }
      else goto _LAND_2;
    }
    else {
      _LAND_2:
      {
        memcpy((void *)hc06_ptr,(void const *)(& ipaddr->u16[4]),
               (unsigned long)8);
        hc06_ptr += 8;
        __retres = (unsigned char)(1 << (int)bitpos);
        goto return_label;
      }
    }
  }
  return_label: return __retres;
}

static void uncompress_addr(uip_ipaddr_t *ipaddr, uint8_t const *prefix,
                            uint8_t pref_post_count, uip_lladdr_t *lladdr)
{
  uint8_t prefcount = (unsigned char)((int)pref_post_count >> 4);
  uint8_t postcount = (unsigned char)((int)pref_post_count & 0x0f);
  if ((int)prefcount == 15) prefcount = (unsigned char)16;
  else prefcount = prefcount;
  if ((int)postcount == 15) postcount = (unsigned char)16;
  else postcount = postcount;
  {
    int tmp;
    if (0 < curr_log_level_6lowpan) tmp = 0;
    else tmp = curr_log_level_6lowpan;
    if (4 <= tmp) {
      printf("[%-4s: %-10s] ","DBG","6LoWPAN");
      printf("uncompression: address %d %d",(int)prefcount,(int)postcount);
    }
  }
  if ((int)prefcount > 0) memcpy((void *)ipaddr,(void const *)prefix,
                                 (unsigned long)prefcount);
  if ((int)prefcount + (int)postcount < 16) memset((void *)(& ipaddr->u8[prefcount]),
                                                   0,
                                                   (unsigned long)(16 - (
                                                                   (int)prefcount + (int)postcount)));
  if ((int)postcount > 0) {
    memcpy((void *)(& ipaddr->u8[16 - (int)postcount]),
           (void const *)hc06_ptr,(unsigned long)postcount);
    if ((int)postcount == 2) 
      if ((int)prefcount < 11) {
        ipaddr->u8[11] = (unsigned char)0xff;
        ipaddr->u8[12] = (unsigned char)0xfe;
      }
    hc06_ptr += (int)postcount;
  }
  else 
    if ((int)prefcount > 0) uip_ds6_set_addr_iid(ipaddr,lladdr);
  {
    int tmp_0;
    if (0 < curr_log_level_6lowpan) tmp_0 = 0;
    else tmp_0 = curr_log_level_6lowpan;
    if (4 <= tmp_0) log_6addr((uip_ipaddr_t const *)ipaddr);
  }
  {
    int tmp_1;
    if (0 < curr_log_level_6lowpan) tmp_1 = 0;
    else tmp_1 = curr_log_level_6lowpan;
    if (4 <= tmp_1) printf("\n");
  }
  return;
}

static int compress_hdr_iphc(linkaddr_t *link_destaddr)
{
  int __retres;
  uint8_t tmp;
  uint8_t iphc0;
  uint8_t iphc1;
  uint8_t *next_hdr;
  uint8_t *next_nhc;
  int ext_hdr_len;
  struct uip_udp_hdr *udp_buf;
  int tmp_3;
  struct sicslowpan_addr_context *tmp_6;
  int tmp_36;
  if (0 < curr_log_level_6lowpan) tmp_3 = 0;
  else tmp_3 = curr_log_level_6lowpan;
  if (tmp_3 >= 4) {
    uint16_t ndx;
    {
      int tmp_0;
      if (0 < curr_log_level_6lowpan) tmp_0 = 0;
      else tmp_0 = curr_log_level_6lowpan;
      if (4 <= tmp_0) {
        printf("[%-4s: %-10s] ","DBG","6LoWPAN");
        printf("compression: before (%d): ",
               (int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->len[1]);
      }
    }
    ndx = (unsigned short)0;
    while ((int)ndx < (int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->len[1] + 40) {
      {
        uint8_t data = uip_aligned_buf.u8[ndx];
        {
          int tmp_1;
          if (0 < curr_log_level_6lowpan) tmp_1 = 0;
          else tmp_1 = curr_log_level_6lowpan;
          if (4 <= tmp_1) printf("%02x",(int)data);
        }
      }
      ndx = (uint16_t)((int)ndx + 1);
    }
    {
      int tmp_2;
      if (0 < curr_log_level_6lowpan) tmp_2 = 0;
      else tmp_2 = curr_log_level_6lowpan;
      if (4 <= tmp_2) printf("\n");
    }
  }
  hc06_ptr = (packetbuf_ptr + (int)packetbuf_hdr_len) + 2;
  if (hc06_ptr + 38 >= packetbuf_ptr + mac_max_payload) {
    {
      int tmp_4;
      if (0 < curr_log_level_6lowpan) tmp_4 = 0;
      else tmp_4 = curr_log_level_6lowpan;
      if (2 <= tmp_4) {
        printf("[%-4s: %-10s] ","WARN","6LoWPAN");
        printf("Not enough packetbuf space to compress header (%u bytes, %u left). Aborting.\n",
               (unsigned int)38,
               (unsigned int)((packetbuf_ptr + mac_max_payload) - hc06_ptr));
      }
    }
    __retres = 0;
    goto return_label;
  }
  iphc0 = (unsigned char)0x60;
  iphc1 = (unsigned char)0;
  *((packetbuf_ptr + (int)packetbuf_hdr_len) + 2) = (unsigned char)0;
  tmp_6 = addr_context_lookup_by_prefix(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr);
  if (tmp_6 != (struct sicslowpan_addr_context *)0) goto _LOR;
  else {
    struct sicslowpan_addr_context *tmp_7;
    tmp_7 = addr_context_lookup_by_prefix(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr);
    if (tmp_7 != (struct sicslowpan_addr_context *)0) {
      _LOR:
      {
        {
          int tmp_5;
          if (0 < curr_log_level_6lowpan) tmp_5 = 0;
          else tmp_5 = curr_log_level_6lowpan;
          if (4 <= tmp_5) {
            printf("[%-4s: %-10s] ","DBG","6LoWPAN");
            printf("compression: dest or src ipaddr - setting CID\n");
          }
        }
        iphc1 = (unsigned char)((int)iphc1 | 0x80);
        hc06_ptr ++;
      }
    }
  }
  tmp = (unsigned char)(((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->vtc << 4) | (
                        (int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->tcflow >> 4));
  tmp = (unsigned char)((((int)tmp & 0x03) << 6) | ((int)tmp >> 2));
  if (((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->tcflow & 0x0F) == 0) {
    if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->flow == 0) {
      iphc0 = (unsigned char)((int)iphc0 | 0x10);
      if (((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->vtc & 0x0F) == 0) {
        if (((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->tcflow & 0xF0) == 0) 
          iphc0 = (unsigned char)((int)iphc0 | 0x08);
        else goto _LAND;
      }
      else {
        _LAND: {
                 *hc06_ptr = tmp;
                 hc06_ptr ++;
               }
      }
    }
    else goto _LAND_1;
  }
  else 
    _LAND_1:
    if (((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->vtc & 0x0F) == 0) {
      if (((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->tcflow & 0xF0) == 0) {
        iphc0 = (unsigned char)((int)iphc0 | 0x08);
        *hc06_ptr = (unsigned char)(((int)tmp & 0xc0) | ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->tcflow & 0x0F));
        memcpy((void *)(hc06_ptr + 1),
               (void const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->flow),
               (unsigned long)2);
        hc06_ptr += 3;
      }
      else goto _LAND_0;
    }
    else {
      _LAND_0:
      {
        memcpy((void *)hc06_ptr,
               (void const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->vtc),
               (unsigned long)4);
        *hc06_ptr = tmp;
        hc06_ptr += 4;
      }
    }
  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto == 17) 
    goto _LOR_0;
  else 
    if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto == 0) 
      goto _LOR_0;
    else 
      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto == 60) 
        goto _LOR_0;
      else 
        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto == 43) 
          goto _LOR_0;
        else 
          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto == 44) 
            _LOR_0:
            iphc0 = (unsigned char)((int)iphc0 | 0x04);
  if (((int)iphc0 & 0x04) == 0) {
    *hc06_ptr = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto;
    hc06_ptr ++;
  }
  switch ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->ttl) {
    case 1: iphc0 = (unsigned char)((int)iphc0 | 0x01);
    break;
    case 64: iphc0 = (unsigned char)((int)iphc0 | 0x02);
    break;
    case 255: iphc0 = (unsigned char)((int)iphc0 | 0x03);
    break;
    default: *hc06_ptr = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->ttl;
    hc06_ptr ++;
    break;
  }
  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[0] == 0) {
    if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[1] == 0) {
      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[2] == 0) {
        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[3] == 0) {
          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[4] == 0) {
            if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[5] == 0) {
              if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[6] == 0) {
                if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[7] == 0) {
                  {
                    int tmp_8;
                    if (0 < curr_log_level_6lowpan) tmp_8 = 0;
                    else tmp_8 = curr_log_level_6lowpan;
                    if (4 <= tmp_8) {
                      printf("[%-4s: %-10s] ","DBG","6LoWPAN");
                      printf("compression: addr unspecified - setting SAC\n");
                    }
                  }
                  iphc1 = (unsigned char)((int)iphc1 | 0x40);
                  iphc1 = (unsigned char)((int)iphc1 | 0x00);
                }
                else goto _LAND_12;
              }
              else goto _LAND_12;
            }
            else goto _LAND_12;
          }
          else goto _LAND_12;
        }
        else goto _LAND_12;
      }
      else goto _LAND_12;
    }
    else goto _LAND_12;
  }
  else {
    _LAND_12:
    context = addr_context_lookup_by_prefix(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr);
    if (context != (struct sicslowpan_addr_context *)0) {
      uint8_t tmp_10;
      {
        int tmp_9;
        if (0 < curr_log_level_6lowpan) tmp_9 = 0;
        else tmp_9 = curr_log_level_6lowpan;
        if (4 <= tmp_9) {
          printf("[%-4s: %-10s] ","DBG","6LoWPAN");
          printf("compression: src with context - setting CID & SAC ctx: %d\n",
                 (int)context->number);
        }
      }
      iphc1 = (unsigned char)((int)iphc1 | (0x80 | 0x40));
      *((packetbuf_ptr + (int)packetbuf_hdr_len) + 2) = (unsigned char)(
      (int)*((packetbuf_ptr + (int)packetbuf_hdr_len) + 2) | ((int)context->number << 4));
      tmp_10 = compress_addr_64((unsigned char)4,
                                & ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr,
                                & uip_lladdr);
      iphc1 = (unsigned char)((int)iphc1 | (int)tmp_10);
    }
    else 
      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u8[0] == 0xfe) {
        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u8[1] == 0x80) {
          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[1] == 0) {
            if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[2] == 0) {
              if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[3] == 0) {
                uint8_t tmp_11;
                tmp_11 = compress_addr_64((unsigned char)4,
                                          & ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr,
                                          & uip_lladdr);
                iphc1 = (unsigned char)((int)iphc1 | (int)tmp_11);
              }
              else goto _LAND_5;
            }
            else goto _LAND_5;
          }
          else goto _LAND_5;
        }
        else goto _LAND_5;
      }
      else {
        _LAND_5:
        {
          iphc1 = (unsigned char)((int)iphc1 | 0x00);
          memcpy((void *)hc06_ptr,
                 (void const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr.u16[0]),
                 (unsigned long)16);
          hc06_ptr += 16;
        }
      }
  }
  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[0] == 0xFF) {
    iphc1 = (unsigned char)((int)iphc1 | 0x08);
    if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[1] == 2) {
      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[1] == 0) {
        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[2] == 0) {
          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[3] == 0) {
            if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[4] == 0) {
              if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[5] == 0) {
                if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[6] == 0) {
                  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[14] == 0) {
                    iphc1 = (unsigned char)((int)iphc1 | 0x03);
                    *hc06_ptr = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[15];
                    hc06_ptr ++;
                  }
                  else goto _LAND_28;
                }
                else goto _LAND_28;
              }
              else goto _LAND_28;
            }
            else goto _LAND_28;
          }
          else goto _LAND_28;
        }
        else goto _LAND_28;
      }
      else goto _LAND_28;
    }
    else {
      _LAND_28: ;
      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[1] == 0) {
        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[2] == 0) {
          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[3] == 0) {
            if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[4] == 0) {
              if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[5] == 0) {
                if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[12] == 0) {
                  iphc1 = (unsigned char)((int)iphc1 | 0x02);
                  *hc06_ptr = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[1];
                  memcpy((void *)(hc06_ptr + 1),
                         (void const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[13]),
                         (unsigned long)3);
                  hc06_ptr += 4;
                }
                else goto _LAND_21;
              }
              else goto _LAND_21;
            }
            else goto _LAND_21;
          }
          else goto _LAND_21;
        }
        else goto _LAND_21;
      }
      else {
        _LAND_21: ;
        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[1] == 0) {
          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[2] == 0) {
            if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[3] == 0) {
              if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[4] == 0) {
                if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[10] == 0) {
                  iphc1 = (unsigned char)((int)iphc1 | 0x01);
                  *hc06_ptr = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[1];
                  memcpy((void *)(hc06_ptr + 1),
                         (void const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[11]),
                         (unsigned long)5);
                  hc06_ptr += 6;
                }
                else goto _LAND_16;
              }
              else goto _LAND_16;
            }
            else goto _LAND_16;
          }
          else goto _LAND_16;
        }
        else {
          _LAND_16:
          {
            iphc1 = (unsigned char)((int)iphc1 | 0x00);
            memcpy((void *)hc06_ptr,
                   (void const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[0]),
                   (unsigned long)16);
            hc06_ptr += 16;
          }
        }
      }
    }
  }
  else {
    context = addr_context_lookup_by_prefix(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr);
    if (context != (struct sicslowpan_addr_context *)0) {
      uint8_t tmp_12;
      iphc1 = (unsigned char)((int)iphc1 | 0x04);
      *((packetbuf_ptr + (int)packetbuf_hdr_len) + 2) = (unsigned char)(
      (int)*((packetbuf_ptr + (int)packetbuf_hdr_len) + 2) | (int)context->number);
      tmp_12 = compress_addr_64((unsigned char)0,
                                & ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr,
                                (uip_lladdr_t *)link_destaddr);
      iphc1 = (unsigned char)((int)iphc1 | (int)tmp_12);
    }
    else 
      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[0] == 0xfe) {
        if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[1] == 0x80) {
          if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[1] == 0) {
            if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[2] == 0) {
              if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[3] == 0) {
                uint8_t tmp_13;
                tmp_13 = compress_addr_64((unsigned char)0,
                                          & ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr,
                                          (uip_lladdr_t *)link_destaddr);
                iphc1 = (unsigned char)((int)iphc1 | (int)tmp_13);
              }
              else goto _LAND_32;
            }
            else goto _LAND_32;
          }
          else goto _LAND_32;
        }
        else goto _LAND_32;
      }
      else {
        _LAND_32:
        {
          iphc1 = (unsigned char)((int)iphc1 | 0x00);
          memcpy((void *)hc06_ptr,
                 (void const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u16[0]),
                 (unsigned long)16);
          hc06_ptr += 16;
        }
      }
  }
  uncomp_hdr_len = (unsigned char)40;
  next_hdr = & ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto;
  next_nhc = hc06_ptr;
  ext_hdr_len = 0;
  {
    int tmp_14;
    if (0 < curr_log_level_6lowpan) tmp_14 = 0;
    else tmp_14 = curr_log_level_6lowpan;
    if (4 <= tmp_14) {
      printf("[%-4s: %-10s] ","DBG","6LoWPAN");
      printf("compression: first header: %d\n",(int)*next_hdr);
    }
  }
  while (1) {
    if (next_hdr != (uint8_t *)0) {
      if (! ((int)*next_hdr == 17)) 
        if (! ((int)*next_hdr == 0)) 
          if (! ((int)*next_hdr == 60)) 
            if (! ((int)*next_hdr == 43)) 
              if (! ((int)*next_hdr == 44)) break;
    }
    else break;
    {
      {
        int tmp_15;
        if (0 < curr_log_level_6lowpan) tmp_15 = 0;
        else tmp_15 = curr_log_level_6lowpan;
        if (4 <= tmp_15) {
          printf("[%-4s: %-10s] ","DBG","6LoWPAN");
          printf("compression: next header: %d\n",(int)*next_hdr);
        }
      }
      int proto = -1;
      switch ((int)*next_hdr) {
        case 0: proto = 0x00;
        case 43: if (proto == -1) proto = 0x01; else proto = proto;
        case 44: if (proto == -1) proto = 0x02; else proto = proto;
        case 60:
        {
          int len;
          int tmp_20;
          struct uip_ext_hdr *ext_hdr =
            (struct uip_ext_hdr *)(& uip_aligned_buf.u8[40 + ext_hdr_len]);
          if (proto == -1) proto = 0x03; else proto = proto;
          len = ((int)ext_hdr->len << 3) + 8;
          {
            int tmp_16;
            if (0 < curr_log_level_6lowpan) tmp_16 = 0;
            else tmp_16 = curr_log_level_6lowpan;
            if (4 <= tmp_16) {
              printf("[%-4s: %-10s] ","DBG","6LoWPAN");
              printf("compression: next header %d (len:%d)\n",(int)*next_hdr,
                     len);
            }
          }
          next_hdr = & ext_hdr->next;
          if (! ((int)*next_hdr == 17)) 
            if (! ((int)*next_hdr == 0)) 
              if (! ((int)*next_hdr == 60)) 
                if (! ((int)*next_hdr == 43)) 
                  if (! ((int)*next_hdr == 44)) {
                    if (hc06_ptr + 1 >= packetbuf_ptr + mac_max_payload) {
                      {
                        int tmp_17;
                        if (0 < curr_log_level_6lowpan) tmp_17 = 0;
                        else tmp_17 = curr_log_level_6lowpan;
                        if (2 <= tmp_17) {
                          printf("[%-4s: %-10s] ","WARN","6LoWPAN");
                          printf("Not enough packetbuf space to compress header (%u bytes, %u left). Aborting.\n",
                                 (unsigned int)1,
                                 (unsigned int)((packetbuf_ptr + mac_max_payload) - hc06_ptr));
                        }
                      }
                      __retres = 0;
                      goto return_label;
                    }
                    hc06_ptr ++;
                    {
                      int tmp_18;
                      if (0 < curr_log_level_6lowpan) tmp_18 = 0;
                      else tmp_18 = curr_log_level_6lowpan;
                      if (4 <= tmp_18) {
                        printf("[%-4s: %-10s] ","DBG","6LoWPAN");
                        printf("compression: keeping the next header in this ext hdr: %d\n",
                               (int)ext_hdr->next);
                      }
                    }
                  }
          if (hc06_ptr + len >= packetbuf_ptr + mac_max_payload) {
            {
              int tmp_19;
              if (0 < curr_log_level_6lowpan) tmp_19 = 0;
              else tmp_19 = curr_log_level_6lowpan;
              if (2 <= tmp_19) {
                printf("[%-4s: %-10s] ","WARN","6LoWPAN");
                printf("Not enough packetbuf space to compress header (%u bytes, %u left). Aborting.\n",
                       (unsigned int)len,
                       (unsigned int)((packetbuf_ptr + mac_max_payload) - hc06_ptr));
              }
            }
            __retres = 0;
            goto return_label;
          }
          memcpy((void *)hc06_ptr,(void const *)ext_hdr,(unsigned long)len);
          ext_hdr = (struct uip_ext_hdr *)hc06_ptr;
          ext_hdr->len = (unsigned char)(len - 2);
          ext_hdr_len += len;
          hc06_ptr += len;
          uncomp_hdr_len = (unsigned char)((int)uncomp_hdr_len + len);
          if ((int)*next_hdr == 17) tmp_20 = 0x01;
          else 
            if ((int)*next_hdr == 0) tmp_20 = 0x01;
            else 
              if ((int)*next_hdr == 60) tmp_20 = 0x01;
              else 
                if ((int)*next_hdr == 43) tmp_20 = 0x01;
                else 
                  if ((int)*next_hdr == 44) tmp_20 = 0x01; else tmp_20 = 0;
          *next_nhc = (unsigned char)((0xE0 | tmp_20) | (proto << 1));
          next_nhc = hc06_ptr;
        }
        break;
        case 17: hc06_ptr ++;
        udp_buf = (struct uip_udp_hdr *)(& uip_aligned_buf.u8[40 + ext_hdr_len]);
        {
          int tmp_21;
          if (0 < curr_log_level_6lowpan) tmp_21 = 0;
          else tmp_21 = curr_log_level_6lowpan;
          if (4 <= tmp_21) {
            printf("[%-4s: %-10s] ","DBG","6LoWPAN");
            printf("compression: inlined UDP ports on send side: %x, %x\n",
                   (int)((unsigned short)(((int)udp_buf->srcport << 8) | (
                                          (int)udp_buf->srcport >> 8))),
                   (int)((unsigned short)(((int)udp_buf->destport << 8) | (
                                          (int)udp_buf->destport >> 8))));
          }
        }
        if (((int)((unsigned short)(((int)udp_buf->srcport << 8) | ((int)udp_buf->srcport >> 8))) & 0xfff0) == 0xF0B0) {
          if (((int)((unsigned short)(((int)udp_buf->destport << 8) | (
                                      (int)udp_buf->destport >> 8))) & 0xfff0) == 0xF0B0) {
            *next_nhc = (unsigned char)0xF3;
            {
              int tmp_22;
              if (0 < curr_log_level_6lowpan) tmp_22 = 0;
              else tmp_22 = curr_log_level_6lowpan;
              if (4 <= tmp_22) {
                printf("[%-4s: %-10s] ","DBG","6LoWPAN");
                printf("IPHC: remove 12 b of both source & dest with prefix 0xFOB\n");
              }
            }
            if (hc06_ptr + 1 >= packetbuf_ptr + mac_max_payload) {
              {
                int tmp_23;
                if (0 < curr_log_level_6lowpan) tmp_23 = 0;
                else tmp_23 = curr_log_level_6lowpan;
                if (2 <= tmp_23) {
                  printf("[%-4s: %-10s] ","WARN","6LoWPAN");
                  printf("Not enough packetbuf space to compress header (%u bytes, %u left). Aborting.\n",
                         (unsigned int)1,
                         (unsigned int)((packetbuf_ptr + mac_max_payload) - hc06_ptr));
                }
              }
              __retres = 0;
              goto return_label;
            }
            *hc06_ptr = (unsigned char)((int)((unsigned char)(((int)((unsigned short)(
                                                               ((int)udp_buf->srcport << 8) | (
                                                               (int)udp_buf->srcport >> 8))) - 0xF0B0) << 4)) + (int)((unsigned char)(
                                        (int)((unsigned short)(((int)udp_buf->destport << 8) | (
                                                               (int)udp_buf->destport >> 8))) - 0xF0B0)));
            hc06_ptr ++;
          }
          else goto _LAND_33;
        }
        else {
          _LAND_33: ;
          if (((int)((unsigned short)(((int)udp_buf->destport << 8) | (
                                      (int)udp_buf->destport >> 8))) & 0xff00) == 0xF000) {
            *next_nhc = (unsigned char)0xF1;
            {
              int tmp_24;
              if (0 < curr_log_level_6lowpan) tmp_24 = 0;
              else tmp_24 = curr_log_level_6lowpan;
              if (4 <= tmp_24) {
                printf("[%-4s: %-10s] ","DBG","6LoWPAN");
                printf("IPHC: leave source, remove 8 bits of dest with prefix 0xF0\n");
              }
            }
            if (hc06_ptr + 3 >= packetbuf_ptr + mac_max_payload) {
              {
                int tmp_25;
                if (0 < curr_log_level_6lowpan) tmp_25 = 0;
                else tmp_25 = curr_log_level_6lowpan;
                if (2 <= tmp_25) {
                  printf("[%-4s: %-10s] ","WARN","6LoWPAN");
                  printf("Not enough packetbuf space to compress header (%u bytes, %u left). Aborting.\n",
                         (unsigned int)3,
                         (unsigned int)((packetbuf_ptr + mac_max_payload) - hc06_ptr));
                }
              }
              __retres = 0;
              goto return_label;
            }
            memcpy((void *)hc06_ptr,(void const *)(& udp_buf->srcport),
                   (unsigned long)2);
            *(hc06_ptr + 2) = (unsigned char)((int)((unsigned short)(
                                              ((int)udp_buf->destport << 8) | (
                                              (int)udp_buf->destport >> 8))) - 0xF000);
            hc06_ptr += 3;
          }
          else 
            if (((int)((unsigned short)(((int)udp_buf->srcport << 8) | (
                                        (int)udp_buf->srcport >> 8))) & 0xff00) == 0xF000) {
              *next_nhc = (unsigned char)0xF2;
              {
                int tmp_26;
                if (0 < curr_log_level_6lowpan) tmp_26 = 0;
                else tmp_26 = curr_log_level_6lowpan;
                if (4 <= tmp_26) {
                  printf("[%-4s: %-10s] ","DBG","6LoWPAN");
                  printf("IPHC: remove 8 bits of source with prefix 0xF0, leave dest. hch: %i\n",
                         (int)*next_nhc);
                }
              }
              if (hc06_ptr + 3 >= packetbuf_ptr + mac_max_payload) {
                {
                  int tmp_27;
                  if (0 < curr_log_level_6lowpan) tmp_27 = 0;
                  else tmp_27 = curr_log_level_6lowpan;
                  if (2 <= tmp_27) {
                    printf("[%-4s: %-10s] ","WARN","6LoWPAN");
                    printf("Not enough packetbuf space to compress header (%u bytes, %u left). Aborting.\n",
                           (unsigned int)3,
                           (unsigned int)((packetbuf_ptr + mac_max_payload) - hc06_ptr));
                  }
                }
                __retres = 0;
                goto return_label;
              }
              *hc06_ptr = (unsigned char)((int)((unsigned short)(((int)udp_buf->srcport << 8) | (
                                                                 (int)udp_buf->srcport >> 8))) - 0xF000);
              memcpy((void *)(hc06_ptr + 1),
                     (void const *)(& udp_buf->destport),(unsigned long)2);
              hc06_ptr += 3;
            }
            else {
              *next_nhc = (unsigned char)0xF0;
              {
                int tmp_28;
                if (0 < curr_log_level_6lowpan) tmp_28 = 0;
                else tmp_28 = curr_log_level_6lowpan;
                if (4 <= tmp_28) {
                  printf("[%-4s: %-10s] ","DBG","6LoWPAN");
                  printf("IPHC: cannot compress UDP headers\n");
                }
              }
              if (hc06_ptr + 4 >= packetbuf_ptr + mac_max_payload) {
                {
                  int tmp_29;
                  if (0 < curr_log_level_6lowpan) tmp_29 = 0;
                  else tmp_29 = curr_log_level_6lowpan;
                  if (2 <= tmp_29) {
                    printf("[%-4s: %-10s] ","WARN","6LoWPAN");
                    printf("Not enough packetbuf space to compress header (%u bytes, %u left). Aborting.\n",
                           (unsigned int)4,
                           (unsigned int)((packetbuf_ptr + mac_max_payload) - hc06_ptr));
                  }
                }
                __retres = 0;
                goto return_label;
              }
              memcpy((void *)hc06_ptr,(void const *)(& udp_buf->srcport),
                     (unsigned long)4);
              hc06_ptr += 4;
            }
        }
        if (hc06_ptr + 2 >= packetbuf_ptr + mac_max_payload) {
          {
            int tmp_30;
            if (0 < curr_log_level_6lowpan) tmp_30 = 0;
            else tmp_30 = curr_log_level_6lowpan;
            if (2 <= tmp_30) {
              printf("[%-4s: %-10s] ","WARN","6LoWPAN");
              printf("Not enough packetbuf space to compress header (%u bytes, %u left). Aborting.\n",
                     (unsigned int)2,
                     (unsigned int)((packetbuf_ptr + mac_max_payload) - hc06_ptr));
            }
          }
          __retres = 0;
          goto return_label;
        }
        memcpy((void *)hc06_ptr,(void const *)(& udp_buf->udpchksum),
               (unsigned long)2);
        hc06_ptr += 2;
        uncomp_hdr_len = (unsigned char)((int)uncomp_hdr_len + 8);
        next_hdr = (uint8_t *)0;
        break;
        default:
        {
          int tmp_31;
          if (0 < curr_log_level_6lowpan) tmp_31 = 0;
          else tmp_31 = curr_log_level_6lowpan;
          if (1 <= tmp_31) {
            printf("[%-4s: %-10s] ","ERR","6LoWPAN");
            printf("compression: could not handle compression of header");
          }
        }
      }
    }
  }
  if (next_hdr != (uint8_t *)0) {
    int tmp_32;
    if (0 < curr_log_level_6lowpan) tmp_32 = 0;
    else tmp_32 = curr_log_level_6lowpan;
    if (4 <= tmp_32) {
      printf("[%-4s: %-10s] ","DBG","6LoWPAN");
      printf("compression: last header could is not compressed: %d\n",
             (int)*next_hdr);
    }
  }
  *((packetbuf_ptr + (int)packetbuf_hdr_len) + 0) = iphc0;
  *((packetbuf_ptr + (int)packetbuf_hdr_len) + 1) = iphc1;
  if (0 < curr_log_level_6lowpan) tmp_36 = 0;
  else tmp_36 = curr_log_level_6lowpan;
  if (tmp_36 >= 4) {
    uint16_t ndx_0;
    {
      int tmp_33;
      if (0 < curr_log_level_6lowpan) tmp_33 = 0;
      else tmp_33 = curr_log_level_6lowpan;
      if (4 <= tmp_33) {
        printf("[%-4s: %-10s] ","DBG","6LoWPAN");
        printf("compression: after (%d): ",(int)(hc06_ptr - packetbuf_ptr));
      }
    }
    ndx_0 = (unsigned short)0;
    while ((long)ndx_0 < hc06_ptr - packetbuf_ptr) {
      {
        uint8_t data_0 = *(packetbuf_ptr + ndx_0);
        {
          int tmp_34;
          if (0 < curr_log_level_6lowpan) tmp_34 = 0;
          else tmp_34 = curr_log_level_6lowpan;
          if (4 <= tmp_34) printf("%02x",(int)data_0);
        }
      }
      ndx_0 = (uint16_t)((int)ndx_0 + 1);
    }
    {
      int tmp_35;
      if (0 < curr_log_level_6lowpan) tmp_35 = 0;
      else tmp_35 = curr_log_level_6lowpan;
      if (4 <= tmp_35) printf("\n");
    }
  }
  packetbuf_hdr_len = (unsigned char)(hc06_ptr - packetbuf_ptr);
  __retres = 1;
  return_label: return __retres;
}

static void uncompress_hdr_iphc(uint8_t *buf_0, uint16_t ip_len)
{
  uint8_t tmp;
  uint8_t iphc0;
  uint8_t iphc1;
  uint8_t nhc;
  struct uip_ext_hdr *exthdr;
  uint8_t *last_nextheader;
  uint8_t *ip_payload;
  uint8_t ext_hdr_len = (unsigned char)0;
  hc06_ptr = (packetbuf_ptr + (int)packetbuf_hdr_len) + 2;
  iphc0 = *((packetbuf_ptr + (int)packetbuf_hdr_len) + 0);
  iphc1 = *((packetbuf_ptr + (int)packetbuf_hdr_len) + 1);
  if ((int)iphc1 & 0x80) {
    {
      int tmp_0;
      if (0 < curr_log_level_6lowpan) tmp_0 = 0;
      else tmp_0 = curr_log_level_6lowpan;
      if (4 <= tmp_0) {
        printf("[%-4s: %-10s] ","DBG","6LoWPAN");
        printf("uncompression: CID flag set - increase header with one\n");
      }
    }
    hc06_ptr ++;
  }
  if (((int)iphc0 & 0x10) == 0) 
    if (((int)iphc0 & 0x08) == 0) {
      memcpy((void *)(& ((struct uip_ip_hdr *)buf_0)->tcflow),
             (void const *)(hc06_ptr + 1),(unsigned long)3);
      tmp = *hc06_ptr;
      hc06_ptr += 4;
      ((struct uip_ip_hdr *)buf_0)->vtc = (unsigned char)(0x60 | (((int)tmp >> 2) & 0x0f));
      ((struct uip_ip_hdr *)buf_0)->tcflow = (unsigned char)(((((int)tmp >> 2) & 0x30) | (
                                                              (int)tmp << 6)) | (
                                                             (int)((struct uip_ip_hdr *)buf_0)->tcflow & 0x0f));
    }
    else {
      ((struct uip_ip_hdr *)buf_0)->vtc = (unsigned char)0x60;
      ((struct uip_ip_hdr *)buf_0)->tcflow = (unsigned char)(((int)*hc06_ptr & 0x0F) | (
                                                             ((int)*hc06_ptr >> 2) & 0x30));
      memcpy((void *)(& ((struct uip_ip_hdr *)buf_0)->flow),
             (void const *)(hc06_ptr + 1),(unsigned long)2);
      hc06_ptr += 3;
    }
  else 
    if (((int)iphc0 & 0x08) == 0) {
      ((struct uip_ip_hdr *)buf_0)->vtc = (unsigned char)(0x60 | (((int)*hc06_ptr >> 2) & 0x0f));
      ((struct uip_ip_hdr *)buf_0)->tcflow = (unsigned char)((((int)*hc06_ptr << 6) & 0xC0) | (
                                                             ((int)*hc06_ptr >> 2) & 0x30));
      ((struct uip_ip_hdr *)buf_0)->flow = (unsigned short)0;
      hc06_ptr ++;
    }
    else {
      ((struct uip_ip_hdr *)buf_0)->vtc = (unsigned char)0x60;
      ((struct uip_ip_hdr *)buf_0)->tcflow = (unsigned char)0;
      ((struct uip_ip_hdr *)buf_0)->flow = (unsigned short)0;
    }
  if (((int)iphc0 & 0x04) == 0) {
    ((struct uip_ip_hdr *)buf_0)->proto = *hc06_ptr;
    {
      int tmp_1;
      if (0 < curr_log_level_6lowpan) tmp_1 = 0;
      else tmp_1 = curr_log_level_6lowpan;
      if (4 <= tmp_1) {
        printf("[%-4s: %-10s] ","DBG","6LoWPAN");
        printf("uncompression: next header inline: %d\n",
               (int)((struct uip_ip_hdr *)buf_0)->proto);
      }
    }
    hc06_ptr ++;
  }
  if (((int)iphc0 & 0x03) != 0x00) ((struct uip_ip_hdr *)buf_0)->ttl = ttl_values[
                                   (int)iphc0 & 0x03];
  else {
    ((struct uip_ip_hdr *)buf_0)->ttl = *hc06_ptr;
    hc06_ptr ++;
  }
  tmp = (unsigned char)((((int)iphc1 & 0x30) >> 4) & 0x03);
  if ((int)iphc1 & 0x40) {
    int tmp_2;
    linkaddr_t const *tmp_4;
    uint8_t *tmp_5;
    if ((int)iphc1 & 0x80) tmp_2 = (int)*((packetbuf_ptr + (int)packetbuf_hdr_len) + 2) >> 4;
    else tmp_2 = 0;
    uint8_t sci = (unsigned char)tmp_2;
    if ((int)tmp != 0) {
      context = addr_context_lookup_by_number(sci);
      if (context == (struct sicslowpan_addr_context *)0) {
        {
          int tmp_3;
          if (0 < curr_log_level_6lowpan) tmp_3 = 0;
          else tmp_3 = curr_log_level_6lowpan;
          if (1 <= tmp_3) {
            printf("[%-4s: %-10s] ","ERR","6LoWPAN");
            printf("uncompression: error context not found\n");
          }
        }
        goto return_label;
      }
    }
    tmp_4 = packetbuf_addr((unsigned char)PACKETBUF_ADDR_SENDER);
    ;
    if ((int)tmp != 0) tmp_5 = context->prefix; else tmp_5 = (uint8_t *)0;
    ;
    uncompress_addr(& ((struct uip_ip_hdr *)buf_0)->srcipaddr,
                    (uint8_t const *)tmp_5,unc_ctxconf[tmp],
                    (uip_lladdr_t *)tmp_4);
  }
  else {
    linkaddr_t const *tmp_6;
    tmp_6 = packetbuf_addr((unsigned char)PACKETBUF_ADDR_SENDER);
    ;
    ;
    uncompress_addr(& ((struct uip_ip_hdr *)buf_0)->srcipaddr,llprefix,
                    unc_llconf[tmp],(uip_lladdr_t *)tmp_6);
  }
  tmp = (unsigned char)((((int)iphc1 & 0x03) >> 0) & 0x03);
  if ((int)iphc1 & 0x08) {
    if (! ((int)iphc1 & 0x04)) {
      uint8_t prefix[2] = {(unsigned char)0xff, (unsigned char)0x02};
      if ((int)tmp > 0) 
        if ((int)tmp < 3) {
          prefix[1] = *hc06_ptr;
          hc06_ptr ++;
        }
      uncompress_addr(& ((struct uip_ip_hdr *)buf_0)->destipaddr,
                      (uint8_t const *)(prefix),unc_mxconf[tmp],
                      (uip_lladdr_t *)0);
    }
  }
  else 
    if ((int)iphc1 & 0x04) {
      int tmp_7;
      linkaddr_t const *tmp_9;
      if ((int)iphc1 & 0x80) tmp_7 = (int)*((packetbuf_ptr + (int)packetbuf_hdr_len) + 2) & 0x0f;
      else tmp_7 = 0;
      uint8_t dci = (unsigned char)tmp_7;
      context = addr_context_lookup_by_number(dci);
      if (context == (struct sicslowpan_addr_context *)0) {
        {
          int tmp_8;
          if (0 < curr_log_level_6lowpan) tmp_8 = 0;
          else tmp_8 = curr_log_level_6lowpan;
          if (1 <= tmp_8) {
            printf("[%-4s: %-10s] ","ERR","6LoWPAN");
            printf("uncompression: error context not found\n");
          }
        }
        goto return_label;
      }
      tmp_9 = packetbuf_addr((unsigned char)PACKETBUF_ADDR_RECEIVER);
      ;
      ;
      ;
      uncompress_addr(& ((struct uip_ip_hdr *)buf_0)->destipaddr,
                      (uint8_t const *)(context->prefix),unc_ctxconf[tmp],
                      (uip_lladdr_t *)tmp_9);
    }
    else {
      linkaddr_t const *tmp_10;
      tmp_10 = packetbuf_addr((unsigned char)PACKETBUF_ADDR_RECEIVER);
      ;
      ;
      uncompress_addr(& ((struct uip_ip_hdr *)buf_0)->destipaddr,llprefix,
                      unc_llconf[tmp],(uip_lladdr_t *)tmp_10);
    }
  uncomp_hdr_len = (unsigned char)((int)uncomp_hdr_len + 40);
  nhc = (unsigned char)((int)iphc0 & 0x04);
  last_nextheader = & ((struct uip_ip_hdr *)buf_0)->proto;
  ip_payload = buf_0 + 40;
  while (1) {
    if (nhc) {
      if (! (((int)*hc06_ptr & 0xF0) == 0xE0)) break;
    }
    else break;
    {
      uint8_t len;
      uint8_t proto;
      uint8_t eid = (unsigned char)(((int)*hc06_ptr & 0x0e) >> 1);
      uint8_t nh = (unsigned char)((int)*hc06_ptr & 0x01);
      uint8_t next = (unsigned char)0;
      nhc = nh;
      hc06_ptr ++;
      if (! nh) {
        next = *hc06_ptr;
        hc06_ptr ++;
        {
          int tmp_11;
          if (0 < curr_log_level_6lowpan) tmp_11 = 0;
          else tmp_11 = curr_log_level_6lowpan;
          if (4 <= tmp_11) {
            printf("[%-4s: %-10s] ","DBG","6LoWPAN");
            printf("uncompression: next header is inlined. Next: %d\n",
                   (int)next);
          }
        }
      }
      len = *hc06_ptr;
      hc06_ptr ++;
      {
        int tmp_12;
        if (0 < curr_log_level_6lowpan) tmp_12 = 0;
        else tmp_12 = curr_log_level_6lowpan;
        if (4 <= tmp_12) {
          printf("[%-4s: %-10s] ","DBG","6LoWPAN");
          printf("uncompression: found ext header id: %d next: %d len: %d\n",
                 (int)eid,(int)next,(int)len);
        }
      }
      switch ((int)eid) {
        case 0x00: proto = (unsigned char)0;
        break;
        case 0x01: proto = (unsigned char)43;
        break;
        case 0x02: proto = (unsigned char)44;
        break;
        case 0x03: proto = (unsigned char)60;
        break;
        default:
        {
          int tmp_13;
          if (0 < curr_log_level_6lowpan) tmp_13 = 0;
          else tmp_13 = curr_log_level_6lowpan;
          if (4 <= tmp_13) {
            printf("[%-4s: %-10s] ","DBG","6LoWPAN");
            printf("uncompression: error unsupported ext header\n");
          }
        }
        goto return_label;
      }
      *last_nextheader = proto;
      exthdr = (struct uip_ext_hdr *)ip_payload;
      exthdr->len = (unsigned char)((2 + (int)len) / 8 - 1);
      exthdr->next = next;
      last_nextheader = & exthdr->next;
      memcpy((void *)((uint8_t *)exthdr + 2),(void const *)hc06_ptr,
             (unsigned long)len);
      hc06_ptr += (int)len;
      uncomp_hdr_len = (unsigned char)((int)uncomp_hdr_len + ((int)exthdr->len + 1) * 8);
      ip_payload += ((int)exthdr->len + 1) * 8;
      ext_hdr_len = (unsigned char)((int)ext_hdr_len + ((int)exthdr->len + 1) * 8);
      {
        int tmp_14;
        if (0 < curr_log_level_6lowpan) tmp_14 = 0;
        else tmp_14 = curr_log_level_6lowpan;
        if (4 <= tmp_14) {
          printf("[%-4s: %-10s] ","DBG","6LoWPAN");
          printf("uncompression: %d len: %d exhdrlen: %d (calc: %d)\n",
                 (int)proto,(int)len,(int)exthdr->len,
                 ((int)exthdr->len + 1) * 8);
        }
      }
    }
  }
  if (nhc) 
    if (((int)*hc06_ptr & 0xF8) == 0xF0) {
      uint16_t udp_len;
      uint8_t checksum_compressed;
      uint16_t tmp_25;
      int tmp_26;
      int tmp_27;
      struct uip_udp_hdr *udp_buf = (struct uip_udp_hdr *)ip_payload;
      *last_nextheader = (unsigned char)17;
      checksum_compressed = (unsigned char)((int)*hc06_ptr & 0x04);
      {
        int tmp_15;
        if (0 < curr_log_level_6lowpan) tmp_15 = 0;
        else tmp_15 = curr_log_level_6lowpan;
        if (4 <= tmp_15) {
          printf("[%-4s: %-10s] ","DBG","6LoWPAN");
          printf("uncompression: incoming header value: %i\n",(int)*hc06_ptr);
        }
      }
      switch ((int)*hc06_ptr & 0xF3) {
        case 0xF0:
        memcpy((void *)(& udp_buf->srcport),(void const *)(hc06_ptr + 1),
               (unsigned long)2);
        memcpy((void *)(& udp_buf->destport),(void const *)(hc06_ptr + 3),
               (unsigned long)2);
        {
          int tmp_16;
          if (0 < curr_log_level_6lowpan) tmp_16 = 0;
          else tmp_16 = curr_log_level_6lowpan;
          if (4 <= tmp_16) {
            printf("[%-4s: %-10s] ","DBG","6LoWPAN");
            printf("uncompression: UDP ports (ptr+5): %x, %x\n",
                   (int)((unsigned short)(((int)udp_buf->srcport << 8) | (
                                          (int)udp_buf->srcport >> 8))),
                   (int)((unsigned short)(((int)udp_buf->destport << 8) | (
                                          (int)udp_buf->destport >> 8))));
          }
        }
        hc06_ptr += 5;
        break;
        case 0xF1:
        {
          int tmp_17;
          if (0 < curr_log_level_6lowpan) tmp_17 = 0;
          else tmp_17 = curr_log_level_6lowpan;
          if (4 <= tmp_17) {
            printf("[%-4s: %-10s] ","DBG","6LoWPAN");
            printf("uncompression: destination address\n");
          }
        }
        memcpy((void *)(& udp_buf->srcport),(void const *)(hc06_ptr + 1),
               (unsigned long)2);
        udp_buf->destport = (unsigned short)(((int)((unsigned short)(
                                              0xF000 + (int)*(hc06_ptr + 3))) << 8) | (
                                             (int)((unsigned short)(0xF000 + (int)*(
                                                                    hc06_ptr + 3))) >> 8));
        {
          int tmp_18;
          if (0 < curr_log_level_6lowpan) tmp_18 = 0;
          else tmp_18 = curr_log_level_6lowpan;
          if (4 <= tmp_18) {
            printf("[%-4s: %-10s] ","DBG","6LoWPAN");
            printf("uncompression: UDP ports (ptr+4): %x, %x\n",
                   (int)((unsigned short)(((int)udp_buf->srcport << 8) | (
                                          (int)udp_buf->srcport >> 8))),
                   (int)((unsigned short)(((int)udp_buf->destport << 8) | (
                                          (int)udp_buf->destport >> 8))));
          }
        }
        hc06_ptr += 4;
        break;
        case 0xF2:
        {
          int tmp_19;
          if (0 < curr_log_level_6lowpan) tmp_19 = 0;
          else tmp_19 = curr_log_level_6lowpan;
          if (4 <= tmp_19) {
            printf("[%-4s: %-10s] ","DBG","6LoWPAN");
            printf("uncompression: source address\n");
          }
        }
        udp_buf->srcport = (unsigned short)(((int)((unsigned short)(0xF000 + (int)*(
                                                                    hc06_ptr + 1))) << 8) | (
                                            (int)((unsigned short)(0xF000 + (int)*(
                                                                   hc06_ptr + 1))) >> 8));
        memcpy((void *)(& udp_buf->destport),(void const *)(hc06_ptr + 2),
               (unsigned long)2);
        {
          int tmp_20;
          if (0 < curr_log_level_6lowpan) tmp_20 = 0;
          else tmp_20 = curr_log_level_6lowpan;
          if (4 <= tmp_20) {
            printf("[%-4s: %-10s] ","DBG","6LoWPAN");
            printf("uncompression: UDP ports (ptr+4): %x, %x\n",
                   (int)((unsigned short)(((int)udp_buf->srcport << 8) | (
                                          (int)udp_buf->srcport >> 8))),
                   (int)((unsigned short)(((int)udp_buf->destport << 8) | (
                                          (int)udp_buf->destport >> 8))));
          }
        }
        hc06_ptr += 4;
        break;
        case 0xF3:
        udp_buf->srcport = (unsigned short)(((int)((unsigned short)(0xF0B0 + (
                                                                    (int)*(
                                                                    hc06_ptr + 1) >> 4))) << 8) | (
                                            (int)((unsigned short)(0xF0B0 + (
                                                                   (int)*(
                                                                   hc06_ptr + 1) >> 4))) >> 8));
        udp_buf->destport = (unsigned short)(((int)((unsigned short)(
                                              0xF0B0 + ((int)*(hc06_ptr + 1) & 0x0F))) << 8) | (
                                             (int)((unsigned short)(0xF0B0 + (
                                                                    (int)*(
                                                                    hc06_ptr + 1) & 0x0F))) >> 8));
        {
          int tmp_21;
          if (0 < curr_log_level_6lowpan) tmp_21 = 0;
          else tmp_21 = curr_log_level_6lowpan;
          if (4 <= tmp_21) {
            printf("[%-4s: %-10s] ","DBG","6LoWPAN");
            printf("uncompression: UDP ports (ptr+2): %x, %x\n",
                   (int)((unsigned short)(((int)udp_buf->srcport << 8) | (
                                          (int)udp_buf->srcport >> 8))),
                   (int)((unsigned short)(((int)udp_buf->destport << 8) | (
                                          (int)udp_buf->destport >> 8))));
          }
        }
        hc06_ptr += 2;
        break;
        default:
        {
          int tmp_22;
          if (0 < curr_log_level_6lowpan) tmp_22 = 0;
          else tmp_22 = curr_log_level_6lowpan;
          if (4 <= tmp_22) {
            printf("[%-4s: %-10s] ","DBG","6LoWPAN");
            printf("uncompression: error unsupported UDP compression\n");
          }
        }
        goto return_label;
      }
      if (! checksum_compressed) {
        memcpy((void *)(& udp_buf->udpchksum),(void const *)hc06_ptr,
               (unsigned long)2);
        hc06_ptr += 2;
        {
          int tmp_23;
          if (0 < curr_log_level_6lowpan) tmp_23 = 0;
          else tmp_23 = curr_log_level_6lowpan;
          if (4 <= tmp_23) {
            printf("[%-4s: %-10s] ","DBG","6LoWPAN");
            printf("uncompression: checksum included\n");
          }
        }
      }
      else {
        int tmp_24;
        if (0 < curr_log_level_6lowpan) tmp_24 = 0;
        else tmp_24 = curr_log_level_6lowpan;
        if (4 <= tmp_24) {
          printf("[%-4s: %-10s] ","DBG","6LoWPAN");
          printf("uncompression: checksum *NOT* included\n");
        }
      }
      tmp_25 = packetbuf_datalen();
      udp_len = (unsigned short)((long)(8 + (int)tmp_25) - (hc06_ptr - packetbuf_ptr));
      if ((int)ip_len == 0) tmp_26 = (int)udp_len;
      else tmp_26 = ((int)ip_len - 40) - (int)ext_hdr_len;
      if ((int)ip_len == 0) tmp_27 = (int)udp_len;
      else tmp_27 = ((int)ip_len - 40) - (int)ext_hdr_len;
      udp_buf->udplen = (unsigned short)(((int)((unsigned short)tmp_26) << 8) | (
                                         (int)((unsigned short)tmp_27) >> 8));
      {
        int tmp_28;
        if (0 < curr_log_level_6lowpan) tmp_28 = 0;
        else tmp_28 = curr_log_level_6lowpan;
        if (4 <= tmp_28) {
          printf("[%-4s: %-10s] ","DBG","6LoWPAN");
          printf("uncompression: UDP length: %u (ext: %u) ip_len: %d udp_len: %d\n",
                 (int)((unsigned short)(((int)udp_buf->udplen << 8) | (
                                        (int)udp_buf->udplen >> 8))),
                 (int)ext_hdr_len,(int)ip_len,(int)udp_len);
        }
      }
      uncomp_hdr_len = (unsigned char)((int)uncomp_hdr_len + 8);
    }
  packetbuf_hdr_len = (unsigned char)(hc06_ptr - packetbuf_ptr);
  if ((int)ip_len == 0) {
    uint16_t tmp_29;
    tmp_29 = packetbuf_datalen();
    int len_0 =
      (((int)tmp_29 - (int)packetbuf_hdr_len) + (int)uncomp_hdr_len) - 40;
    {
      int tmp_31;
      if (0 < curr_log_level_6lowpan) tmp_31 = 0;
      else tmp_31 = curr_log_level_6lowpan;
      if (4 <= tmp_31) {
        uint16_t tmp_30;
        printf("[%-4s: %-10s] ","DBG","6LoWPAN");
        ;
        ;
        tmp_30 = packetbuf_datalen();
        ;
        printf("uncompression: IP payload length: %d. %u - %u + %u - %u\n",
               len_0,(int)tmp_30,(int)packetbuf_hdr_len,(int)uncomp_hdr_len,
               40);
      }
    }
    ((struct uip_ip_hdr *)buf_0)->len[0] = (unsigned char)(len_0 >> 8);
    ((struct uip_ip_hdr *)buf_0)->len[1] = (unsigned char)(len_0 & 0x00FF);
  }
  else {
    ((struct uip_ip_hdr *)buf_0)->len[0] = (unsigned char)(((int)ip_len - 40) >> 8);
    ((struct uip_ip_hdr *)buf_0)->len[1] = (unsigned char)(((int)ip_len - 40) & 0x00FF);
  }
  return_label: return;
}

static void digest_paging_dispatch(void)
{
  if (((int)*((packetbuf_ptr + (int)packetbuf_hdr_len) + 0) & 0xf0) == 0xf0) {
    curr_page = (unsigned char)((int)*((packetbuf_ptr + (int)packetbuf_hdr_len) + 0) & 0x0f);
    packetbuf_hdr_len = (uint8_t)((int)packetbuf_hdr_len + 1);
  }
  return;
}

static void digest_6lorh_hdr(void)
{
  return;
}

static void packet_sent(void *ptr, int status, int transmissions)
{
  linkaddr_t const *dest;
  int tmp;
  if (callback != (struct netstack_sniffer *)0) (*(callback->output_callback))
                                                (status);
  last_tx_status = status;
  dest = packetbuf_addr((unsigned char)PACKETBUF_ADDR_RECEIVER);
  tmp = linkaddr_cmp(dest,& linkaddr_null);
  if (tmp) goto return_label;
  link_stats_packet_sent(dest,status,transmissions);
  (*(rpl_lite_driver.link_callback))(dest,status,transmissions);
  uip_ds6_link_callback(status,transmissions);
  return_label: return;
}

static void send_packet_0(linkaddr_t *dest)
{
  packetbuf_set_addr((unsigned char)PACKETBUF_ADDR_RECEIVER,
                     (linkaddr_t const *)dest);
  (*(nullmac_driver.send))(& packet_sent,(void *)0);
  watchdog_periodic();
  return;
}

static int fragment_copy_payload_and_send(uint16_t uip_offset,
                                          linkaddr_t *dest)
{
  int __retres;
  struct queuebuf *q;
  memcpy((void *)(packetbuf_ptr + (int)packetbuf_hdr_len),
         (void const *)(& uip_aligned_buf.u8[uip_offset]),
         (unsigned long)packetbuf_payload_len);
  packetbuf_set_datalen((unsigned short)(packetbuf_payload_len + (int)packetbuf_hdr_len));
  q = queuebuf_new_from_packetbuf();
  if (q == (struct queuebuf *)0) {
    {
      int tmp;
      if (0 < curr_log_level_6lowpan) tmp = 0;
      else tmp = curr_log_level_6lowpan;
      if (2 <= tmp) {
        printf("[%-4s: %-10s] ","WARN","6LoWPAN");
        printf("output: could not allocate queuebuf, dropping fragment\n");
      }
    }
    __retres = 0;
    goto return_label;
  }
  send_packet_0(dest);
  queuebuf_to_packetbuf(q);
  queuebuf_free(q);
  if (last_tx_status == MAC_TX_COLLISION) goto _LOR;
  else 
    if (last_tx_status == MAC_TX_ERR) goto _LOR;
    else 
      if (last_tx_status == MAC_TX_ERR_FATAL) {
        _LOR:
        {
          {
            int tmp_0;
            if (0 < curr_log_level_6lowpan) tmp_0 = 0;
            else tmp_0 = curr_log_level_6lowpan;
            if (1 <= tmp_0) {
              printf("[%-4s: %-10s] ","ERR","6LoWPAN");
              printf("output: error in fragment tx, dropping subsequent fragments.\n");
            }
          }
          __retres = 0;
          goto return_label;
        }
      }
  __retres = 1;
  return_label: return __retres;
}

static uint8_t output_0(linkaddr_t const *localdest)
{
  uint8_t __retres;
  int frag_needed;
  linkaddr_t dest;
  uint16_t tmp_0;
  int tmp_2;
  uncomp_hdr_len = (unsigned char)0;
  packetbuf_hdr_len = (unsigned char)0;
  packetbuf_clear();
  packetbuf_ptr = (uint8_t *)packetbuf_dataptr();
  if (callback) set_packet_attrs();
  if (localdest == (linkaddr_t const *)0) linkaddr_copy(& dest,
                                                        & linkaddr_null);
  else linkaddr_copy(& dest,localdest);
  {
    int tmp;
    if (0 < curr_log_level_6lowpan) tmp = 0;
    else tmp = curr_log_level_6lowpan;
    if (3 <= tmp) {
      printf("[%-4s: %-10s] ","INFO","6LoWPAN");
      printf("output: sending IPv6 packet with len %d\n",(int)uip_len);
    }
  }
  tmp_0 = uipbuf_get_attr((unsigned char)UIPBUF_ATTR_MAX_MAC_TRANSMISSIONS);
  packetbuf_set_attr((unsigned char)PACKETBUF_ATTR_MAX_MAC_TRANSMISSIONS,
                     tmp_0);
  packetbuf_set_addr((unsigned char)PACKETBUF_ADDR_RECEIVER,
                     (linkaddr_t const *)(& dest));
  mac_max_payload = (*(nullmac_driver.max_payload))();
  if (mac_max_payload <= 0) {
    {
      int tmp_1;
      if (0 < curr_log_level_6lowpan) tmp_1 = 0;
      else tmp_1 = curr_log_level_6lowpan;
      if (2 <= tmp_1) {
        printf("[%-4s: %-10s] ","WARN","6LoWPAN");
        printf("output: failed to calculate payload size - dropping packet\n");
      }
    }
    __retres = (unsigned char)0;
    goto return_label;
  }
  tmp_2 = compress_hdr_iphc(& dest);
  if (tmp_2 == 0) {
    __retres = (unsigned char)0;
    goto return_label;
  }
  packetbuf_set_addr((unsigned char)PACKETBUF_ADDR_RECEIVER,
                     (linkaddr_t const *)(& dest));
  frag_needed = ((int)uip_len - (int)uncomp_hdr_len) + (int)packetbuf_hdr_len > mac_max_payload;
  {
    int tmp_3;
    if (0 < curr_log_level_6lowpan) tmp_3 = 0;
    else tmp_3 = curr_log_level_6lowpan;
    if (3 <= tmp_3) {
      printf("[%-4s: %-10s] ","INFO","6LoWPAN");
      printf("output: header len %d -> %d, total len %d -> %d, MAC max payload %d, frag_needed %d\n",
             (int)uncomp_hdr_len,(int)packetbuf_hdr_len,(int)uip_len,
             ((int)uip_len - (int)uncomp_hdr_len) + (int)packetbuf_hdr_len,
             mac_max_payload,frag_needed);
    }
  }
  if (frag_needed) {
    uint16_t processed_ip_out_len;
    uint16_t frag_tag;
    int tmp_4;
    int tmp_5;
    uint16_t tmp_9;
    int tmp_11;
    int curr_frag = 0;
    int total_payload = (int)uip_len - (int)uncomp_hdr_len;
    int frag1_payload =
      (int)((unsigned int)((mac_max_payload - (int)packetbuf_hdr_len) - 4) & 0xfffffff8);
    int fragn_max_payload =
      (int)((unsigned int)(mac_max_payload - 5) & 0xfffffff8);
    int last_fragn_max_payload = mac_max_payload - 5;
    if ((total_payload - frag1_payload) - last_fragn_max_payload < 0) 
      tmp_4 = 0;
    else tmp_4 = (total_payload - frag1_payload) - last_fragn_max_payload;
    int middle_fragn_total_payload = tmp_4;
    int fragment_count = 2;
    if (middle_fragn_total_payload > 0) fragment_count += 1 + (middle_fragn_total_payload - 1) / fragn_max_payload;
    tmp_5 = queuebuf_numfree();
    int freebuf = tmp_5 - 1;
    {
      int tmp_6;
      if (0 < curr_log_level_6lowpan) tmp_6 = 0;
      else tmp_6 = curr_log_level_6lowpan;
      if (3 <= tmp_6) {
        printf("[%-4s: %-10s] ","INFO","6LoWPAN");
        printf("output: fragmentation needed, fragments: %u, free queuebufs: %u\n",
               fragment_count,freebuf);
      }
    }
    if (freebuf < fragment_count) {
      {
        int tmp_7;
        if (0 < curr_log_level_6lowpan) tmp_7 = 0;
        else tmp_7 = curr_log_level_6lowpan;
        if (2 <= tmp_7) {
          printf("[%-4s: %-10s] ","WARN","6LoWPAN");
          printf("output: dropping packet, not enough free bufs (needed: %u, free: %u)\n",
                 fragment_count,freebuf);
        }
      }
      __retres = (unsigned char)0;
      goto return_label;
    }
    if (frag1_payload < 0) {
      {
        int tmp_8;
        if (0 < curr_log_level_6lowpan) tmp_8 = 0;
        else tmp_8 = curr_log_level_6lowpan;
        if (2 <= tmp_8) {
          printf("[%-4s: %-10s] ","WARN","6LoWPAN");
          printf("output: compressed header does not fit first fragment\n");
        }
      }
      __retres = (unsigned char)0;
      goto return_label;
    }
    last_tx_status = MAC_TX_OK;
    tmp_9 = my_tag;
    my_tag = (uint16_t)((int)my_tag + 1);
    frag_tag = tmp_9;
    memmove((void *)(packetbuf_ptr + 4),(void const *)packetbuf_ptr,
            (unsigned long)packetbuf_hdr_len);
    packetbuf_hdr_len = (unsigned char)((int)packetbuf_hdr_len + 4);
    *(packetbuf_ptr + 0) = (unsigned char)((((0xc0 << 8) | (int)uip_len) >> 8) & 0xff);
    *(packetbuf_ptr + (0 + 1)) = (unsigned char)(((0xc0 << 8) | (int)uip_len) & 0xff);
    *(packetbuf_ptr + 2) = (unsigned char)(((int)frag_tag >> 8) & 0xff);
    *(packetbuf_ptr + (2 + 1)) = (unsigned char)((int)frag_tag & 0xff);
    packetbuf_payload_len = frag1_payload;
    {
      int tmp_10;
      if (0 < curr_log_level_6lowpan) tmp_10 = 0;
      else tmp_10 = curr_log_level_6lowpan;
      if (3 <= tmp_10) {
        printf("[%-4s: %-10s] ","INFO","6LoWPAN");
        printf("output: fragment %d/%d (tag %d, payload %d)\n",curr_frag + 1,
               fragment_count,(int)frag_tag,packetbuf_payload_len);
      }
    }
    tmp_11 = fragment_copy_payload_and_send((unsigned short)uncomp_hdr_len,
                                            & dest);
    if (tmp_11 == 0) {
      __retres = (unsigned char)0;
      goto return_label;
    }
    packetbuf_hdr_len = (unsigned char)5;
    *(packetbuf_ptr + 0) = (unsigned char)((((0xe0 << 8) | (int)uip_len) >> 8) & 0xff);
    *(packetbuf_ptr + (0 + 1)) = (unsigned char)(((0xe0 << 8) | (int)uip_len) & 0xff);
    processed_ip_out_len = (unsigned short)((int)uncomp_hdr_len + packetbuf_payload_len);
    while ((int)processed_ip_out_len < (int)uip_len) {
      int tmp_13;
      curr_frag ++;
      *(packetbuf_ptr + 4) = (unsigned char)((int)processed_ip_out_len >> 3);
      if ((int)uip_len - (int)processed_ip_out_len > last_fragn_max_payload) 
        packetbuf_payload_len = fragn_max_payload;
      else packetbuf_payload_len = (int)uip_len - (int)processed_ip_out_len;
      {
        int tmp_12;
        if (0 < curr_log_level_6lowpan) tmp_12 = 0;
        else tmp_12 = curr_log_level_6lowpan;
        if (3 <= tmp_12) {
          printf("[%-4s: %-10s] ","INFO","6LoWPAN");
          printf("output: fragment %d/%d (tag %d, payload %d, offset %d)\n",
                 curr_frag + 1,fragment_count,(int)frag_tag,
                 packetbuf_payload_len,(int)processed_ip_out_len);
        }
      }
      tmp_13 = fragment_copy_payload_and_send(processed_ip_out_len,& dest);
      if (tmp_13 == 0) {
        __retres = (unsigned char)0;
        goto return_label;
      }
      processed_ip_out_len = (unsigned short)((int)processed_ip_out_len + packetbuf_payload_len);
    }
  }
  else {
    memcpy((void *)(packetbuf_ptr + (int)packetbuf_hdr_len),
           (void const *)(& uip_aligned_buf.u8[uncomp_hdr_len]),
           (unsigned long)((int)uip_len - (int)uncomp_hdr_len));
    packetbuf_set_datalen((unsigned short)(((int)uip_len - (int)uncomp_hdr_len) + (int)packetbuf_hdr_len));
    send_packet_0(& dest);
  }
  __retres = (unsigned char)1;
  return_label: return __retres;
}

static void input_0(void)
{
  uint8_t *buffer;
  linkaddr_t const *tmp;
  uint16_t tmp_1;
  packetbuf_attr_t tmp_2;
  uint16_t tmp_12;
  uint16_t tmp_13;
  uint16_t frag_size = (unsigned short)0;
  uint8_t frag_offset = (unsigned char)0;
  uint8_t is_fragment = (unsigned char)0;
  int8_t frag_context = (signed char)0;
  uint16_t frag_tag = (unsigned short)0;
  uint8_t first_fragment = (unsigned char)0;
  uint8_t last_fragment = (unsigned char)0;
  tmp = packetbuf_addr((unsigned char)PACKETBUF_ADDR_SENDER);
  link_stats_input_callback(tmp);
  uncomp_hdr_len = (unsigned char)0;
  packetbuf_hdr_len = (unsigned char)0;
  packetbuf_ptr = (uint8_t *)packetbuf_dataptr();
  tmp_1 = packetbuf_datalen();
  if ((int)tmp_1 == 0) {
    {
      int tmp_0;
      if (0 < curr_log_level_6lowpan) tmp_0 = 0;
      else tmp_0 = curr_log_level_6lowpan;
      if (2 <= tmp_0) {
        printf("[%-4s: %-10s] ","WARN","6LoWPAN");
        printf("input: empty packet\n");
      }
    }
    goto return_label;
  }
  uipbuf_clear();
  buffer = uip_aligned_buf.u8;
  tmp_2 = packetbuf_attr((unsigned char)PACKETBUF_ATTR_RSSI);
  last_rssi = (int)((short)tmp_2);
  switch ((((int)((unsigned short)((int)*(packetbuf_ptr + 0) << 8)) | (int)*(
            packetbuf_ptr + (0 + 1))) >> 8) & 0xf8) {
    case 0xc0: frag_offset = (unsigned char)0;
    frag_size = (unsigned short)(((int)((unsigned short)((int)*(packetbuf_ptr + 0) << 8)) | (int)*(
                                  packetbuf_ptr + (0 + 1))) & 0x07ff);
    frag_tag = (unsigned short)((int)((unsigned short)((int)*(packetbuf_ptr + 2) << 8)) | (int)*(
                                packetbuf_ptr + (2 + 1)));
    packetbuf_hdr_len = (unsigned char)((int)packetbuf_hdr_len + 4);
    first_fragment = (unsigned char)1;
    is_fragment = (unsigned char)1;
    {
      int tmp_3;
      if (0 < curr_log_level_6lowpan) tmp_3 = 0;
      else tmp_3 = curr_log_level_6lowpan;
      if (3 <= tmp_3) {
        printf("[%-4s: %-10s] ","INFO","6LoWPAN");
        printf("input: received first element of a fragmented packet (tag %d, len %d)\n",
               (int)frag_tag,(int)frag_size);
      }
    }
    frag_context = add_fragment(frag_tag,frag_size,frag_offset);
    if ((int)frag_context == -1) {
      {
        int tmp_4;
        if (0 < curr_log_level_6lowpan) tmp_4 = 0;
        else tmp_4 = curr_log_level_6lowpan;
        if (1 <= tmp_4) {
          printf("[%-4s: %-10s] ","ERR","6LoWPAN");
          printf("input: failed to allocate new reassembly context\n");
        }
      }
      goto return_label;
    }
    buffer = frag_info[frag_context].first_frag;
    break;
    case 0xe0: frag_offset = *(packetbuf_ptr + 4);
    frag_tag = (unsigned short)((int)((unsigned short)((int)*(packetbuf_ptr + 2) << 8)) | (int)*(
                                packetbuf_ptr + (2 + 1)));
    frag_size = (unsigned short)(((int)((unsigned short)((int)*(packetbuf_ptr + 0) << 8)) | (int)*(
                                  packetbuf_ptr + (0 + 1))) & 0x07ff);
    packetbuf_hdr_len = (unsigned char)((int)packetbuf_hdr_len + 5);
    frag_context = add_fragment(frag_tag,frag_size,frag_offset);
    if ((int)frag_context == -1) {
      {
        int tmp_5;
        if (0 < curr_log_level_6lowpan) tmp_5 = 0;
        else tmp_5 = curr_log_level_6lowpan;
        if (1 <= tmp_5) {
          printf("[%-4s: %-10s] ","ERR","6LoWPAN");
          printf("input: reassembly context not found (tag %d)\n",
                 (int)frag_tag);
        }
      }
      goto return_label;
    }
    buffer = (uint8_t *)0;
    if ((int)frag_info[frag_context].reassembled_len >= (int)frag_size) 
      last_fragment = (unsigned char)1;
    is_fragment = (unsigned char)1;
    break;
    default: break;
  }
  if (is_fragment) 
    if (! first_fragment) goto copypayload;
  curr_page = (unsigned char)0;
  digest_paging_dispatch();
  if ((int)curr_page == 1) {
    {
      int tmp_6;
      if (0 < curr_log_level_6lowpan) tmp_6 = 0;
      else tmp_6 = curr_log_level_6lowpan;
      if (3 <= tmp_6) {
        printf("[%-4s: %-10s] ","INFO","6LoWPAN");
        printf("input: page 1, 6LoRH\n");
      }
    }
    digest_6lorh_hdr();
  }
  else 
    if ((int)curr_page > 1) {
      {
        int tmp_7;
        if (0 < curr_log_level_6lowpan) tmp_7 = 0;
        else tmp_7 = curr_log_level_6lowpan;
        if (1 <= tmp_7) {
          printf("[%-4s: %-10s] ","ERR","6LoWPAN");
          printf("input: page %u not supported\n",(int)curr_page);
        }
      }
      goto return_label;
    }
  if (((int)*((packetbuf_ptr + (int)packetbuf_hdr_len) + 0) & 0xe0) == 0x60) {
    {
      int tmp_8;
      if (0 < curr_log_level_6lowpan) tmp_8 = 0;
      else tmp_8 = curr_log_level_6lowpan;
      if (4 <= tmp_8) {
        printf("[%-4s: %-10s] ","DBG","6LoWPAN");
        printf("uncompression: IPHC dispatch\n");
      }
    }
    uncompress_hdr_iphc(buffer,frag_size);
  }
  else 
    if ((int)*((packetbuf_ptr + (int)packetbuf_hdr_len) + 0) == 0x41) {
      {
        int tmp_9;
        if (0 < curr_log_level_6lowpan) tmp_9 = 0;
        else tmp_9 = curr_log_level_6lowpan;
        if (4 <= tmp_9) {
          printf("[%-4s: %-10s] ","DBG","6LoWPAN");
          printf("uncompression: IPV6 dispatch\n");
        }
      }
      packetbuf_hdr_len = (unsigned char)((int)packetbuf_hdr_len + 1);
      memcpy((void *)buffer,
             (void const *)(packetbuf_ptr + (int)packetbuf_hdr_len),
             (unsigned long)40);
      packetbuf_hdr_len = (unsigned char)((int)packetbuf_hdr_len + 40);
      uncomp_hdr_len = (unsigned char)((int)uncomp_hdr_len + 40);
    }
    else {
      {
        int tmp_10;
        if (0 < curr_log_level_6lowpan) tmp_10 = 0;
        else tmp_10 = curr_log_level_6lowpan;
        if (1 <= tmp_10) {
          printf("[%-4s: %-10s] ","ERR","6LoWPAN");
          printf("uncompression: unknown dispatch: 0x%02x\n",
                 (int)*((packetbuf_ptr + (int)packetbuf_hdr_len) + 0) & 0xe0);
        }
      }
      goto return_label;
    }
  copypayload: { /* sequence */
                 tmp_12 = packetbuf_datalen();
                 ;
               }
  if ((int)tmp_12 < (int)packetbuf_hdr_len) {
    {
      int tmp_11;
      if (0 < curr_log_level_6lowpan) tmp_11 = 0;
      else tmp_11 = curr_log_level_6lowpan;
      if (1 <= tmp_11) {
        printf("[%-4s: %-10s] ","ERR","6LoWPAN");
        printf("input: packet dropped due to header > total packet\n");
      }
    }
    goto return_label;
  }
  tmp_13 = packetbuf_datalen();
  packetbuf_payload_len = (int)tmp_13 - (int)packetbuf_hdr_len;
  if (is_fragment) {
    int tmp_15;
    if (0 < curr_log_level_6lowpan) tmp_15 = 0;
    else tmp_15 = curr_log_level_6lowpan;
    if (3 <= tmp_15) {
      uint16_t tmp_14;
      printf("[%-4s: %-10s] ","INFO","6LoWPAN");
      ;
      tmp_14 = packetbuf_datalen();
      ;
      ;
      ;
      printf("input: fragment (tag %d, payload %d, offset %d) -- %u %u\n",
             (int)frag_tag,packetbuf_payload_len,(int)frag_offset << 3,
             (int)tmp_14,(int)packetbuf_hdr_len);
    }
  }
  {
    int req_size =
      ((int)uncomp_hdr_len + (int)((unsigned short)((int)frag_offset << 3))) + packetbuf_payload_len;
    if ((unsigned long)req_size > sizeof(uip_aligned_buf.u8)) {
      {
        int tmp_16;
        if (0 < curr_log_level_6lowpan) tmp_16 = 0;
        else tmp_16 = curr_log_level_6lowpan;
        if (1 <= tmp_16) {
          printf("[%-4s: %-10s] ","ERR","6LoWPAN");
          printf("input: packet dropped, minimum required IP_BUF size: %d+%d+%d=%d (current size: %u)\n",
                 (int)uncomp_hdr_len,
                 (int)((unsigned short)((int)frag_offset << 3)),
                 packetbuf_payload_len,req_size,
                 (unsigned int)sizeof(uip_aligned_buf.u8));
        }
      }
      goto return_label;
    }
  }
  if (buffer != (uint8_t *)0) memcpy((void *)(buffer + (int)uncomp_hdr_len),
                                     (void const *)(packetbuf_ptr + (int)packetbuf_hdr_len),
                                     (unsigned long)packetbuf_payload_len);
  if ((int)frag_size > 0) {
    if ((int)first_fragment != 0) {
      frag_info[frag_context].reassembled_len = (unsigned short)((int)uncomp_hdr_len + packetbuf_payload_len);
      frag_info[frag_context].first_frag_len = (unsigned short)((int)uncomp_hdr_len + packetbuf_payload_len);
    }
    if ((int)last_fragment != 0) {
      frag_info[frag_context].reassembled_len = frag_size;
      copy_frags2uip((int)frag_context);
    }
  }
  if (! is_fragment) goto _LOR;
  else 
    if (last_fragment) {
      _LOR:
      {
        int tmp_21;
        if ((int)is_fragment != 0) {
          if ((int)last_fragment != 0) uip_len = frag_size; else goto _LAND;
        }
        else _LAND:
             uip_len = (unsigned short)(packetbuf_payload_len + (int)uncomp_hdr_len);
        {
          int tmp_17;
          if (0 < curr_log_level_6lowpan) tmp_17 = 0;
          else tmp_17 = curr_log_level_6lowpan;
          if (3 <= tmp_17) {
            printf("[%-4s: %-10s] ","INFO","6LoWPAN");
            printf("input: received IPv6 packet with len %d\n",(int)uip_len);
          }
        }
        if (0 < curr_log_level_6lowpan) tmp_21 = 0;
        else tmp_21 = curr_log_level_6lowpan;
        if (tmp_21 >= 4) {
          uint16_t ndx;
          {
            int tmp_18;
            if (0 < curr_log_level_6lowpan) tmp_18 = 0;
            else tmp_18 = curr_log_level_6lowpan;
            if (4 <= tmp_18) {
              printf("[%-4s: %-10s] ","DBG","6LoWPAN");
              printf("uncompression: after (%u):",
                     (int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->len[1]);
            }
          }
          ndx = (unsigned short)0;
          while ((int)ndx < (int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->len[1] + 40) {
            {
              uint8_t data = uip_aligned_buf.u8[ndx];
              {
                int tmp_19;
                if (0 < curr_log_level_6lowpan) tmp_19 = 0;
                else tmp_19 = curr_log_level_6lowpan;
                if (4 <= tmp_19) printf("%02x",(int)data);
              }
            }
            ndx = (uint16_t)((int)ndx + 1);
          }
          {
            int tmp_20;
            if (0 < curr_log_level_6lowpan) tmp_20 = 0;
            else tmp_20 = curr_log_level_6lowpan;
            if (4 <= tmp_20) printf("\n");
          }
        }
        if (callback) {
          set_packet_attrs();
          (*(callback->input_callback))();
        }
        tcpip_input();
      }
    }
  return_label: return;
}

void sicslowpan_init(void)
{
  addr_contexts[0].used = (unsigned char)1;
  addr_contexts[0].number = (unsigned char)0;
  addr_contexts[0].prefix[0] = (unsigned char)((0xfd00 >> 8) & 0xff);
  addr_contexts[0].prefix[1] = (unsigned char)(0xfd00 & 0xff);
  return;
}

int sicslowpan_get_last_rssi(void)
{
  return last_rssi;
}

struct network_driver const sicslowpan_driver =
  {.name = (char *)"sicslowpan",
   .init = & sicslowpan_init,
   .input = & input_0,
   .output = & output_0};
__inline static unsigned int __bswap_32_74(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_74(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

int uiplib_ip6addrconv(char const *addrstr, uip_ip6addr_t *ipaddr)
{
  int __retres;
  uint16_t value;
  int tmp;
  int zero;
  unsigned int len;
  char c = (char)0;
  value = (unsigned short)0;
  zero = -1;
  if ((int)*addrstr == '[') addrstr ++;
  len = (unsigned int)0;
  while ((unsigned long)len < sizeof(uip_ip6addr_t) - (unsigned long)1) {
    c = *addrstr;
    if ((int)c == ':') goto _LOR_0;
    else 
      if ((int)c == '\000') goto _LOR_0;
      else 
        if ((int)c == ']') goto _LOR_0;
        else 
          if ((int)c == '/') {
            _LOR_0:
            {
              ipaddr->u8[len] = (unsigned char)(((int)value >> 8) & 0xff);
              ipaddr->u8[len + (unsigned int)1] = (unsigned char)((int)value & 0xff);
              len += (unsigned int)2;
              value = (unsigned short)0;
              if ((int)c == '\000') goto _LOR;
              else 
                if ((int)c == ']') goto _LOR;
                else 
                  if ((int)c == '/') _LOR: break;
              if ((int)*(addrstr + 1) == ':') {
                if (zero < 0) zero = (int)len;
                addrstr ++;
              }
            }
          }
          else {
            if ((int)c >= '0') {
              if ((int)c <= '9') tmp = (int)c - '0'; else goto _LAND_1;
            }
            else {
              _LAND_1: ;
              if ((int)c >= 'a') {
                if ((int)c <= 'f') tmp = ((int)c - 'a') + 10;
                else goto _LAND_0;
              }
              else {
                _LAND_0: ;
                if ((int)c >= 'A') {
                  if ((int)c <= 'F') tmp = ((int)c - 'A') + 10;
                  else goto _LAND;
                }
                else {
                  _LAND:
                  {
                    if (1 <= 0) {
                      printf("[%-4s: %-10s] ","ERR","uiplib");
                      printf("illegal char: \'%c\'\n",(int)c);
                    }
                    __retres = 0;
                    goto return_label;
                  }
                }
              }
            }
            value = (unsigned short)(((int)value << 4) + (tmp & 0xf));
          }
    addrstr ++;
  }
  if ((int)c != '\000') 
    if ((int)c != ']') 
      if ((int)c != '/') {
        if (1 <= 0) {
          printf("[%-4s: %-10s] ","ERR","uiplib");
          printf("too large address\n");
        }
        __retres = 0;
        goto return_label;
      }
  if ((unsigned long)len < sizeof(uip_ip6addr_t)) {
    if (zero < 0) {
      if (1 <= 0) {
        printf("[%-4s: %-10s] ","ERR","uiplib");
        printf("too short address\n");
      }
      __retres = 0;
      goto return_label;
    }
    memmove((void *)(& ipaddr->u8[((unsigned long)zero + sizeof(uip_ip6addr_t)) - (unsigned long)len]),
            (void const *)(& ipaddr->u8[zero]),
            (unsigned long)(len - (unsigned int)zero));
    memset((void *)(& ipaddr->u8[zero]),0,
           sizeof(uip_ip6addr_t) - (unsigned long)len);
  }
  __retres = 1;
  return_label: return __retres;
}

int uiplib_ip4addrconv(char const *addrstr, uip_ip4addr_t *ipaddr)
{
  int __retres;
  unsigned char tmp;
  char c;
  unsigned char i;
  unsigned char j;
  uint8_t charsread = (unsigned char)0;
  tmp = (unsigned char)0;
  i = (unsigned char)0;
  while ((int)i < 4) {
    j = (unsigned char)0;
    while (1) {
      c = *addrstr;
      j = (unsigned char)((int)j + 1);
      if ((int)j > 4) {
        __retres = 0;
        goto return_label;
      }
      if ((int)c == '.') goto _LOR;
      else 
        if ((int)c == 0) goto _LOR;
        else 
          if ((int)c == ' ') {
            _LOR: {
                    ipaddr->u8[i] = tmp;
                    tmp = (unsigned char)0;
                  }
          }
          else 
            if ((int)c >= '0') {
              if ((int)c <= '9') tmp = (unsigned char)((int)tmp * 10 + (
                                                       (int)c - '0'));
              else goto _LAND;
            }
            else {
              _LAND: {
                       __retres = 0;
                       goto return_label;
                     }
            }
      addrstr ++;
      charsread = (uint8_t)((int)charsread + 1);
      if ((int)c != '.') 
        if ((int)c != 0) {
          if (! ((int)c != ' ')) break;
        }
        else break;
      else break;
    }
    i = (unsigned char)((int)i + 1);
  }
  __retres = (int)charsread - 1;
  return_label: return __retres;
}

void uiplib_ipaddr_print(uip_ipaddr_t const *addr_0)
{
  char buf_0[40];
  uiplib_ipaddr_snprint(buf_0,sizeof(buf_0),addr_0);
  printf("%s",buf_0);
  return;
}

int uiplib_ipaddr_snprint(char *buf_0, size_t size,
                          uip_ipaddr_t const *addr_0)
{
  int __retres;
  uint16_t a;
  unsigned int i;
  int f;
  int n = 0;
  if (size == (size_t)0) {
    __retres = 0;
    goto return_label;
  }
  if (addr_0 == (uip_ipaddr_t const *)0) {
    n = snprintf(buf_0,size,"(NULL IP addr)");
    __retres = n;
    goto return_label;
  }
  else 
    if ((int)addr_0->u16[0] == 0) {
      if ((int)addr_0->u16[1] == 0) {
        if ((int)addr_0->u16[2] == 0) {
          if ((int)addr_0->u16[3] == 0) {
            if ((int)addr_0->u16[4] == 0) {
              if ((int)addr_0->u16[5] == 0xFFFF) {
                n = snprintf(buf_0,size,"::FFFF:%u.%u.%u.%u",
                             (int)addr_0->u8[12],(int)addr_0->u8[13],
                             (int)addr_0->u8[14],(int)addr_0->u8[15]);
                __retres = n;
                goto return_label;
              }
              else goto _LAND_4;
            }
            else goto _LAND_4;
          }
          else goto _LAND_4;
        }
        else goto _LAND_4;
      }
      else goto _LAND_4;
    }
    else {
      _LAND_4:
      {
        i = (unsigned int)0;
        f = 0;
        while ((unsigned long)i < sizeof(uip_ipaddr_t)) {
          a = (unsigned short)(((int)addr_0->u8[i] << 8) + (int)addr_0->u8[
                               i + (unsigned int)1]);
          if ((int)a == 0) {
            if (f >= 0) {
              int tmp_0;
              tmp_0 = f;
              f ++;
              ;
              if (tmp_0 == 0) {
                int tmp;
                tmp = snprintf(buf_0 + n,size - (size_t)n,"::");
                n += tmp;
                if ((size_t)n >= size) {
                  __retres = n;
                  goto return_label;
                }
              }
            }
            else goto _LAND;
          }
          else {
            _LAND:
            {
              int tmp_2;
              if (f > 0) f = -1;
              else 
                if (i > (unsigned int)0) {
                  int tmp_1;
                  tmp_1 = snprintf(buf_0 + n,size - (size_t)n,":");
                  n += tmp_1;
                  if ((size_t)n >= size) {
                    __retres = n;
                    goto return_label;
                  }
                }
              tmp_2 = snprintf(buf_0 + n,size - (size_t)n,"%x",(int)a);
              n += tmp_2;
              if ((size_t)n >= size) {
                __retres = n;
                goto return_label;
              }
            }
          }
          i += (unsigned int)2;
        }
      }
    }
  __retres = n;
  return_label: return __retres;
}

__inline static unsigned int __bswap_32_75(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_75(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static int num_parents;
static int num_free;
static linkaddr_t const *worst_rank_nbr_lladdr;
static rpl_rank_t worst_rank;
static void update_state(void)
{
  uip_ds6_nbr_t *ds6_nbr;
  rpl_nbr_t *rpl_nbr;
  rpl_rank_t nbr_rank;
  int num_used = 0;
  worst_rank = (unsigned short)0;
  worst_rank_nbr_lladdr = (linkaddr_t const *)0;
  num_parents = 0;
  ds6_nbr = uip_ds6_nbr_head();
  while (ds6_nbr != (uip_ds6_nbr_t *)0) {
    linkaddr_t const *nbr_lladdr =
      uip_ds6_nbr_get_ll((uip_ds6_nbr_t const *)ds6_nbr);
    rpl_nbr = rpl_neighbor_get_from_lladdr((uip_lladdr_t *)nbr_lladdr);
    if (rpl_nbr != (rpl_nbr_t *)0) {
      int tmp_0;
      tmp_0 = rpl_neighbor_is_parent(rpl_nbr);
      if (tmp_0) num_parents ++;
    }
    nbr_rank = rpl_neighbor_rank_via_nbr(rpl_nbr);
    if (rpl_nbr != curr_instance.dag.preferred_parent) 
      if ((int)nbr_rank > (int)worst_rank) {
        worst_rank = nbr_rank;
        worst_rank_nbr_lladdr = nbr_lladdr;
      }
    ds6_nbr = uip_ds6_nbr_next(ds6_nbr);
    num_used ++;
  }
  num_free = 300 - num_used;
  {
    int tmp_1;
    if (0 < curr_log_level_rpl) tmp_1 = 0; else tmp_1 = curr_log_level_rpl;
    if (4 <= tmp_1) {
      printf("[%-4s: %-10s] ","DBG","RPL");
      printf("nbr-policy: free: %d, parents: %d\n",num_free,num_parents);
    }
  }
  return;
}

static linkaddr_t const *find_worst_rank_nbr_lladdr(void)
{
  update_state();
  return worst_rank_nbr_lladdr;
}

static linkaddr_t const *find_removable_dio(uip_ipaddr_t *from,
                                            rpl_dio_t *dio)
{
  linkaddr_t const *__retres;
  update_state();
  if (! curr_instance.used) goto _LOR;
  else 
    if ((int)curr_instance.instance_id != (int)dio->instance_id) {
      _LOR:
      {
        {
          int tmp;
          if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
          if (2 <= tmp) {
            printf("[%-4s: %-10s] ","WARN","RPL");
            printf("nbr-policy: did not find instance id: %d\n",
                   (int)dio->instance_id);
          }
        }
        __retres = (linkaddr_t const *)0;
        goto return_label;
      }
    }
  if ((int)dio->rank + (int)curr_instance.min_hoprankinc < (int)worst_rank - 
                                                           (int)curr_instance.min_hoprankinc / 2) {
    {
      int tmp_0;
      if (0 < curr_log_level_rpl) tmp_0 = 0; else tmp_0 = curr_log_level_rpl;
      if (4 <= tmp_0) {
        printf("[%-4s: %-10s] ","DBG","RPL");
        printf("nbr-policy: DIO rank %u, worst_rank %u -- add to cache\n",
               (int)dio->rank,(int)worst_rank);
      }
    }
    __retres = worst_rank_nbr_lladdr;
    goto return_label;
  }
  {
    int tmp_1;
    if (0 < curr_log_level_rpl) tmp_1 = 0; else tmp_1 = curr_log_level_rpl;
    if (4 <= tmp_1) {
      printf("[%-4s: %-10s] ","DBG","RPL");
      printf("nbr-policy: DIO rank %u, worst_rank %u -- do not add to cache\n",
             (int)dio->rank,(int)worst_rank);
    }
  }
  __retres = (linkaddr_t const *)0;
  return_label: return __retres;
}

linkaddr_t const *rpl_nbr_policy_find_removable(nbr_table_reason_t reason,
                                                void *data)
{
  linkaddr_t const *__retres;
  switch (reason) {
    linkaddr_t const *tmp;
    linkaddr_t const *tmp_0;
    linkaddr_t const *tmp_1;
    case (nbr_table_reason_t)NBR_TABLE_REASON_RPL_DIO:
    tmp = find_removable_dio(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr,
                             (rpl_dio_t *)data);
    __retres = tmp;
    goto return_label;
    case (nbr_table_reason_t)NBR_TABLE_REASON_RPL_DIS:
    tmp_0 = find_worst_rank_nbr_lladdr();
    __retres = tmp_0;
    goto return_label;
    case (nbr_table_reason_t)NBR_TABLE_REASON_IPV6_ND_AUTOFILL:
    tmp_1 = find_worst_rank_nbr_lladdr();
    __retres = tmp_1;
    goto return_label;
    default: __retres = (linkaddr_t const *)0;
    goto return_label;
  }
  return_label: return __retres;
}

__inline static unsigned int __bswap_32_76(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_76(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static void reset(void)
{
  int tmp;
  if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
  if (3 <= tmp) {
    printf("[%-4s: %-10s] ","INFO","RPL");
    printf("reset OF0\n");
  }
  return;
}

static uint16_t nbr_link_metric(rpl_nbr_t *nbr_0)
{
  uint16_t __retres;
  int tmp_0;
  struct link_stats const *stats = rpl_neighbor_get_link_stats(nbr_0);
  if (stats != (struct link_stats const *)0) tmp_0 = (int)stats->etx;
  else tmp_0 = 0xffff;
  __retres = (unsigned short)tmp_0;
  return __retres;
}

static uint16_t nbr_rank_increase(rpl_nbr_t *nbr_0)
{
  uint16_t __retres;
  uint16_t min_hoprankinc;
  uint16_t tmp;
  if (nbr_0 == (rpl_nbr_t *)0) {
    __retres = (unsigned short)0xFFFF;
    goto return_label;
  }
  min_hoprankinc = curr_instance.min_hoprankinc;
  tmp = nbr_link_metric(nbr_0);
  ;
  __retres = (unsigned short)((1 * ((3 * (int)tmp) / 128 - 2) + 0) * (int)min_hoprankinc);
  return_label: return __retres;
}

static uint16_t nbr_path_cost(rpl_nbr_t *nbr_0)
{
  uint16_t __retres;
  unsigned int tmp_1;
  uint16_t tmp;
  if (nbr_0 == (rpl_nbr_t *)0) {
    __retres = (unsigned short)0xffff;
    goto return_label;
  }
  tmp = nbr_link_metric(nbr_0);
  ;
  if ((unsigned int)nbr_0->rank + (unsigned int)tmp < (unsigned int)0xffff) {
    uint16_t tmp_0;
    tmp_0 = nbr_link_metric(nbr_0);
    tmp_1 = (unsigned int)nbr_0->rank + (unsigned int)tmp_0;
  }
  else tmp_1 = (unsigned int)0xffff;
  __retres = (unsigned short)tmp_1;
  return_label: return __retres;
}

static rpl_rank_t rank_via_nbr(rpl_nbr_t *nbr_0)
{
  rpl_rank_t __retres;
  if (nbr_0 == (rpl_nbr_t *)0) {
    __retres = (unsigned short)0xFFFF;
    goto return_label;
  }
  else {
    unsigned int tmp_1;
    uint16_t tmp;
    tmp = nbr_rank_increase(nbr_0);
    ;
    if ((unsigned int)nbr_0->rank + (unsigned int)tmp < (unsigned int)0xFFFF) {
      uint16_t tmp_0;
      tmp_0 = nbr_rank_increase(nbr_0);
      tmp_1 = (unsigned int)nbr_0->rank + (unsigned int)tmp_0;
    }
    else tmp_1 = (unsigned int)0xFFFF;
    __retres = (unsigned short)tmp_1;
    goto return_label;
  }
  return_label: return __retres;
}

static int nbr_has_usable_link(rpl_nbr_t *nbr_0)
{
  int __retres;
  __retres = 1;
  return __retres;
}

static int nbr_is_acceptable_parent(rpl_nbr_t *nbr_0)
{
  int tmp_1;
  uint16_t tmp;
  tmp = nbr_link_metric(nbr_0);
  if ((3 * (int)tmp) / 128 - 2 >= 1) {
    uint16_t tmp_0;
    tmp_0 = nbr_link_metric(nbr_0);
    if ((3 * (int)tmp_0) / 128 - 2 <= 9) tmp_1 = 1; else tmp_1 = 0;
  }
  else tmp_1 = 0;
  return tmp_1;
}

static rpl_nbr_t *best_parent(rpl_nbr_t *nbr1, rpl_nbr_t *nbr2)
{
  rpl_nbr_t *__retres;
  uint16_t nbr1_cost;
  uint16_t nbr2_cost;
  int nbr1_is_acceptable;
  int nbr2_is_acceptable;
  int tmp_0;
  int tmp_2;
  if (nbr1 != (rpl_nbr_t *)0) {
    int tmp;
    tmp = nbr_is_acceptable_parent(nbr1);
    if (tmp) tmp_0 = 1; else tmp_0 = 0;
  }
  else tmp_0 = 0;
  nbr1_is_acceptable = tmp_0;
  if (nbr2 != (rpl_nbr_t *)0) {
    int tmp_1;
    tmp_1 = nbr_is_acceptable_parent(nbr2);
    if (tmp_1) tmp_2 = 1; else tmp_2 = 0;
  }
  else tmp_2 = 0;
  nbr2_is_acceptable = tmp_2;
  if (! nbr1_is_acceptable) {
    rpl_nbr_t *tmp_3;
    if (nbr2_is_acceptable) tmp_3 = nbr2; else tmp_3 = (rpl_nbr_t *)0;
    __retres = tmp_3;
    goto return_label;
  }
  if (! nbr2_is_acceptable) {
    rpl_nbr_t *tmp_4;
    if (nbr1_is_acceptable) tmp_4 = nbr1; else tmp_4 = (rpl_nbr_t *)0;
    __retres = tmp_4;
    goto return_label;
  }
  nbr1_cost = nbr_path_cost(nbr1);
  nbr2_cost = nbr_path_cost(nbr2);
  if ((int)nbr1_cost != (int)nbr2_cost) {
    rpl_nbr_t *tmp_5;
    if ((int)nbr1_cost < (int)nbr2_cost) tmp_5 = nbr1; else tmp_5 = nbr2;
    __retres = tmp_5;
    goto return_label;
  }
  else {
    rpl_nbr_t *tmp_8;
    uint16_t tmp_6;
    uint16_t tmp_7;
    if (nbr1 == curr_instance.dag.preferred_parent) goto _LOR;
    else 
      if (nbr2 == curr_instance.dag.preferred_parent) {
        _LOR:
        {
          __retres = curr_instance.dag.preferred_parent;
          goto return_label;
        }
      }
    tmp_6 = nbr_link_metric(nbr1);
    tmp_7 = nbr_link_metric(nbr2);
    if ((int)tmp_6 < (int)tmp_7) tmp_8 = nbr1; else tmp_8 = nbr2;
    __retres = tmp_8;
    goto return_label;
  }
  return_label: return __retres;
}

static void update_metric_container(void)
{
  curr_instance.mc.type = (unsigned char)0;
  return;
}

rpl_of_t rpl_of0 =
  {.reset = & reset,
   .nbr_link_metric = & nbr_link_metric,
   .nbr_has_usable_link = & nbr_has_usable_link,
   .nbr_is_acceptable_parent = & nbr_is_acceptable_parent,
   .nbr_path_cost = & nbr_path_cost,
   .rank_via_nbr = & rank_via_nbr,
   .best_parent = & best_parent,
   .update_metric_container = & update_metric_container,
   .ocp = (unsigned short)0};
__inline static unsigned int __bswap_32_77(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_77(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static rpl_nbr_t *best_parent_0(int fresh_only);

static rpl_nbr_t _rpl_neighbors_mem[300];
static nbr_table_t rpl_neighbors_struct =
  {.index = 0,
   .item_size = (int)sizeof(rpl_nbr_t),
   .callback = (nbr_table_callback *)0,
   .data = (nbr_table_item_t *)(_rpl_neighbors_mem)};
nbr_table_t *rpl_neighbors = & rpl_neighbors_struct;
static int max_acceptable_rank(void)
{
  int __retres;
  if ((int)curr_instance.max_rankinc == 0) {
    __retres = 0xFFFF;
    goto return_label;
  }
  else {
    unsigned int tmp;
    if ((unsigned int)curr_instance.dag.lowest_rank + (unsigned int)curr_instance.max_rankinc < (unsigned int)0xFFFF) 
      tmp = (unsigned int)curr_instance.dag.lowest_rank + (unsigned int)curr_instance.max_rankinc;
    else tmp = (unsigned int)0xFFFF;
    __retres = (int)tmp;
    goto return_label;
  }
  return_label: return __retres;
}

static int acceptable_rank(rpl_rank_t rank)
{
  int tmp_0;
  if ((int)rank != 0xFFFF) 
    if ((int)rank >= (int)curr_instance.min_hoprankinc) {
      int tmp;
      tmp = max_acceptable_rank();
      ;
      if ((int)rank <= tmp) tmp_0 = 1; else tmp_0 = 0;
    }
    else tmp_0 = 0;
  else tmp_0 = 0;
  return tmp_0;
}

int rpl_neighbor_snprint(char *buf_0, int buflen_0, rpl_nbr_t *nbr_0)
{
  int __retres;
  int tmp_18;
  int tmp_6;
  int tmp_8;
  int tmp_7;
  int tmp_12;
  int tmp_10;
  rpl_rank_t tmp_9;
  int tmp_13;
  int tmp_14;
  int tmp_15;
  rpl_rank_t tmp_16;
  uint16_t tmp_17;
  int index_0 = 0;
  rpl_nbr_t *best = best_parent_0(0);
  struct link_stats const *stats = rpl_neighbor_get_link_stats(nbr_0);
  clock_time_t clock_now = clock_time();
  {
    int tmp_5;
    uip_ipaddr_t *tmp_4;
    tmp_4 = rpl_neighbor_get_ipaddr(nbr_0);
    ;
    ;
    tmp_5 = uiplib_ipaddr_snprint(buf_0 + index_0,
                                  (unsigned long)(buflen_0 - index_0),
                                  (uip_ipaddr_t const *)tmp_4);
    index_0 += tmp_5;
  }
  if (index_0 >= buflen_0) {
    __retres = index_0;
    goto return_label;
  }
  if (nbr_0 == curr_instance.dag.preferred_parent) tmp_6 = 'p';
  else tmp_6 = ' ';
  tmp_7 = link_stats_is_fresh(stats);
  if (tmp_7) tmp_8 = 'f'; else tmp_8 = ' ';
  tmp_9 = rpl_neighbor_rank_via_nbr(nbr_0);
  tmp_10 = acceptable_rank(tmp_9);
  if (tmp_10) {
    int tmp_11;
    tmp_11 = rpl_neighbor_is_acceptable_parent(nbr_0);
    if (tmp_11) tmp_12 = 'a'; else tmp_12 = ' ';
  }
  else tmp_12 = ' ';
  if (nbr_0 == best) tmp_13 = 'b'; else tmp_13 = ' ';
  if ((int)nbr_0->rank == (int)curr_instance.min_hoprankinc) tmp_14 = 'r';
  else tmp_14 = ' ';
  if (stats != (struct link_stats const *)0) tmp_15 = (int)stats->freshness;
  else tmp_15 = 0;
  tmp_16 = rpl_neighbor_rank_via_nbr(nbr_0);
  tmp_17 = rpl_neighbor_get_link_metric(nbr_0);
  ;
  ;
  ;
  tmp_18 = snprintf(buf_0 + index_0,(unsigned long)(buflen_0 - index_0),
                    "%5u, %5u => %5u -- %2u %c%c%c%c%c",(int)nbr_0->rank,
                    (int)tmp_17,(int)tmp_16,tmp_15,tmp_14,tmp_13,tmp_12,
                    tmp_8,tmp_6);
  index_0 += tmp_18;
  if (index_0 >= buflen_0) {
    __retres = index_0;
    goto return_label;
  }
  if (stats->last_tx_time > (clock_time_t)0) {
    int tmp_19;
    tmp_19 = snprintf(buf_0 + index_0,(unsigned long)(buflen_0 - index_0),
                      " (last tx %u min ago",
                      (unsigned int)((clock_now - stats->last_tx_time) / (clock_time_t)(
                                     60 * 1000)));
    index_0 += tmp_19;
  }
  else {
    int tmp_20;
    tmp_20 = snprintf(buf_0 + index_0,(unsigned long)(buflen_0 - index_0),
                      " (no tx");
    index_0 += tmp_20;
  }
  if (index_0 >= buflen_0) {
    __retres = index_0;
    goto return_label;
  }
  if (nbr_0->better_parent_since > (clock_time_t)0) {
    int tmp_21;
    tmp_21 = snprintf(buf_0 + index_0,(unsigned long)(buflen_0 - index_0),
                      ", better since %u min)",
                      (unsigned int)((clock_now - nbr_0->better_parent_since) / (clock_time_t)(
                                     60 * 1000)));
    index_0 += tmp_21;
  }
  else {
    int tmp_22;
    tmp_22 = snprintf(buf_0 + index_0,(unsigned long)(buflen_0 - index_0),
                      ")");
    index_0 += tmp_22;
  }
  __retres = index_0;
  return_label: return __retres;
}

void rpl_neighbor_print_list(char const *str)
{
  if (curr_instance.used) {
    int curr_dio_interval = (int)curr_instance.dag.dio_intcurrent;
    int curr_rank = (int)curr_instance.dag.rank;
    rpl_nbr_t *nbr_0 = nbr_table_head(rpl_neighbors);
    {
      int tmp_0;
      if (0 < curr_log_level_rpl) tmp_0 = 0; else tmp_0 = curr_log_level_rpl;
      if (3 <= tmp_0) {
        printf("[%-4s: %-10s] ","INFO","RPL");
        printf("nbr: own state, addr ");
      }
    }
    {
      int tmp_3;
      if (0 < curr_log_level_rpl) tmp_3 = 0; else tmp_3 = curr_log_level_rpl;
      if (3 <= tmp_3) {
        uip_ipaddr_t const *tmp_2;
        tmp_2 = rpl_get_global_address();
        log_6addr(tmp_2);
      }
    }
    {
      int tmp_7;
      if (0 < curr_log_level_rpl) tmp_7 = 0; else tmp_7 = curr_log_level_rpl;
      if (3 <= tmp_7) {
        int tmp_4;
        int tmp_5;
        char const *tmp_6;
        ;
        tmp_4 = rpl_neighbor_count();
        ;
        tmp_5 = max_acceptable_rank();
        ;
        ;
        ;
        tmp_6 = rpl_dag_state_to_str(curr_instance.dag.state);
        printf(", DAG state: %s, MOP %u OCP %u rank %u max-rank %u, dioint %u, nbr count %u (%s)\n",
               tmp_6,(int)curr_instance.mop,(int)(curr_instance.of)->ocp,
               curr_rank,tmp_5,curr_dio_interval,tmp_4,str);
      }
    }
    while (nbr_0 != (rpl_nbr_t *)0) {
      char buf_0[120];
      rpl_neighbor_snprint(buf_0,(int)sizeof(buf_0),nbr_0);
      {
        int tmp_8;
        if (0 < curr_log_level_rpl) tmp_8 = 0;
        else tmp_8 = curr_log_level_rpl;
        if (3 <= tmp_8) {
          printf("[%-4s: %-10s] ","INFO","RPL");
          printf("nbr: %s\n",buf_0);
        }
      }
      nbr_0 = (rpl_nbr_t *)nbr_table_next(rpl_neighbors,
                                          (nbr_table_item_t *)nbr_0);
    }
    {
      int tmp_9;
      if (0 < curr_log_level_rpl) tmp_9 = 0; else tmp_9 = curr_log_level_rpl;
      if (3 <= tmp_9) {
        printf("[%-4s: %-10s] ","INFO","RPL");
        printf("nbr: end of list\n");
      }
    }
  }
  return;
}

int rpl_neighbor_count(void)
{
  int count = 0;
  rpl_nbr_t *nbr_0 = nbr_table_head(rpl_neighbors);
  nbr_0 = (rpl_nbr_t *)nbr_table_head(rpl_neighbors);
  while (nbr_0 != (rpl_nbr_t *)0) {
    count ++;
    nbr_0 = (rpl_nbr_t *)nbr_table_next(rpl_neighbors,
                                        (nbr_table_item_t *)nbr_0);
  }
  return count;
}

static void remove_neighbor(rpl_nbr_t *nbr_0)
{
  if (nbr_0 == curr_instance.dag.urgent_probing_target) curr_instance.dag.urgent_probing_target = (rpl_nbr_t *)0;
  if (nbr_0 == curr_instance.dag.unicast_dio_target) curr_instance.dag.unicast_dio_target = (rpl_nbr_t *)0;
  nbr_table_remove(rpl_neighbors,(nbr_table_item_t *)nbr_0);
  rpl_timers_schedule_state_update();
  return;
}

rpl_nbr_t *rpl_neighbor_get_from_lladdr(uip_lladdr_t *addr_0)
{
  rpl_nbr_t *tmp;
  tmp = (rpl_nbr_t *)nbr_table_get_from_lladdr(rpl_neighbors,
                                               (linkaddr_t const *)addr_0);
  return tmp;
}

int rpl_neighbor_is_acceptable_parent(rpl_nbr_t *nbr_0)
{
  int __retres;
  if (nbr_0 != (rpl_nbr_t *)0) 
    if ((curr_instance.of)->nbr_is_acceptable_parent != (int (*)(rpl_nbr_t *))0) {
      int tmp;
      tmp = (*((curr_instance.of)->nbr_is_acceptable_parent))(nbr_0);
      __retres = tmp;
      goto return_label;
    }
  __retres = 0xffff;
  return_label: return __retres;
}

uint16_t rpl_neighbor_get_link_metric(rpl_nbr_t *nbr_0)
{
  uint16_t __retres;
  if (nbr_0 != (rpl_nbr_t *)0) 
    if ((curr_instance.of)->nbr_link_metric != (uint16_t (*)(rpl_nbr_t *))0) {
      uint16_t tmp;
      tmp = (*((curr_instance.of)->nbr_link_metric))(nbr_0);
      __retres = tmp;
      goto return_label;
    }
  __retres = (unsigned short)0xffff;
  return_label: return __retres;
}

rpl_rank_t rpl_neighbor_rank_via_nbr(rpl_nbr_t *nbr_0)
{
  rpl_rank_t __retres;
  if (nbr_0 != (rpl_nbr_t *)0) 
    if ((curr_instance.of)->rank_via_nbr != (rpl_rank_t (*)(rpl_nbr_t *))0) {
      rpl_rank_t tmp;
      tmp = (*((curr_instance.of)->rank_via_nbr))(nbr_0);
      __retres = tmp;
      goto return_label;
    }
  __retres = (unsigned short)0xFFFF;
  return_label: return __retres;
}

linkaddr_t const *rpl_neighbor_get_lladdr(rpl_nbr_t *nbr_0)
{
  linkaddr_t const *tmp;
  tmp = (linkaddr_t const *)nbr_table_get_lladdr(rpl_neighbors,
                                                 (nbr_table_item_t const *)nbr_0);
  return tmp;
}

uip_ipaddr_t *rpl_neighbor_get_ipaddr(rpl_nbr_t *nbr_0)
{
  uip_ipaddr_t *tmp_0;
  linkaddr_t const *lladdr = rpl_neighbor_get_lladdr(nbr_0);
  tmp_0 = uip_ds6_nbr_ipaddr_from_lladdr((uip_lladdr_t const *)lladdr);
  return tmp_0;
}

struct link_stats const *rpl_neighbor_get_link_stats(rpl_nbr_t *nbr_0)
{
  struct link_stats const *tmp_0;
  linkaddr_t const *lladdr = rpl_neighbor_get_lladdr(nbr_0);
  tmp_0 = link_stats_from_lladdr(lladdr);
  return tmp_0;
}

int rpl_neighbor_is_fresh(rpl_nbr_t *nbr_0)
{
  int tmp_0;
  struct link_stats const *stats = rpl_neighbor_get_link_stats(nbr_0);
  tmp_0 = link_stats_is_fresh(stats);
  return tmp_0;
}

int rpl_neighbor_is_reachable(rpl_nbr_t *nbr_0)
{
  int __retres;
  if (nbr_0 == (rpl_nbr_t *)0) {
    __retres = 0;
    goto return_label;
  }
  else {
    int tmp_1;
    int tmp;
    tmp = rpl_neighbor_is_fresh(nbr_0);
    if (tmp) {
      int tmp_0;
      tmp_0 = (*((curr_instance.of)->nbr_has_usable_link))(nbr_0);
      if (tmp_0) tmp_1 = 1; else tmp_1 = 0;
    }
    else tmp_1 = 1;
    __retres = tmp_1;
    goto return_label;
  }
  return_label: return __retres;
}

int rpl_neighbor_is_parent(rpl_nbr_t *nbr_0)
{
  int tmp;
  if (nbr_0 != (rpl_nbr_t *)0) 
    if ((int)nbr_0->rank < (int)curr_instance.dag.rank) tmp = 1;
    else tmp = 0;
  else tmp = 0;
  return tmp;
}

void rpl_neighbor_set_preferred_parent(rpl_nbr_t *nbr_0)
{
  if (curr_instance.dag.preferred_parent != nbr_0) {
    uip_ds6_defrt_t *tmp_9;
    uip_ipaddr_t *tmp_8;
    uip_ipaddr_t *tmp_10;
    {
      int tmp;
      if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
      if (3 <= tmp) {
        printf("[%-4s: %-10s] ","INFO","RPL");
        printf("parent switch: ");
      }
    }
    {
      int tmp_2;
      if (0 < curr_log_level_rpl) tmp_2 = 0; else tmp_2 = curr_log_level_rpl;
      if (3 <= tmp_2) {
        uip_ipaddr_t *tmp_1;
        tmp_1 = rpl_neighbor_get_ipaddr(curr_instance.dag.preferred_parent);
        log_6addr((uip_ipaddr_t const *)tmp_1);
      }
    }
    {
      int tmp_3;
      if (0 < curr_log_level_rpl) tmp_3 = 0; else tmp_3 = curr_log_level_rpl;
      if (3 <= tmp_3) printf(" -> ");
    }
    {
      int tmp_6;
      if (0 < curr_log_level_rpl) tmp_6 = 0; else tmp_6 = curr_log_level_rpl;
      if (3 <= tmp_6) {
        uip_ipaddr_t *tmp_5;
        tmp_5 = rpl_neighbor_get_ipaddr(nbr_0);
        log_6addr((uip_ipaddr_t const *)tmp_5);
      }
    }
    {
      int tmp_7;
      if (0 < curr_log_level_rpl) tmp_7 = 0; else tmp_7 = curr_log_level_rpl;
      if (3 <= tmp_7) printf("\n");
    }
    nbr_table_unlock(rpl_neighbors,
                     (nbr_table_item_t *)curr_instance.dag.preferred_parent);
    nbr_table_lock(rpl_neighbors,(nbr_table_item_t *)nbr_0);
    tmp_8 = rpl_neighbor_get_ipaddr(curr_instance.dag.preferred_parent);
    tmp_9 = uip_ds6_defrt_lookup((uip_ipaddr_t const *)tmp_8);
    uip_ds6_defrt_rm(tmp_9);
    tmp_10 = rpl_neighbor_get_ipaddr(nbr_0);
    uip_ds6_defrt_add((uip_ipaddr_t const *)tmp_10,(unsigned long)0);
    curr_instance.dag.preferred_parent = nbr_0;
  }
  return;
}

void rpl_neighbor_remove_all(void)
{
  rpl_nbr_t *nbr_0;
  {
    int tmp;
    if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
    if (3 <= tmp) {
      printf("[%-4s: %-10s] ","INFO","RPL");
      printf("removing all neighbors\n");
    }
  }
  nbr_0 = (rpl_nbr_t *)nbr_table_head(rpl_neighbors);
  while (nbr_0 != (rpl_nbr_t *)0) {
    remove_neighbor(nbr_0);
    nbr_0 = (rpl_nbr_t *)nbr_table_next(rpl_neighbors,
                                        (nbr_table_item_t *)nbr_0);
  }
  rpl_dag_update_state();
  return;
}

rpl_nbr_t *rpl_neighbor_get_from_ipaddr(uip_ipaddr_t *addr_0)
{
  rpl_nbr_t *tmp_1;
  uip_ds6_nbr_t *ds6_nbr = uip_ds6_nbr_lookup((uip_ipaddr_t const *)addr_0);
  uip_lladdr_t const *lladdr =
    uip_ds6_nbr_get_ll((uip_ds6_nbr_t const *)ds6_nbr);
  tmp_1 = (rpl_nbr_t *)nbr_table_get_from_lladdr(rpl_neighbors,
                                                 (linkaddr_t const *)lladdr);
  return tmp_1;
}

static rpl_nbr_t *best_parent_0(int fresh_only)
{
  rpl_nbr_t *__retres;
  rpl_nbr_t *nbr_0;
  rpl_nbr_t *best = (rpl_nbr_t *)0;
  if ((int)curr_instance.used == 0) {
    __retres = (rpl_nbr_t *)0;
    goto return_label;
  }
  nbr_0 = (rpl_nbr_t *)nbr_table_head(rpl_neighbors);
  while (nbr_0 != (rpl_nbr_t *)0) {
    {
      int tmp_0;
      rpl_rank_t tmp;
      tmp = rpl_neighbor_rank_via_nbr(nbr_0);
      tmp_0 = acceptable_rank(tmp);
      if (tmp_0) {
        int tmp_1;
        tmp_1 = (*((curr_instance.of)->nbr_is_acceptable_parent))(nbr_0);
        if (! tmp_1) goto _LAND;
      }
      else _LAND: goto __Cont;
      if (fresh_only) {
        int tmp_2;
        tmp_2 = rpl_neighbor_is_fresh(nbr_0);
        if (! tmp_2) goto __Cont;
      }
      best = (*((curr_instance.of)->best_parent))(best,nbr_0);
    }
    __Cont:
    nbr_0 = (rpl_nbr_t *)nbr_table_next(rpl_neighbors,
                                        (nbr_table_item_t *)nbr_0);
  }
  __retres = best;
  return_label: return __retres;
}

rpl_nbr_t *rpl_neighbor_select_best(void)
{
  rpl_nbr_t *__retres;
  rpl_nbr_t *best;
  int tmp;
  tmp = rpl_dag_root_is_root();
  if (tmp) {
    __retres = (rpl_nbr_t *)0;
    goto return_label;
  }
  best = best_parent_0(0);
  if (best != (rpl_nbr_t *)0) {
    int tmp_5;
    tmp_5 = rpl_neighbor_is_fresh(best);
    if (tmp_5) {
      curr_instance.dag.urgent_probing_target = (rpl_nbr_t *)0;
      __retres = best;
      goto return_label;
    }
    else {
      rpl_nbr_t *best_fresh;
      if (curr_instance.dag.urgent_probing_target == (rpl_nbr_t *)0) {
        {
          int tmp_0;
          if (0 < curr_log_level_rpl) tmp_0 = 0;
          else tmp_0 = curr_log_level_rpl;
          if (3 <= tmp_0) {
            printf("[%-4s: %-10s] ","INFO","RPL");
            printf("best parent is not fresh, schedule urgent probing to ");
          }
        }
        {
          int tmp_3;
          if (0 < curr_log_level_rpl) tmp_3 = 0;
          else tmp_3 = curr_log_level_rpl;
          if (3 <= tmp_3) {
            uip_ipaddr_t *tmp_2;
            tmp_2 = rpl_neighbor_get_ipaddr(best);
            log_6addr((uip_ipaddr_t const *)tmp_2);
          }
        }
        {
          int tmp_4;
          if (0 < curr_log_level_rpl) tmp_4 = 0;
          else tmp_4 = curr_log_level_rpl;
          if (3 <= tmp_4) printf("\n");
        }
        curr_instance.dag.urgent_probing_target = best;
        rpl_schedule_probing_now();
      }
      if (best == curr_instance.dag.preferred_parent) {
        __retres = best;
        goto return_label;
      }
      best_fresh = best_parent_0(1);
      if (best_fresh == (rpl_nbr_t *)0) 
        if (curr_instance.dag.preferred_parent == (rpl_nbr_t *)0) {
          __retres = (rpl_nbr_t *)0;
          goto return_label;
        }
        else {
          __retres = best;
          goto return_label;
        }
      else {
        __retres = best_fresh;
        goto return_label;
      }
    }
  }
  else {
    __retres = (rpl_nbr_t *)0;
    goto return_label;
  }
  return_label: return __retres;
}

void rpl_neighbor_init(void)
{
  nbr_table_register(rpl_neighbors,
                     (void (*)(nbr_table_item_t *item))(& remove_neighbor));
  return;
}

__inline static unsigned int __bswap_32_78(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_78(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

rpl_instance_t curr_instance;
rpl_of_t rpl_mrhof;

static rpl_of_t * const objective_functions[1] = {& rpl_mrhof};
static int init_dag_from_dio(rpl_dio_t *dio);

char const *rpl_dag_state_to_str(enum rpl_dag_state state)
{
  char const *__retres;
  switch (state) {
    case (enum rpl_dag_state)DAG_INITIALIZED: __retres = "initialized";
    goto return_label;
    case (enum rpl_dag_state)DAG_JOINED: __retres = "joined";
    goto return_label;
    case (enum rpl_dag_state)DAG_REACHABLE: __retres = "reachable";
    goto return_label;
    case (enum rpl_dag_state)DAG_POISONING: __retres = "poisoning";
    goto return_label;
    default: __retres = "unknown";
    goto return_label;
  }
  return_label: return __retres;
}

int rpl_dag_get_root_ipaddr(uip_ipaddr_t *ipaddr)
{
  int __retres;
  if (curr_instance.used) 
    if (ipaddr != (uip_ipaddr_t *)0) {
      *ipaddr = curr_instance.dag.dag_id;
      __retres = 1;
      goto return_label;
    }
  __retres = 0;
  return_label: return __retres;
}

void rpl_dag_leave(void)
{
  int tmp_2;
  {
    int tmp;
    if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
    if (3 <= tmp) {
      printf("[%-4s: %-10s] ","INFO","RPL");
      printf("leaving DAG ");
    }
  }
  {
    int tmp_0;
    if (0 < curr_log_level_rpl) tmp_0 = 0; else tmp_0 = curr_log_level_rpl;
    if (3 <= tmp_0) log_6addr((uip_ipaddr_t const *)(& curr_instance.dag.dag_id));
  }
  {
    int tmp_1;
    if (0 < curr_log_level_rpl) tmp_1 = 0; else tmp_1 = curr_log_level_rpl;
    if (3 <= tmp_1) printf(", instance %u\n",(int)curr_instance.instance_id);
  }
  tmp_2 = rpl_dag_root_is_root();
  if (! tmp_2) {
    if ((int)curr_instance.dag.dao_last_seqno > 127) curr_instance.dag.dao_last_seqno = (unsigned char)(
                                                     ((int)curr_instance.dag.dao_last_seqno + 1) & 255);
    else curr_instance.dag.dao_last_seqno = (unsigned char)(((int)curr_instance.dag.dao_last_seqno + 1) & 127);
    rpl_icmp6_dao_output((unsigned char)0);
  }
  link_stats_reset();
  rpl_neighbor_remove_all();
  uip_sr_free_all();
  rpl_timers_stop_dag_timers();
  if ((int)curr_instance.dag.prefix_info.flags & 0x40) rpl_reset_prefix
                                                       (& curr_instance.dag.prefix_info);
  curr_instance.used = (unsigned char)0;
  return;
}

void rpl_dag_poison_and_leave(void)
{
  curr_instance.dag.state = DAG_POISONING;
  rpl_timers_schedule_state_update();
  return;
}

void rpl_dag_periodic(unsigned int seconds)
{
  if (curr_instance.used) {
    unsigned long tmp_2;
    if (0xFF == 0xFF) tmp_2 = (unsigned long)0xFFFFFFFF;
    else tmp_2 = (unsigned long)curr_instance.lifetime_unit * (unsigned long)0xFF;
    ;
    if ((unsigned long)curr_instance.dag.lifetime != tmp_2) {
      if (curr_instance.dag.lifetime > seconds) curr_instance.dag.lifetime -= seconds;
      else curr_instance.dag.lifetime = (unsigned int)0;
      if (curr_instance.dag.lifetime == (uint32_t)0) {
        {
          int tmp;
          if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
          if (2 <= tmp) {
            printf("[%-4s: %-10s] ","WARN","RPL");
            printf("DAG expired, poison and leave\n");
          }
        }
        curr_instance.dag.state = DAG_POISONING;
        rpl_timers_schedule_state_update();
      }
      else 
        if (curr_instance.dag.lifetime < (uint32_t)300) 
          if (curr_instance.dag.preferred_parent != (rpl_nbr_t *)0) {
            uip_ipaddr_t *tmp_1;
            {
              int tmp_0;
              if (0 < curr_log_level_rpl) tmp_0 = 0;
              else tmp_0 = curr_log_level_rpl;
              if (2 <= tmp_0) {
                printf("[%-4s: %-10s] ","WARN","RPL");
                printf("DAG expiring in %u seconds, send DIS to preferred parent\n",
                       curr_instance.dag.lifetime);
              }
            }
            tmp_1 = rpl_neighbor_get_ipaddr(curr_instance.dag.preferred_parent);
            rpl_icmp6_dis_output(tmp_1);
          }
    }
  }
  return;
}

int rpl_is_addr_in_our_dag(uip_ipaddr_t const *addr_0)
{
  int tmp_0;
  if (curr_instance.used) {
    int tmp;
    tmp = memcmp((void const *)(& curr_instance.dag.dag_id),
                 (void const *)addr_0,
                 (unsigned long)((int)curr_instance.dag.prefix_info.length >> 3));
    if (tmp == 0) tmp_0 = 1; else tmp_0 = 0;
  }
  else tmp_0 = 0;
  return tmp_0;
}

rpl_instance_t *rpl_get_default_instance(void)
{
  rpl_instance_t *tmp;
  if (curr_instance.used) tmp = & curr_instance;
  else tmp = (rpl_instance_t *)0;
  return tmp;
}

rpl_dag_t *rpl_get_any_dag(void)
{
  rpl_dag_t *tmp;
  if (curr_instance.used) tmp = & curr_instance.dag;
  else tmp = (rpl_dag_t *)0;
  return tmp;
}

static rpl_of_t *find_objective_function(rpl_ocp_t ocp)
{
  rpl_of_t *__retres;
  unsigned int i;
  i = (unsigned int)0;
  while ((unsigned long)i < sizeof(objective_functions) / sizeof(objective_functions[0])) {
    if ((int)(objective_functions[i])->ocp == (int)ocp) {
      __retres = objective_functions[i];
      goto return_label;
    }
    i ++;
  }
  __retres = (rpl_of_t *)0;
  return_label: return __retres;
}

void rpl_refresh_routes(char const *str)
{
  int tmp_1;
  tmp_1 = rpl_dag_root_is_root();
  if (tmp_1) {
    int tmp_0;
    if ((int)curr_instance.dtsn_out > 127) curr_instance.dtsn_out = (unsigned char)(
                                           ((int)curr_instance.dtsn_out + 1) & 255);
    else curr_instance.dtsn_out = (unsigned char)(((int)curr_instance.dtsn_out + 1) & 127);
    {
      int tmp;
      if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
      if (2 <= tmp) {
        printf("[%-4s: %-10s] ","WARN","RPL");
        printf("incremented DTSN (%s), current %u\n",str,
               (int)curr_instance.dtsn_out);
      }
    }
    if (0 < curr_log_level_rpl) tmp_0 = 0; else tmp_0 = curr_log_level_rpl;
    if (tmp_0 >= 3) rpl_neighbor_print_list("Refresh routes (before)");
  }
  return;
}

void rpl_global_repair(char const *str)
{
  int tmp_1;
  tmp_1 = rpl_dag_root_is_root();
  if (tmp_1) {
    int tmp_0;
    if ((int)curr_instance.dag.version > 127) curr_instance.dag.version = (unsigned char)(
                                              ((int)curr_instance.dag.version + 1) & 255);
    else curr_instance.dag.version = (unsigned char)(((int)curr_instance.dag.version + 1) & 127);
    curr_instance.dtsn_out = (unsigned char)((255 - 16) + 1);
    {
      int tmp;
      if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
      if (2 <= tmp) {
        printf("[%-4s: %-10s] ","WARN","RPL");
        printf("initiating global repair (%s), version %u, rank %u\n",str,
               (int)curr_instance.dag.version,(int)curr_instance.dag.rank);
      }
    }
    if (0 < curr_log_level_rpl) tmp_0 = 0; else tmp_0 = curr_log_level_rpl;
    if (tmp_0 >= 3) rpl_neighbor_print_list("Global repair (before)");
    rpl_local_repair("Global repair");
  }
  return;
}

static void global_repair_non_root(rpl_dio_t *dio)
{
  int tmp_1;
  tmp_1 = rpl_dag_root_is_root();
  if (! tmp_1) {
    int tmp_0;
    {
      int tmp;
      if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
      if (2 <= tmp) {
        printf("[%-4s: %-10s] ","WARN","RPL");
        printf("participating in global repair, version %u, rank %u\n",
               (int)dio->version,(int)curr_instance.dag.rank);
      }
    }
    if (0 < curr_log_level_rpl) tmp_0 = 0; else tmp_0 = curr_log_level_rpl;
    if (tmp_0 >= 3) rpl_neighbor_print_list("Global repair (before)");
    rpl_timers_stop_dag_timers();
    init_dag_from_dio(dio);
    rpl_local_repair("Global repair");
  }
  return;
}

void rpl_local_repair(char const *str)
{
  if (curr_instance.used) {
    int tmp_0;
    {
      int tmp;
      if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
      if (2 <= tmp) {
        printf("[%-4s: %-10s] ","WARN","RPL");
        printf("local repair (%s)\n",str);
      }
    }
    tmp_0 = rpl_dag_root_is_root();
    if (! tmp_0) curr_instance.dag.state = DAG_INITIALIZED;
    (*((curr_instance.of)->reset))();
    rpl_neighbor_remove_all();
    rpl_timers_dio_reset("Local repair");
    rpl_timers_schedule_state_update();
  }
  return;
}

int rpl_dag_ready_to_advertise(void)
{
  int __retres;
  if ((int)curr_instance.mop == 0) {
    int tmp;
    if (curr_instance.used) 
      if (curr_instance.dag.state >= (unsigned int)DAG_INITIALIZED) tmp = 1;
      else tmp = 0;
    else tmp = 0;
    __retres = tmp;
    goto return_label;
  }
  else {
    int tmp_0;
    if (curr_instance.used) 
      if (curr_instance.dag.state >= (unsigned int)DAG_REACHABLE) tmp_0 = 1;
      else tmp_0 = 0;
    else tmp_0 = 0;
    __retres = tmp_0;
    goto return_label;
  }
  return_label: return __retres;
}

void rpl_dag_update_state(void)
{
  rpl_rank_t old_rank;
  if (! curr_instance.used) goto return_label;
  old_rank = curr_instance.dag.rank;
  rpl_timers_unschedule_state_update();
  if (curr_instance.dag.state == (unsigned int)DAG_POISONING) {
    rpl_neighbor_set_preferred_parent((rpl_nbr_t *)0);
    curr_instance.dag.rank = (unsigned short)0xFFFF;
    if ((int)old_rank != 0xFFFF) {
      {
        int tmp;
        if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
        if (2 <= tmp) {
          printf("[%-4s: %-10s] ","WARN","RPL");
          printf("poisoning and leaving after a delay\n");
        }
      }
      rpl_timers_dio_reset("Poison routes");
      rpl_timers_schedule_leaving();
    }
  }
  else {
    int tmp_11;
    tmp_11 = rpl_dag_root_is_root();
    if (! tmp_11) {
      rpl_nbr_t *nbr_0;
      rpl_nbr_t *tmp_0;
      rpl_nbr_t *old_parent = curr_instance.dag.preferred_parent;
      tmp_0 = rpl_neighbor_select_best();
      rpl_neighbor_set_preferred_parent(tmp_0);
      curr_instance.dag.rank = rpl_neighbor_rank_via_nbr(curr_instance.dag.preferred_parent);
      nbr_0 = (rpl_nbr_t *)nbr_table_head(rpl_neighbors);
      while (nbr_0 != (rpl_nbr_t *)0) {
        rpl_rank_t tmp_1;
        tmp_1 = rpl_neighbor_rank_via_nbr(nbr_0);
        ;
        if ((int)tmp_1 < (int)curr_instance.dag.rank) {
          if (nbr_0->better_parent_since == (clock_time_t)0) nbr_0->better_parent_since = clock_time();
        }
        else nbr_0->better_parent_since = (unsigned long)0;
        nbr_0 = (rpl_nbr_t *)nbr_table_next(rpl_neighbors,
                                            (nbr_table_item_t *)nbr_0);
      }
      if (old_parent == (rpl_nbr_t *)0) goto _LOR;
      else 
        if ((int)curr_instance.dag.rank < (int)curr_instance.dag.lowest_rank) 
          _LOR:
          curr_instance.dag.lowest_rank = curr_instance.dag.rank;
      if ((int)curr_instance.dag.last_advertised_rank != 0xFFFF) 
        if ((int)curr_instance.dag.rank != 0xFFFF) {
          int tmp_3;
          if ((int)curr_instance.dag.rank - (int)curr_instance.dag.last_advertised_rank < 0) 
            tmp_3 = - ((int)curr_instance.dag.rank - (int)curr_instance.dag.last_advertised_rank);
          else tmp_3 = (int)curr_instance.dag.rank - (int)curr_instance.dag.last_advertised_rank;
          if (tmp_3 > 4 * 128) {
            {
              int tmp_2;
              if (0 < curr_log_level_rpl) tmp_2 = 0;
              else tmp_2 = curr_log_level_rpl;
              if (2 <= tmp_2) {
                printf("[%-4s: %-10s] ","WARN","RPL");
                printf("significant rank update %u->%u\n",
                       (int)curr_instance.dag.last_advertised_rank,
                       (int)curr_instance.dag.rank);
              }
            }
            curr_instance.dag.last_advertised_rank = curr_instance.dag.rank;
            rpl_timers_dio_reset("Significant rank update");
          }
        }
      if (curr_instance.dag.preferred_parent != old_parent) {
        int tmp_10;
        if (old_parent == (rpl_nbr_t *)0) {
          curr_instance.dag.state = DAG_JOINED;
          rpl_timers_dio_reset("Got parent");
          {
            int tmp_4;
            if (0 < curr_log_level_rpl) tmp_4 = 0;
            else tmp_4 = curr_log_level_rpl;
            if (2 <= tmp_4) {
              printf("[%-4s: %-10s] ","WARN","RPL");
              printf("found parent: ");
            }
          }
          {
            int tmp_7;
            if (0 < curr_log_level_rpl) tmp_7 = 0;
            else tmp_7 = curr_log_level_rpl;
            if (2 <= tmp_7) {
              uip_ipaddr_t *tmp_6;
              tmp_6 = rpl_neighbor_get_ipaddr(curr_instance.dag.preferred_parent);
              log_6addr((uip_ipaddr_t const *)tmp_6);
            }
          }
          {
            int tmp_8;
            if (0 < curr_log_level_rpl) tmp_8 = 0;
            else tmp_8 = curr_log_level_rpl;
            if (2 <= tmp_8) printf(", staying in DAG\n");
          }
          rpl_timers_unschedule_leaving();
        }
        if (curr_instance.dag.preferred_parent != (rpl_nbr_t *)0) rpl_timers_schedule_dao();
        else {
          curr_instance.dag.state = DAG_INITIALIZED;
          {
            int tmp_9;
            if (0 < curr_log_level_rpl) tmp_9 = 0;
            else tmp_9 = curr_log_level_rpl;
            if (2 <= tmp_9) {
              printf("[%-4s: %-10s] ","WARN","RPL");
              printf("no parent, scheduling periodic DIS, will leave if no parent is found\n");
            }
          }
          rpl_timers_dio_reset("Poison routes");
          rpl_timers_schedule_periodic_dis();
          rpl_timers_schedule_leaving();
        }
        if (0 < curr_log_level_rpl) tmp_10 = 0;
        else tmp_10 = curr_log_level_rpl;
        if (tmp_10 >= 3) rpl_neighbor_print_list("Parent switch");
      }
    }
  }
  (*((curr_instance.of)->update_metric_container))();
  return_label: return;
}

static rpl_nbr_t *update_nbr_from_dio(uip_ipaddr_t *from, rpl_dio_t *dio)
{
  rpl_nbr_t *__retres;
  uip_lladdr_t const *lladdr;
  rpl_nbr_t *nbr_0 = (rpl_nbr_t *)0;
  nbr_0 = rpl_neighbor_get_from_ipaddr(from);
  if (nbr_0 == (rpl_nbr_t *)0) {
    lladdr = uip_ds6_nbr_lladdr_from_ipaddr((uip_ipaddr_t const *)from);
    if (lladdr == (uip_lladdr_t const *)0) {
      __retres = (rpl_nbr_t *)0;
      goto return_label;
    }
    nbr_0 = (rpl_nbr_t *)nbr_table_add_lladdr(rpl_neighbors,
                                              (linkaddr_t const *)lladdr,
                                              NBR_TABLE_REASON_RPL_DIO,
                                              (void *)dio);
    if (nbr_0 == (rpl_nbr_t *)0) {
      {
        int tmp;
        if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
        if (1 <= tmp) {
          printf("[%-4s: %-10s] ","ERR","RPL");
          printf("failed to add neighbor\n");
        }
      }
      __retres = (rpl_nbr_t *)0;
      goto return_label;
    }
  }
  nbr_0->rank = dio->rank;
  nbr_0->dtsn = dio->dtsn;
  __retres = nbr_0;
  return_label: return __retres;
}

static void process_dio_from_current_dag(uip_ipaddr_t *from, rpl_dio_t *dio)
{
  rpl_nbr_t *nbr_0;
  uint8_t last_dtsn;
  int tmp;
  int tmp_2;
  uip_ds6_nbr_t *tmp_4;
  rpl_nbr_t *tmp_6;
  if ((int)dio->rank < (int)curr_instance.min_hoprankinc) goto return_label;
  tmp = rpl_lollipop_greater_than((int)curr_instance.dag.version,
                                  (int)dio->version);
  if (tmp) {
    if ((int)dio->rank == (int)curr_instance.min_hoprankinc) rpl_timers_dio_reset
                                                             ("Heard old version from root");
    goto return_label;
  }
  if ((int)dio->rank != 0xFFFF) curr_instance.dag.dio_counter = (uint8_t)(
                                (int)curr_instance.dag.dio_counter + 1);
  tmp_2 = rpl_lollipop_greater_than((int)dio->version,
                                    (int)curr_instance.dag.version);
  if (tmp_2) 
    if ((int)curr_instance.dag.rank == (int)curr_instance.min_hoprankinc) {
      {
        int tmp_0;
        if (0 < curr_log_level_rpl) tmp_0 = 0;
        else tmp_0 = curr_log_level_rpl;
        if (1 <= tmp_0) {
          printf("[%-4s: %-10s] ","ERR","RPL");
          printf("inconsistent DIO version (current: %u, received: %u), initiate global repair\n",
                 (int)curr_instance.dag.version,(int)dio->version);
        }
      }
      curr_instance.dag.version = dio->version;
      rpl_global_repair("Inconsistent DIO version");
    }
    else {
      {
        int tmp_1;
        if (0 < curr_log_level_rpl) tmp_1 = 0;
        else tmp_1 = curr_log_level_rpl;
        if (2 <= tmp_1) {
          printf("[%-4s: %-10s] ","WARN","RPL");
          printf("new DIO version (current: %u, received: %u), apply global repair\n",
                 (int)curr_instance.dag.version,(int)dio->version);
        }
      }
      global_repair_non_root(dio);
    }
  tmp_4 = rpl_icmp6_update_nbr_table(from,NBR_TABLE_REASON_RPL_DIO,
                                     (void *)dio);
  if (! tmp_4) {
    {
      int tmp_3;
      if (0 < curr_log_level_rpl) tmp_3 = 0; else tmp_3 = curr_log_level_rpl;
      if (1 <= tmp_3) {
        printf("[%-4s: %-10s] ","ERR","RPL");
        printf("IPv6 cache full, dropping DIO\n");
      }
    }
    goto return_label;
  }
  nbr_0 = rpl_neighbor_get_from_ipaddr(from);
  if (nbr_0 != (rpl_nbr_t *)0) last_dtsn = nbr_0->dtsn;
  else last_dtsn = (unsigned char)((255 - 16) + 1);
  tmp_6 = update_nbr_from_dio(from,dio);
  if (! tmp_6) {
    {
      int tmp_5;
      if (0 < curr_log_level_rpl) tmp_5 = 0; else tmp_5 = curr_log_level_rpl;
      if (1 <= tmp_5) {
        printf("[%-4s: %-10s] ","ERR","RPL");
        printf("neighbor table full, dropping DIO\n");
      }
    }
    goto return_label;
  }
  if (curr_instance.dag.lifetime == (uint32_t)0) goto _LOR;
  else 
    if (nbr_0 != (rpl_nbr_t *)0) 
      if (nbr_0 == curr_instance.dag.preferred_parent) {
        _LOR:
        {
          {
            int tmp_7;
            if (0 < curr_log_level_rpl) tmp_7 = 0;
            else tmp_7 = curr_log_level_rpl;
            if (3 <= tmp_7) {
              printf("[%-4s: %-10s] ","INFO","RPL");
              printf("refreshing lifetime\n");
            }
          }
          if (8 * 60 == 0xFF) curr_instance.dag.lifetime = 0xFFFFFFFF;
          else curr_instance.dag.lifetime = (unsigned int)((unsigned long)curr_instance.lifetime_unit * (unsigned long)(
                                                           8 * 60));
        }
      }
  if ((int)curr_instance.mop != 0) 
    if (nbr_0 != (rpl_nbr_t *)0) 
      if (nbr_0 == curr_instance.dag.preferred_parent) {
        int tmp_9;
        tmp_9 = rpl_lollipop_greater_than((int)dio->dtsn,(int)last_dtsn);
        if (tmp_9) {
          if ((int)curr_instance.dtsn_out > 127) curr_instance.dtsn_out = (unsigned char)(
                                                 ((int)curr_instance.dtsn_out + 1) & 255);
          else curr_instance.dtsn_out = (unsigned char)(((int)curr_instance.dtsn_out + 1) & 127);
          {
            int tmp_8;
            if (0 < curr_log_level_rpl) tmp_8 = 0;
            else tmp_8 = curr_log_level_rpl;
            if (2 <= tmp_8) {
              printf("[%-4s: %-10s] ","WARN","RPL");
              printf("DTSN increment %u->%u, schedule new DAO with DTSN %u\n",
                     (int)last_dtsn,(int)dio->dtsn,
                     (int)curr_instance.dtsn_out);
            }
          }
          rpl_timers_schedule_dao();
        }
      }
  return_label: return;
}

static int init_dag(uint8_t instance_id, uip_ipaddr_t *dag_id, rpl_ocp_t ocp,
                    uip_ipaddr_t *prefix, unsigned int prefix_len,
                    uint8_t prefix_flags)
{
  int __retres;
  rpl_of_t *of;
  int tmp_1;
  memset((void *)(& curr_instance),0,sizeof(curr_instance));
  of = find_objective_function(ocp);
  if (of == (rpl_of_t *)0) {
    {
      int tmp;
      if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
      if (1 <= tmp) {
        printf("[%-4s: %-10s] ","ERR","RPL");
        printf("ignoring DIO with an unsupported OF: %u\n",(int)ocp);
      }
    }
    __retres = 0;
    goto return_label;
  }
  tmp_1 = rpl_set_prefix_from_addr(prefix,prefix_len,prefix_flags);
  if (! tmp_1) {
    {
      int tmp_0;
      if (0 < curr_log_level_rpl) tmp_0 = 0; else tmp_0 = curr_log_level_rpl;
      if (1 <= tmp_0) {
        printf("[%-4s: %-10s] ","ERR","RPL");
        printf("failed to set prefix\n");
      }
    }
    __retres = 0;
    goto return_label;
  }
  curr_instance.instance_id = instance_id;
  curr_instance.of = of;
  curr_instance.dtsn_out = (unsigned char)((255 - 16) + 1);
  curr_instance.used = (unsigned char)1;
  curr_instance.dag.rank = (unsigned short)0xFFFF;
  curr_instance.dag.last_advertised_rank = (unsigned short)0xFFFF;
  curr_instance.dag.lowest_rank = (unsigned short)0xFFFF;
  curr_instance.dag.dao_last_seqno = (unsigned char)((255 - 16) + 1);
  curr_instance.dag.dao_last_acked_seqno = (unsigned char)((255 - 16) + 1);
  curr_instance.dag.dao_last_seqno = (unsigned char)((255 - 16) + 1);
  memcpy((void *)(& curr_instance.dag.dag_id),(void const *)dag_id,
         sizeof(curr_instance.dag.dag_id));
  __retres = 1;
  return_label: return __retres;
}

static int init_dag_from_dio(rpl_dio_t *dio)
{
  int __retres;
  int tmp;
  tmp = init_dag(dio->instance_id,& dio->dag_id,dio->ocp,
                 & dio->prefix_info.prefix,
                 (unsigned int)dio->prefix_info.length,
                 dio->prefix_info.flags);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  curr_instance.mop = dio->mop;
  curr_instance.mc.type = dio->mc.type;
  curr_instance.mc.flags = dio->mc.flags;
  curr_instance.mc.aggr = dio->mc.aggr;
  curr_instance.mc.prec = dio->mc.prec;
  curr_instance.max_rankinc = dio->dag_max_rankinc;
  curr_instance.min_hoprankinc = dio->dag_min_hoprankinc;
  curr_instance.dio_intdoubl = dio->dag_intdoubl;
  curr_instance.dio_intmin = dio->dag_intmin;
  curr_instance.dio_redundancy = dio->dag_redund;
  curr_instance.default_lifetime = dio->default_lifetime;
  curr_instance.lifetime_unit = dio->lifetime_unit;
  curr_instance.dag.state = DAG_INITIALIZED;
  curr_instance.dag.preference = dio->preference;
  curr_instance.dag.grounded = dio->grounded;
  curr_instance.dag.version = dio->version;
  curr_instance.dag.dio_intcurrent = dio->dag_intmin;
  __retres = 1;
  return_label: return __retres;
}

static int process_dio_init_dag(uip_ipaddr_t *from, rpl_dio_t *dio)
{
  int __retres;
  int tmp_1;
  if ((int)dio->mop != 0) 
    if ((int)dio->mop != 1) {
      {
        int tmp;
        if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
        if (2 <= tmp) {
          printf("[%-4s: %-10s] ","WARN","RPL");
          printf("ignoring DIO with an unsupported MOP: %d\n",(int)dio->mop);
        }
      }
      __retres = 0;
      goto return_label;
    }
  tmp_1 = init_dag_from_dio(dio);
  if (! tmp_1) {
    {
      int tmp_0;
      if (0 < curr_log_level_rpl) tmp_0 = 0; else tmp_0 = curr_log_level_rpl;
      if (2 <= tmp_0) {
        printf("[%-4s: %-10s] ","WARN","RPL");
        printf("failed to initialize DAG\n");
      }
    }
    __retres = 0;
    goto return_label;
  }
  (*((curr_instance.of)->reset))();
  rpl_timers_dio_reset("Join");
  rpl_schedule_probing();
  {
    int tmp_2;
    if (0 < curr_log_level_rpl) tmp_2 = 0; else tmp_2 = curr_log_level_rpl;
    if (3 <= tmp_2) {
      printf("[%-4s: %-10s] ","INFO","RPL");
      printf("initialized DAG with instance ID %u, DAG ID ",
             (int)curr_instance.instance_id);
    }
  }
  {
    int tmp_3;
    if (0 < curr_log_level_rpl) tmp_3 = 0; else tmp_3 = curr_log_level_rpl;
    if (3 <= tmp_3) log_6addr((uip_ipaddr_t const *)(& curr_instance.dag.dag_id));
  }
  {
    int tmp_4;
    if (0 < curr_log_level_rpl) tmp_4 = 0; else tmp_4 = curr_log_level_rpl;
    if (3 <= tmp_4) printf(", prexix ");
  }
  {
    int tmp_5;
    if (0 < curr_log_level_rpl) tmp_5 = 0; else tmp_5 = curr_log_level_rpl;
    if (3 <= tmp_5) log_6addr((uip_ipaddr_t const *)(& dio->prefix_info.prefix));
  }
  {
    int tmp_6;
    if (0 < curr_log_level_rpl) tmp_6 = 0; else tmp_6 = curr_log_level_rpl;
    if (3 <= tmp_6) printf("/%u, rank %u\n",(int)dio->prefix_info.length,
                           (int)curr_instance.dag.rank);
  }
  {
    int tmp_7;
    if (0 < curr_log_level_rpl) tmp_7 = 0; else tmp_7 = curr_log_level_rpl;
    if (2 <= tmp_7) {
      printf("[%-4s: %-10s] ","WARN","RPL");
      printf("just joined, no parent yet, setting timer for leaving\n");
    }
  }
  rpl_timers_schedule_leaving();
  __retres = 1;
  return_label: return __retres;
}

void rpl_process_dio(uip_ipaddr_t *from, rpl_dio_t *dio)
{
  if (! curr_instance.used) {
    int tmp_1;
    tmp_1 = rpl_dag_root_is_root();
    if (! tmp_1) {
      int tmp_0;
      tmp_0 = process_dio_init_dag(from,dio);
      if (! tmp_0) {
        {
          int tmp;
          if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
          if (2 <= tmp) {
            printf("[%-4s: %-10s] ","WARN","RPL");
            printf("failed to init DAG\n");
          }
        }
        goto return_label;
      }
    }
  }
  if (curr_instance.used) 
    if ((int)curr_instance.instance_id == (int)dio->instance_id) {
      int tmp_2;
      tmp_2 = memcmp((void const *)(& curr_instance.dag.dag_id),
                     (void const *)(& dio->dag_id),sizeof(uip_ip6addr_t));
      if (tmp_2 == 0) {
        process_dio_from_current_dag(from,dio);
        rpl_dag_update_state();
      }
    }
  return_label: return;
}

void rpl_process_dis(uip_ipaddr_t *from, int is_multicast)
{
  if (is_multicast) rpl_timers_dio_reset("Multicast DIS");
  else {
    uip_ds6_nbr_t *tmp_0;
    tmp_0 = rpl_icmp6_update_nbr_table(from,NBR_TABLE_REASON_RPL_DIS,
                                       (void *)0);
    if (tmp_0 != (uip_ds6_nbr_t *)0) {
      {
        int tmp;
        if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
        if (3 <= tmp) {
          printf("[%-4s: %-10s] ","INFO","RPL");
          printf("unicast DIS, reply to sender\n");
        }
      }
      rpl_icmp6_dio_output(from);
    }
  }
  return;
}

void rpl_process_dao(uip_ipaddr_t *from, rpl_dao_t *dao)
{
  if ((int)dao->lifetime == 0) uip_sr_expire_parent((void *)0,
                                                    (uip_ipaddr_t const *)from,
                                                    (uip_ipaddr_t const *)(& dao->parent_addr));
  else {
    uip_sr_node_t *tmp_1;
    unsigned long tmp_0;
    if ((int)dao->lifetime == 0xFF) tmp_0 = (unsigned long)0xFFFFFFFF;
    else tmp_0 = (unsigned long)curr_instance.lifetime_unit * (unsigned long)dao->lifetime;
    ;
    ;
    tmp_1 = uip_sr_update_node((void *)0,(uip_ipaddr_t const *)from,
                               (uip_ipaddr_t const *)(& dao->parent_addr),
                               (unsigned int)tmp_0);
    if (! tmp_1) {
      {
        int tmp;
        if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
        if (1 <= tmp) {
          printf("[%-4s: %-10s] ","ERR","RPL");
          printf("failed to add link on incoming DAO\n");
        }
      }
      goto return_label;
    }
  }
  if ((int)dao->flags & 0x80) rpl_timers_schedule_dao_ack(from,dao->sequence);
  return_label: return;
}

void rpl_process_dao_ack(uint8_t sequence, uint8_t status)
{
  int tmp;
  tmp = rpl_lollipop_greater_than((int)sequence,
                                  (int)curr_instance.dag.dao_last_acked_seqno);
  if (tmp) curr_instance.dag.dao_last_acked_seqno = sequence;
  if ((int)sequence == (int)curr_instance.dag.dao_last_seqno) {
    int status_ok = (int)status < 128;
    if (curr_instance.dag.state == (unsigned int)DAG_JOINED) 
      if (status_ok) {
        curr_instance.dag.state = DAG_REACHABLE;
        rpl_timers_dio_reset("Reachable");
      }
    rpl_timers_notify_dao_ack();
    if (! status_ok) {
      {
        int tmp_0;
        if (0 < curr_log_level_rpl) tmp_0 = 0;
        else tmp_0 = curr_log_level_rpl;
        if (2 <= tmp_0) {
          printf("[%-4s: %-10s] ","WARN","RPL");
          printf("DAO-NACK received with seqno %u, status %u, poison and leave\n",
                 (int)sequence,(int)status);
        }
      }
      curr_instance.dag.state = DAG_POISONING;
    }
  }
  return;
}

int rpl_process_hbh(rpl_nbr_t *sender, uint16_t sender_rank,
                    int loop_detected, int rank_error_signaled)
{
  int __retres;
  int drop = 0;
  if (loop_detected) {
    if (rank_error_signaled) ;
    rpl_timers_schedule_unicast_dio(sender);
  }
  if (rank_error_signaled) 
    if (sender != (rpl_nbr_t *)0) {
      sender->rank = sender_rank;
      rpl_dag_update_state();
    }
  __retres = ! drop;
  return __retres;
}

void rpl_dag_init_root(uint8_t instance_id, uip_ipaddr_t *dag_id,
                       uip_ipaddr_t *prefix, unsigned int prefix_len,
                       uint8_t prefix_flags)
{
  uint8_t version = (unsigned char)((255 - 16) + 1);
  if (curr_instance.used) {
    int tmp;
    tmp = memcmp((void const *)(& curr_instance.dag.dag_id),
                 (void const *)dag_id,sizeof(uip_ip6addr_t));
    if (tmp == 0) {
      version = curr_instance.dag.version;
      if ((int)version > 127) version = (unsigned char)(((int)version + 1) & 255);
      else version = (unsigned char)(((int)version + 1) & 127);
    }
    rpl_dag_leave();
  }
  init_dag(instance_id,dag_id,(unsigned short)1,prefix,prefix_len,
           prefix_flags);
  curr_instance.mop = (unsigned char)1;
  curr_instance.max_rankinc = (unsigned short)(8 * 128);
  curr_instance.min_hoprankinc = (unsigned short)128;
  curr_instance.dio_intdoubl = (unsigned char)8;
  curr_instance.dio_intmin = (unsigned char)12;
  curr_instance.dio_redundancy = (unsigned char)0;
  curr_instance.default_lifetime = (unsigned char)30;
  curr_instance.lifetime_unit = (unsigned short)60;
  curr_instance.dag.preference = (unsigned char)0;
  curr_instance.dag.grounded = (unsigned char)0;
  curr_instance.dag.version = version;
  curr_instance.dag.rank = curr_instance.min_hoprankinc;
  if (0xFF == 0xFF) curr_instance.dag.lifetime = 0xFFFFFFFF;
  else curr_instance.dag.lifetime = (unsigned int)((unsigned long)curr_instance.lifetime_unit * (unsigned long)0xFF);
  curr_instance.dag.dio_intcurrent = (unsigned char)12;
  curr_instance.dag.state = DAG_REACHABLE;
  rpl_timers_dio_reset("Init root");
  {
    int tmp_0;
    if (0 < curr_log_level_rpl) tmp_0 = 0; else tmp_0 = curr_log_level_rpl;
    if (3 <= tmp_0) {
      printf("[%-4s: %-10s] ","INFO","RPL");
      printf("created DAG with instance ID %u, DAG ID ",
             (int)curr_instance.instance_id);
    }
  }
  {
    int tmp_1;
    if (0 < curr_log_level_rpl) tmp_1 = 0; else tmp_1 = curr_log_level_rpl;
    if (3 <= tmp_1) log_6addr((uip_ipaddr_t const *)(& curr_instance.dag.dag_id));
  }
  {
    int tmp_2;
    if (0 < curr_log_level_rpl) tmp_2 = 0; else tmp_2 = curr_log_level_rpl;
    if (3 <= tmp_2) printf(", rank %u\n",(int)curr_instance.dag.rank);
  }
  return;
}

void rpl_dag_init(void)
{
  memset((void *)(& curr_instance),0,sizeof(curr_instance));
  return;
}

__inline static unsigned int __bswap_32_79(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_79(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

rpl_nbr_t *get_probing_target(void);

clock_time_t get_probing_delay(void);

static void handle_dis_timer(void *ptr);

static void handle_dio_timer(void *ptr);

static void handle_unicast_dio_timer(void *ptr);

static void send_new_dao(void *ptr);

static void resend_dao(void *ptr);

static void handle_dao_ack_timer(void *ptr);

static void handle_probing_timer(void *ptr);

static void handle_periodic_timer(void *ptr);

static void handle_state_update(void *ptr);

static struct ctimer dis_timer;
static struct ctimer periodic_timer_0;
void rpl_timers_schedule_periodic_dis(void)
{
  int tmp_0;
  tmp_0 = ctimer_expired(& dis_timer);
  if (tmp_0) {
    unsigned short tmp;
    tmp = random_rand();
    clock_time_t expiration_time =
      (unsigned long)((30 * 1000) / 2 + (int)tmp % (30 * 1000));
    ctimer_set(& dis_timer,expiration_time,& handle_dis_timer,(void *)0);
  }
  return;
}

static void handle_dis_timer(void *ptr)
{
  int tmp;
  tmp = rpl_dag_root_is_root();
  if (! tmp) 
    if (! curr_instance.used) goto _LOR;
    else 
      if (curr_instance.dag.preferred_parent == (rpl_nbr_t *)0) goto _LOR;
      else 
        if ((int)curr_instance.dag.rank == 0xFFFF) {
          _LOR:
          {
            rpl_icmp6_dis_output((uip_ipaddr_t *)0);
            rpl_timers_schedule_periodic_dis();
          }
        }
  return;
}

static void new_dio_interval(void)
{
  uint32_t time_0;
  clock_time_t ticks;
  unsigned short tmp;
  time_0 = (unsigned int)(1UL << (int)curr_instance.dag.dio_intcurrent);
  ticks = (unsigned long)((time_0 * (uint32_t)1000) / (uint32_t)1000);
  curr_instance.dag.dio_next_delay = ticks;
  tmp = random_rand();
  ticks = ticks / (clock_time_t)2 + ((ticks / (clock_time_t)2) * (clock_time_t)((unsigned int)tmp)) / (clock_time_t)65535U;
  curr_instance.dag.dio_next_delay -= ticks;
  curr_instance.dag.dio_send = (unsigned char)1;
  curr_instance.dag.dio_counter = (unsigned char)0;
  ctimer_set(& curr_instance.dag.dio_timer,ticks,& handle_dio_timer,
             (void *)0);
  return;
}

void rpl_timers_dio_reset(char const *str)
{
  int tmp_1;
  tmp_1 = rpl_dag_ready_to_advertise();
  if (tmp_1) {
    uint8_t tmp_0;
    {
      int tmp;
      if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
      if (3 <= tmp) {
        printf("[%-4s: %-10s] ","INFO","RPL");
        printf("reset DIO timer (%s)\n",str);
      }
    }
    tmp_0 = rpl_get_leaf_only();
    if (! tmp_0) {
      curr_instance.dag.dio_counter = (unsigned char)0;
      curr_instance.dag.dio_intcurrent = curr_instance.dio_intmin;
      new_dio_interval();
    }
  }
  return;
}

static void handle_dio_timer(void *ptr)
{
  int tmp;
  tmp = rpl_dag_ready_to_advertise();
  if (! tmp) goto return_label;
  if (curr_instance.dag.dio_send) {
    int tmp_0;
    tmp_0 = rpl_dag_root_is_root();
    if (tmp_0) goto _LOR;
    else 
      if ((int)curr_instance.dio_redundancy == 0) goto _LOR;
      else 
        if ((int)curr_instance.dag.dio_counter < (int)curr_instance.dio_redundancy) {
          _LOR:
          {
            curr_instance.dag.last_advertised_rank = curr_instance.dag.rank;
            rpl_icmp6_dio_output((uip_ipaddr_t *)0);
          }
        }
    curr_instance.dag.dio_send = (unsigned char)0;
    ctimer_set(& curr_instance.dag.dio_timer,
               curr_instance.dag.dio_next_delay,& handle_dio_timer,(void *)0);
  }
  else {
    if ((int)curr_instance.dag.dio_intcurrent < (int)curr_instance.dio_intmin + (int)curr_instance.dio_intdoubl) 
      curr_instance.dag.dio_intcurrent = (uint8_t)((int)curr_instance.dag.dio_intcurrent + 1);
    new_dio_interval();
  }
  return_label: return;
}

void rpl_timers_schedule_unicast_dio(rpl_nbr_t *target)
{
  if (curr_instance.used) {
    curr_instance.dag.unicast_dio_target = target;
    ctimer_set(& curr_instance.dag.unicast_dio_timer,(unsigned long)0,
               & handle_unicast_dio_timer,(void *)0);
  }
  return;
}

static void handle_unicast_dio_timer(void *ptr)
{
  uip_ipaddr_t *target_ipaddr =
    rpl_neighbor_get_ipaddr(curr_instance.dag.unicast_dio_target);
  if (target_ipaddr != (uip_ipaddr_t *)0) rpl_icmp6_dio_output(target_ipaddr);
  return;
}

static void schedule_dao_retransmission(void)
{
  unsigned short tmp;
  tmp = random_rand();
  clock_time_t expiration_time =
    (unsigned long)((5 * 1000) / 2 + (int)tmp % (5 * 1000));
  ctimer_set(& curr_instance.dag.dao_timer,expiration_time,& resend_dao,
             (void *)0);
  return;
}

static void schedule_dao_refresh(void)
{
  if (curr_instance.used) 
    if ((int)curr_instance.default_lifetime != 0xFF) {
      unsigned long tmp;
      unsigned short tmp_0;
      if ((int)curr_instance.default_lifetime == 0xFF) tmp = (unsigned long)0xFFFFFFFF;
      else tmp = (unsigned long)curr_instance.lifetime_unit * (unsigned long)curr_instance.default_lifetime;
      clock_time_t target_refresh = (unsigned long)1000 * tmp;
      tmp_0 = random_rand();
      clock_time_t safety_margin =
        (unsigned long)(60 * 1000 + (int)tmp_0 % (60 * 1000));
      if (target_refresh > safety_margin) target_refresh -= safety_margin;
      ctimer_set(& curr_instance.dag.dao_timer,target_refresh,& send_new_dao,
                 (void *)0);
    }
  return;
}

void rpl_timers_schedule_dao(void)
{
  if (curr_instance.used) 
    if ((int)curr_instance.mop != 0) {
      unsigned short tmp;
      tmp = random_rand();
      clock_time_t expiration_time =
        (unsigned long)((1000 * 4) / 2 + (int)tmp % (1000 * 4));
      ctimer_set(& curr_instance.dag.dao_timer,expiration_time,
                 & send_new_dao,(void *)0);
    }
  return;
}

static void send_new_dao(void *ptr)
{
  curr_instance.dag.dao_transmissions = (unsigned char)1;
  schedule_dao_retransmission();
  if ((int)curr_instance.dag.dao_last_seqno > 127) curr_instance.dag.dao_last_seqno = (unsigned char)(
                                                   ((int)curr_instance.dag.dao_last_seqno + 1) & 255);
  else curr_instance.dag.dao_last_seqno = (unsigned char)(((int)curr_instance.dag.dao_last_seqno + 1) & 127);
  rpl_icmp6_dao_output(curr_instance.default_lifetime);
  return;
}

void rpl_timers_schedule_dao_ack(uip_ipaddr_t *target, uint16_t sequence)
{
  if (curr_instance.used) {
    curr_instance.dag.dao_ack_target = *target;
    curr_instance.dag.dao_ack_sequence = sequence;
    ctimer_set(& curr_instance.dag.dao_ack_timer,(unsigned long)0,
               & handle_dao_ack_timer,(void *)0);
  }
  return;
}

static void handle_dao_ack_timer(void *ptr)
{
  rpl_icmp6_dao_ack_output(& curr_instance.dag.dao_ack_target,
                           (unsigned char)curr_instance.dag.dao_ack_sequence,
                           (unsigned char)0);
  return;
}

void rpl_timers_notify_dao_ack(void)
{
  schedule_dao_refresh();
  return;
}

static void resend_dao(void *ptr)
{
  curr_instance.dag.dao_transmissions = (uint8_t)((int)curr_instance.dag.dao_transmissions + 1);
  rpl_icmp6_dao_output(curr_instance.default_lifetime);
  if ((int)curr_instance.dag.dao_transmissions < 5) schedule_dao_retransmission();
  else {
    rpl_local_repair("DAO max rtx");
    goto return_label;
  }
  return_label: return;
}

clock_time_t get_probing_delay(void)
{
  clock_time_t __retres;
  unsigned short tmp;
  tmp = random_rand();
  __retres = (unsigned long)((90 * 1000) / 2 + (int)tmp % (90 * 1000));
  return __retres;
}

rpl_nbr_t *get_probing_target(void)
{
  rpl_nbr_t *__retres;
  rpl_nbr_t *nbr_0;
  unsigned short tmp_5;
  rpl_nbr_t *probing_target = (rpl_nbr_t *)0;
  rpl_rank_t probing_target_rank = (unsigned short)0xFFFF;
  clock_time_t probing_target_age = (unsigned long)0;
  clock_time_t clock_now = clock_time();
  if ((int)curr_instance.used == 0) {
    __retres = (rpl_nbr_t *)0;
    goto return_label;
  }
  if (curr_instance.dag.urgent_probing_target != (rpl_nbr_t *)0) {
    __retres = curr_instance.dag.urgent_probing_target;
    goto return_label;
  }
  if (curr_instance.dag.preferred_parent != (rpl_nbr_t *)0) {
    int tmp_0;
    tmp_0 = rpl_neighbor_is_fresh(curr_instance.dag.preferred_parent);
    if (! tmp_0) {
      __retres = curr_instance.dag.preferred_parent;
      goto return_label;
    }
  }
  tmp_5 = random_rand();
  if ((int)tmp_5 % 3 != 0) {
    nbr_0 = (rpl_nbr_t *)nbr_table_head(rpl_neighbors);
    while (nbr_0 != (rpl_nbr_t *)0) {
      int tmp_2;
      tmp_2 = rpl_neighbor_is_fresh(nbr_0);
      if (! tmp_2) {
        rpl_rank_t nbr_rank = rpl_neighbor_rank_via_nbr(nbr_0);
        if (probing_target == (rpl_nbr_t *)0) goto _LOR;
        else 
          if ((int)nbr_rank < (int)probing_target_rank) {
            _LOR: {
                    probing_target = nbr_0;
                    probing_target_rank = nbr_rank;
                  }
          }
      }
      nbr_0 = (rpl_nbr_t *)nbr_table_next(rpl_neighbors,
                                          (nbr_table_item_t *)nbr_0);
    }
  }
  else {
    nbr_0 = (rpl_nbr_t *)nbr_table_head(rpl_neighbors);
    while (nbr_0 != (rpl_nbr_t *)0) {
      int tmp_4;
      tmp_4 = rpl_neighbor_is_fresh(nbr_0);
      if (! tmp_4) {
        struct link_stats const *stats = rpl_neighbor_get_link_stats(nbr_0);
        if (stats != (struct link_stats const *)0) 
          if (probing_target == (rpl_nbr_t *)0) goto _LOR_0;
          else 
            if (clock_now - stats->last_tx_time > probing_target_age) {
              _LOR_0:
              {
                probing_target = nbr_0;
                probing_target_age = clock_now - stats->last_tx_time;
              }
            }
      }
      nbr_0 = (rpl_nbr_t *)nbr_table_next(rpl_neighbors,
                                          (nbr_table_item_t *)nbr_0);
    }
  }
  __retres = probing_target;
  return_label: return __retres;
}

static void handle_probing_timer(void *ptr)
{
  rpl_nbr_t *probing_target = get_probing_target();
  uip_ipaddr_t *target_ipaddr = rpl_neighbor_get_ipaddr(probing_target);
  if (target_ipaddr != (uip_ipaddr_t *)0) {
    struct link_stats const *stats =
      rpl_neighbor_get_link_stats(probing_target);
    struct link_stats const *tmp_2 = stats;
    {
      int tmp_2_0;
      if (0 < curr_log_level_rpl) tmp_2_0 = 0;
      else tmp_2_0 = curr_log_level_rpl;
      if (3 <= tmp_2_0) {
        printf("[%-4s: %-10s] ","INFO","RPL");
        printf("probing ");
      }
    }
    {
      int tmp_3;
      if (0 < curr_log_level_rpl) tmp_3 = 0; else tmp_3 = curr_log_level_rpl;
      if (3 <= tmp_3) log_6addr((uip_ipaddr_t const *)target_ipaddr);
    }
    {
      int tmp_7;
      if (0 < curr_log_level_rpl) tmp_7 = 0; else tmp_7 = curr_log_level_rpl;
      if (3 <= tmp_7) {
        unsigned int tmp_5;
        char const *tmp_6;
        if (stats != (struct link_stats const *)0) {
          clock_time_t tmp_4;
          tmp_4 = clock_time();
          tmp_5 = (unsigned int)((tmp_4 - stats->last_tx_time) / (clock_time_t)(
                                 60 * 1000));
        }
        else tmp_5 = (unsigned int)0;
        if (curr_instance.dag.urgent_probing_target != (rpl_nbr_t *)0) 
          tmp_6 = "(urgent)";
        else tmp_6 = "";
        printf(" %s last tx %u min ago\n",tmp_6,tmp_5);
      }
    }
    rpl_icmp6_dio_output(target_ipaddr);
  }
  else {
    int tmp_8;
    if (0 < curr_log_level_rpl) tmp_8 = 0; else tmp_8 = curr_log_level_rpl;
    if (3 <= tmp_8) {
      printf("[%-4s: %-10s] ","INFO","RPL");
      printf("no neighbor needs probing\n");
    }
  }
  rpl_schedule_probing();
  return;
}

void rpl_schedule_probing(void)
{
  if (curr_instance.used) {
    clock_time_t tmp;
    tmp = get_probing_delay();
    ctimer_set(& curr_instance.dag.probing_timer,tmp,& handle_probing_timer,
               (void *)0);
  }
  return;
}

void rpl_schedule_probing_now(void)
{
  if (curr_instance.used) {
    unsigned short tmp;
    tmp = random_rand();
    ctimer_set(& curr_instance.dag.probing_timer,
               (unsigned long)((int)tmp % (1000 * 4)),& handle_probing_timer,
               (void *)0);
  }
  return;
}

static void handle_leaving_timer(void *ptr)
{
  if (curr_instance.used) rpl_dag_leave();
  return;
}

void rpl_timers_unschedule_leaving(void)
{
  if (curr_instance.used) {
    int tmp;
    tmp = ctimer_expired(& curr_instance.dag.leave);
    if (! tmp) ctimer_stop(& curr_instance.dag.leave);
  }
  return;
}

void rpl_timers_schedule_leaving(void)
{
  if (curr_instance.used) {
    int tmp;
    tmp = ctimer_expired(& curr_instance.dag.leave);
    if (tmp) ctimer_set(& curr_instance.dag.leave,
                        (unsigned long)((5 * 60) * 1000),
                        & handle_leaving_timer,(void *)0);
  }
  return;
}

void rpl_timers_init(void)
{
  ctimer_set(& periodic_timer_0,(unsigned long)(60 * 1000),
             & handle_periodic_timer,(void *)0);
  rpl_timers_schedule_periodic_dis();
  return;
}

static void handle_periodic_timer(void *ptr)
{
  int tmp;
  if (curr_instance.used) {
    rpl_dag_periodic((unsigned int)60);
    uip_sr_periodic((unsigned int)60);
  }
  if (! curr_instance.used) goto _LOR;
  else 
    if (curr_instance.dag.preferred_parent == (rpl_nbr_t *)0) goto _LOR;
    else 
      if ((int)curr_instance.dag.rank == 0xFFFF) _LOR:
                                                 rpl_timers_schedule_periodic_dis();
  rpl_dag_update_state();
  if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
  if (tmp >= 3) {
    rpl_neighbor_print_list("Periodic");
    rpl_dag_root_print_links("Periodic");
  }
  ctimer_reset(& periodic_timer_0);
  return;
}

void rpl_timers_stop_dag_timers(void)
{
  ctimer_stop(& curr_instance.dag.state_update);
  ctimer_stop(& curr_instance.dag.leave);
  ctimer_stop(& curr_instance.dag.dio_timer);
  ctimer_stop(& curr_instance.dag.unicast_dio_timer);
  ctimer_stop(& curr_instance.dag.dao_timer);
  ctimer_stop(& curr_instance.dag.probing_timer);
  ctimer_stop(& curr_instance.dag.dao_ack_timer);
  return;
}

void rpl_timers_unschedule_state_update(void)
{
  if (curr_instance.used) ctimer_stop(& curr_instance.dag.state_update);
  return;
}

void rpl_timers_schedule_state_update(void)
{
  if (curr_instance.used) ctimer_set(& curr_instance.dag.state_update,
                                     (unsigned long)0,& handle_state_update,
                                     (void *)0);
  return;
}

static void handle_state_update(void *ptr)
{
  rpl_dag_update_state();
  return;
}

__inline static unsigned int __bswap_32_80(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_80(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

int rpl_ext_header_srh_get_next_hop(uip_ipaddr_t *ipaddr)
{
  int __retres;
  struct uip_routing_hdr *rh_header;
  uip_sr_node_t *dest_node;
  uip_sr_node_t *root_node;
  int tmp_0;
  rh_header = (struct uip_routing_hdr *)uipbuf_search_header(uip_aligned_buf.u8,
                                                             uip_len,
                                                             (unsigned char)43);
  tmp_0 = rpl_is_addr_in_our_dag((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  root_node = uip_sr_get_node((void *)0,
                              (uip_ipaddr_t const *)(& curr_instance.dag.dag_id));
  dest_node = uip_sr_get_node((void *)0,
                              (uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
  if (rh_header != (struct uip_routing_hdr *)0) {
    if ((int)rh_header->routing_type == 3) goto _LOR; else goto _LAND;
  }
  else {
    _LAND: ;
    if (dest_node != (uip_sr_node_t *)0) 
      if (root_node != (uip_sr_node_t *)0) 
        if (dest_node->parent == root_node) {
          _LOR:
          {
            *ipaddr = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr;
            ipaddr->u16[0] = (unsigned short)(((int)((unsigned short)0xfe80) << 8) | (
                                              (int)((unsigned short)0xfe80) >> 8));
            ipaddr->u16[1] = (unsigned short)0;
            ipaddr->u16[2] = (unsigned short)0;
            ipaddr->u16[3] = (unsigned short)0;
            __retres = 1;
            goto return_label;
          }
        }
  }
  {
    int tmp_1;
    if (0 < curr_log_level_rpl) tmp_1 = 0; else tmp_1 = curr_log_level_rpl;
    if (4 <= tmp_1) {
      printf("[%-4s: %-10s] ","DBG","RPL");
      printf("no SRH found\n");
    }
  }
  __retres = 0;
  return_label: return __retres;
}

int rpl_ext_header_srh_update(void)
{
  int __retres;
  struct uip_routing_hdr *rh_header;
  struct uip_rpl_srh_hdr *srh_header;
  uint8_t cmpri;
  uint8_t cmpre;
  uint8_t ext_len;
  uint8_t padding;
  uint8_t path_len;
  uint8_t segments_left;
  uip_ipaddr_t current_dest_addr;
  rh_header = (struct uip_routing_hdr *)uipbuf_search_header(uip_aligned_buf.u8,
                                                             uip_len,
                                                             (unsigned char)43);
  if (rh_header == (struct uip_routing_hdr *)0) goto _LOR;
  else 
    if ((int)rh_header->routing_type != 3) {
      _LOR:
      {
        {
          int tmp_0;
          if (0 < curr_log_level_rpl) tmp_0 = 0;
          else tmp_0 = curr_log_level_rpl;
          if (3 <= tmp_0) {
            printf("[%-4s: %-10s] ","INFO","RPL");
            printf("SRH not found\n");
          }
        }
        __retres = 0;
        goto return_label;
      }
    }
  srh_header = (struct uip_rpl_srh_hdr *)((uint8_t *)rh_header + 4);
  segments_left = rh_header->seg_left;
  ext_len = (unsigned char)((int)rh_header->len * 8 + 8);
  cmpri = (unsigned char)((int)srh_header->cmpr >> 4);
  cmpre = (unsigned char)((int)srh_header->cmpr & 0x0f);
  padding = (unsigned char)((int)srh_header->pad >> 4);
  path_len = (unsigned char)((((((int)ext_len - (int)padding) - 4) - 4) - (
                              16 - (int)cmpre)) / (16 - (int)cmpri) + 1);
  uint8_t tmp_2 = path_len;
  {
    int tmp_1;
    if (0 < curr_log_level_rpl) tmp_1 = 0; else tmp_1 = curr_log_level_rpl;
    if (3 <= tmp_1) {
      printf("[%-4s: %-10s] ","INFO","RPL");
      printf("read SRH, path len %u, segments left %u, Cmpri %u, Cmpre %u, ext len %u (padding %u)\n",
             (int)path_len,(int)segments_left,(int)cmpri,(int)cmpre,
             (int)ext_len,(int)padding);
    }
  }
  if (! ((int)segments_left == 0)) {
    int tmp_2_1;
    uint8_t i = (unsigned char)((int)path_len - (int)segments_left);
    uint8_t *addr_ptr =
      (((uint8_t *)rh_header + 4) + 4) + (int)i * (16 - (int)cmpri);
    if ((int)segments_left == 1) tmp_2_1 = (int)cmpre;
    else tmp_2_1 = (int)cmpri;
    uint8_t cmpr = (unsigned char)tmp_2_1;
    current_dest_addr = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr;
    memcpy((void *)((uint8_t *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr) + (int)cmpr),
           (void const *)addr_ptr,(unsigned long)(16 - (int)cmpr));
    memcpy((void *)addr_ptr,
           (void const *)((uint8_t *)(& current_dest_addr) + (int)cmpr),
           (unsigned long)(16 - (int)cmpr));
    rh_header->seg_left = (uint8_t)((int)rh_header->seg_left - 1);
    {
      int tmp_3;
      if (0 < curr_log_level_rpl) tmp_3 = 0; else tmp_3 = curr_log_level_rpl;
      if (3 <= tmp_3) {
        printf("[%-4s: %-10s] ","INFO","RPL");
        printf("SRH next hop ");
      }
    }
    {
      int tmp_4;
      if (0 < curr_log_level_rpl) tmp_4 = 0; else tmp_4 = curr_log_level_rpl;
      if (3 <= tmp_4) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
    }
    {
      int tmp_5;
      if (0 < curr_log_level_rpl) tmp_5 = 0; else tmp_5 = curr_log_level_rpl;
      if (3 <= tmp_5) printf("\n");
    }
  }
  __retres = 1;
  return_label: return __retres;
}

static int count_matching_bytes(void const *p1, void const *p2, size_t n)
{
  int __retres;
  int i = 0;
  i = 0;
  while ((size_t)i < n) {
    if ((int)*((uint8_t *)p1 + i) != (int)*((uint8_t *)p2 + i)) {
      __retres = i;
      goto return_label;
    }
    i ++;
  }
  __retres = (int)n;
  return_label: return __retres;
}

static int insert_srh_header(void)
{
  int __retres;
  uint8_t path_len;
  uint8_t ext_len;
  uint8_t cmpri;
  uint8_t cmpre;
  uint8_t *hop_ptr;
  uint8_t padding;
  uip_sr_node_t *dest_node;
  uip_sr_node_t *root_node;
  uip_sr_node_t *node;
  uip_ipaddr_t node_addr;
  int tmp_3;
  int tmp_7;
  struct uip_routing_hdr *rh_hdr =
    (struct uip_routing_hdr *)(& uip_aligned_buf.u8[40] + 0);
  struct uip_rpl_srh_hdr *srh_hdr =
    (struct uip_rpl_srh_hdr *)((& uip_aligned_buf.u8[40] + 0) + 4);
  {
    int tmp;
    if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
    if (3 <= tmp) {
      printf("[%-4s: %-10s] ","INFO","RPL");
      printf("SRH creating source routing header with destination ");
    }
  }
  {
    int tmp_0;
    if (0 < curr_log_level_rpl) tmp_0 = 0; else tmp_0 = curr_log_level_rpl;
    if (3 <= tmp_0) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
  }
  {
    int tmp_1;
    if (0 < curr_log_level_rpl) tmp_1 = 0; else tmp_1 = curr_log_level_rpl;
    if (3 <= tmp_1) printf(" \n");
  }
  tmp_3 = rpl_is_addr_in_our_dag((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
  if (! tmp_3) {
    {
      int tmp_2;
      if (0 < curr_log_level_rpl) tmp_2 = 0; else tmp_2 = curr_log_level_rpl;
      if (3 <= tmp_2) {
        printf("[%-4s: %-10s] ","INFO","RPL");
        printf("SRH destination not in our DAG, skip SRH insertion\n");
      }
    }
    __retres = 1;
    goto return_label;
  }
  dest_node = uip_sr_get_node((void *)0,
                              (uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
  if (dest_node == (uip_sr_node_t *)0) {
    {
      int tmp_4;
      if (0 < curr_log_level_rpl) tmp_4 = 0; else tmp_4 = curr_log_level_rpl;
      if (3 <= tmp_4) {
        printf("[%-4s: %-10s] ","INFO","RPL");
        printf("SRH node not found, skip SRH insertion\n");
      }
    }
    __retres = 1;
    goto return_label;
  }
  root_node = uip_sr_get_node((void *)0,
                              (uip_ipaddr_t const *)(& curr_instance.dag.dag_id));
  if (root_node == (uip_sr_node_t *)0) {
    {
      int tmp_5;
      if (0 < curr_log_level_rpl) tmp_5 = 0; else tmp_5 = curr_log_level_rpl;
      if (1 <= tmp_5) {
        printf("[%-4s: %-10s] ","ERR","RPL");
        printf("SRH root node not found\n");
      }
    }
    __retres = 0;
    goto return_label;
  }
  tmp_7 = uip_sr_is_addr_reachable((void *)0,
                                   (uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
  if (! tmp_7) {
    {
      int tmp_6;
      if (0 < curr_log_level_rpl) tmp_6 = 0; else tmp_6 = curr_log_level_rpl;
      if (1 <= tmp_6) {
        printf("[%-4s: %-10s] ","ERR","RPL");
        printf("SRH no path found to destination\n");
      }
    }
    __retres = 0;
    goto return_label;
  }
  path_len = (unsigned char)0;
  node = dest_node->parent;
  cmpri = (unsigned char)15;
  cmpre = (unsigned char)15;
  while (1) {
    if (node != (uip_sr_node_t *)0) {
      if (! (node != root_node)) break;
    }
    else break;
    {
      int tmp_8;
      (*(rpl_lite_driver.get_sr_node_ipaddr))(& node_addr,
                                              (uip_sr_node_t const *)node);
      tmp_8 = count_matching_bytes((void const *)(& node_addr),
                                   (void const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr),
                                   (unsigned long)16);
      if ((int)cmpri < tmp_8) cmpri = cmpri;
      else {
        int tmp_9;
        tmp_9 = count_matching_bytes((void const *)(& node_addr),
                                     (void const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr),
                                     (unsigned long)16);
        cmpri = (unsigned char)tmp_9;
      }
      cmpre = cmpri;
      {
        int tmp_10;
        if (0 < curr_log_level_rpl) tmp_10 = 0;
        else tmp_10 = curr_log_level_rpl;
        if (3 <= tmp_10) {
          printf("[%-4s: %-10s] ","INFO","RPL");
          printf("SRH Hop ");
        }
      }
      {
        int tmp_11;
        if (0 < curr_log_level_rpl) tmp_11 = 0;
        else tmp_11 = curr_log_level_rpl;
        if (3 <= tmp_11) log_6addr((uip_ipaddr_t const *)(& node_addr));
      }
      {
        int tmp_12;
        if (0 < curr_log_level_rpl) tmp_12 = 0;
        else tmp_12 = curr_log_level_rpl;
        if (3 <= tmp_12) printf("\n");
      }
      node = node->parent;
      path_len = (uint8_t)((int)path_len + 1);
    }
  }
  ext_len = (unsigned char)(((4 + 4) + ((int)path_len - 1) * (16 - (int)cmpre)) + (
                            16 - (int)cmpri));
  if ((int)ext_len % 8 == 0) padding = (unsigned char)0;
  else padding = (unsigned char)(8 - (int)ext_len % 8);
  ext_len = (unsigned char)((int)ext_len + (int)padding);
  {
    int tmp_13;
    if (0 < curr_log_level_rpl) tmp_13 = 0; else tmp_13 = curr_log_level_rpl;
    if (3 <= tmp_13) {
      printf("[%-4s: %-10s] ","INFO","RPL");
      printf("SRH path len: %u, ComprI %u, ComprE %u, ext len %u (padding %u)\n",
             (int)path_len,(int)cmpri,(int)cmpre,(int)ext_len,(int)padding);
    }
  }
  if ((int)uip_len + (int)ext_len > 1280) {
    {
      int tmp_14;
      if (0 < curr_log_level_rpl) tmp_14 = 0;
      else tmp_14 = curr_log_level_rpl;
      if (1 <= tmp_14) {
        printf("[%-4s: %-10s] ","ERR","RPL");
        printf("packet too long: impossible to add source routing header (%u bytes)\n",
               (int)ext_len);
      }
    }
    __retres = 0;
    goto return_label;
  }
  memmove((void *)((& uip_aligned_buf.u8[40] + (int)uip_ext_len) + (int)ext_len),
          (void const *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len),
          (unsigned long)((int)uip_len - 40));
  memset((void *)(& uip_aligned_buf.u8[40] + (int)uip_ext_len),0,
         (unsigned long)ext_len);
  rh_hdr->next = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto = (unsigned char)43;
  rh_hdr->len = (unsigned char)(((int)ext_len - 8) / 8);
  rh_hdr->routing_type = (unsigned char)3;
  rh_hdr->seg_left = path_len;
  srh_hdr->cmpr = (unsigned char)(((int)cmpri << 4) + (int)cmpre);
  srh_hdr->pad = (unsigned char)((int)padding << 4);
  node = dest_node;
  hop_ptr = ((uint8_t *)rh_hdr + (int)ext_len) - (int)padding;
  while (1) {
    if (node != (uip_sr_node_t *)0) {
      if (! (node->parent != root_node)) break;
    }
    else break;
    (*(rpl_lite_driver.get_sr_node_ipaddr))(& node_addr,
                                            (uip_sr_node_t const *)node);
    hop_ptr -= 16 - (int)cmpri;
    memcpy((void *)hop_ptr,
           (void const *)((uint8_t *)(& node_addr) + (int)cmpri),
           (unsigned long)(16 - (int)cmpri));
    node = node->parent;
  }
  (*(rpl_lite_driver.get_sr_node_ipaddr))(& node_addr,
                                          (uip_sr_node_t const *)node);
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr = node_addr;
  uipbuf_add_ext_hdr((short)ext_len);
  uipbuf_set_len_field((struct uip_ip_hdr *)(uip_aligned_buf.u8),
                       (unsigned short)((int)uip_len - 40));
  __retres = 1;
  return_label: return __retres;
}

int rpl_ext_header_hbh_update(uint8_t *ext_buf, int opt_offset)
{
  int __retres;
  int down;
  int rank_error_signaled;
  int loop_detected;
  uint16_t sender_rank;
  uint8_t sender_closer;
  rpl_nbr_t *sender;
  linkaddr_t const *tmp_2;
  int tmp_3;
  int tmp_10;
  struct uip_hbho_hdr *hbh_hdr = (struct uip_hbho_hdr *)ext_buf;
  struct uip_ext_hdr_opt_rpl *rpl_opt =
    (struct uip_ext_hdr_opt_rpl *)(ext_buf + opt_offset);
  if ((int)hbh_hdr->len != (((4 + 2) + 2) - 8) / 8) goto _LOR;
  else 
    if ((int)rpl_opt->opt_type != 0x63) goto _LOR;
    else 
      if ((int)rpl_opt->opt_len != 4) {
        _LOR:
        {
          {
            int tmp;
            if (0 < curr_log_level_rpl) tmp = 0;
            else tmp = curr_log_level_rpl;
            if (1 <= tmp) {
              printf("[%-4s: %-10s] ","ERR","RPL");
              printf("hop-by-hop extension header has wrong size or type (%u %u %u)\n",
                     (int)hbh_hdr->len,(int)rpl_opt->opt_type,
                     (int)rpl_opt->opt_len);
            }
          }
          __retres = 0;
          goto return_label;
        }
      }
  if (! curr_instance.used) goto _LOR_0;
  else 
    if ((int)curr_instance.instance_id != (int)rpl_opt->instance) {
      _LOR_0:
      {
        {
          int tmp_0;
          if (0 < curr_log_level_rpl) tmp_0 = 0;
          else tmp_0 = curr_log_level_rpl;
          if (1 <= tmp_0) {
            printf("[%-4s: %-10s] ","ERR","RPL");
            printf("unknown instance: %u\n",(int)rpl_opt->instance);
          }
        }
        __retres = 0;
        goto return_label;
      }
    }
  if ((int)rpl_opt->flags & 0x20) {
    {
      int tmp_1;
      if (0 < curr_log_level_rpl) tmp_1 = 0; else tmp_1 = curr_log_level_rpl;
      if (1 <= tmp_1) {
        printf("[%-4s: %-10s] ","ERR","RPL");
        printf("forward error!\n");
      }
    }
    __retres = 0;
    goto return_label;
  }
  if ((int)rpl_opt->flags & 0x80) down = 1; else down = 0;
  sender_rank = (unsigned short)(((int)rpl_opt->senderrank << 8) | ((int)rpl_opt->senderrank >> 8));
  tmp_2 = packetbuf_addr((unsigned char)PACKETBUF_ADDR_SENDER);
  ;
  sender = (rpl_nbr_t *)nbr_table_get_from_lladdr(rpl_neighbors,tmp_2);
  if ((int)rpl_opt->flags & 0x40) rank_error_signaled = 1;
  else rank_error_signaled = 0;
  sender_closer = (unsigned char)((int)sender_rank < (int)curr_instance.dag.rank);
  if (down) {
    if (! sender_closer) tmp_3 = 1; else goto _LAND;
  }
  else 
    _LAND:
    if (! down) 
      if (sender_closer) tmp_3 = 1; else tmp_3 = 0;
    else tmp_3 = 0;
  loop_detected = tmp_3;
  {
    int tmp_4;
    if (0 < curr_log_level_rpl) tmp_4 = 0; else tmp_4 = curr_log_level_rpl;
    if (3 <= tmp_4) {
      printf("[%-4s: %-10s] ","INFO","RPL");
      printf("ext hdr: packet from ");
    }
  }
  {
    int tmp_5;
    if (0 < curr_log_level_rpl) tmp_5 = 0; else tmp_5 = curr_log_level_rpl;
    if (3 <= tmp_5) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr));
  }
  {
    int tmp_6;
    if (0 < curr_log_level_rpl) tmp_6 = 0; else tmp_6 = curr_log_level_rpl;
    if (3 <= tmp_6) printf(" to ");
  }
  {
    int tmp_7;
    if (0 < curr_log_level_rpl) tmp_7 = 0; else tmp_7 = curr_log_level_rpl;
    if (3 <= tmp_7) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr));
  }
  {
    int tmp_9;
    if (0 < curr_log_level_rpl) tmp_9 = 0; else tmp_9 = curr_log_level_rpl;
    if (3 <= tmp_9) {
      char const *tmp_8;
      ;
      ;
      ;
      ;
      ;
      if (down == 1) tmp_8 = "down"; else tmp_8 = "up";
      printf(" going %s, sender closer %d (%d < %d), rank error %u, loop detected %u\n",
             tmp_8,(int)sender_closer,(int)sender_rank,
             (int)curr_instance.dag.rank,rank_error_signaled,loop_detected);
    }
  }
  if (loop_detected) rpl_opt->flags = (unsigned char)((int)rpl_opt->flags | 0x40);
  tmp_10 = rpl_process_hbh(sender,sender_rank,loop_detected,
                           rank_error_signaled);
  __retres = tmp_10;
  return_label: return __retres;
}

static int update_hbh_header(void)
{
  int __retres;
  struct uip_hbho_hdr *hbh_hdr =
    (struct uip_hbho_hdr *)(& uip_aligned_buf.u8[40] + 0);
  struct uip_ext_hdr_opt_rpl *rpl_opt =
    (struct uip_ext_hdr_opt_rpl *)(& uip_aligned_buf.u8[40] + 2);
  if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto == 0) 
    if ((int)rpl_opt->opt_type == 0x63) {
      if ((int)hbh_hdr->len != (((4 + 2) + 2) - 8) / 8) goto _LOR;
      else 
        if ((int)rpl_opt->opt_len != 4) {
          _LOR:
          {
            {
              int tmp;
              if (0 < curr_log_level_rpl) tmp = 0;
              else tmp = curr_log_level_rpl;
              if (1 <= tmp) {
                printf("[%-4s: %-10s] ","ERR","RPL");
                printf("hop-by-hop extension header has wrong size (%u)\n",
                       (int)rpl_opt->opt_len);
              }
            }
            __retres = 0;
            goto return_label;
          }
        }
      if (! curr_instance.used) goto _LOR_0;
      else 
        if ((int)curr_instance.instance_id != (int)rpl_opt->instance) {
          _LOR_0:
          {
            {
              int tmp_0;
              if (0 < curr_log_level_rpl) tmp_0 = 0;
              else tmp_0 = curr_log_level_rpl;
              if (1 <= tmp_0) {
                printf("[%-4s: %-10s] ","ERR","RPL");
                printf("unable to add/update hop-by-hop extension header: incorrect instance\n");
              }
            }
            __retres = 0;
            goto return_label;
          }
        }
      rpl_opt->senderrank = (unsigned short)(((int)curr_instance.dag.rank << 8) | (
                                             (int)curr_instance.dag.rank >> 8));
      rpl_opt->instance = curr_instance.instance_id;
    }
  __retres = 1;
  return_label: return __retres;
}

static int insert_hbh_header(void)
{
  int __retres;
  int tmp_1;
  struct uip_hbho_hdr *hbh_hdr =
    (struct uip_hbho_hdr *)(& uip_aligned_buf.u8[40] + 0);
  struct uip_ext_hdr_opt_rpl *rpl_opt =
    (struct uip_ext_hdr_opt_rpl *)(& uip_aligned_buf.u8[40] + 2);
  {
    int tmp;
    if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
    if (3 <= tmp) {
      printf("[%-4s: %-10s] ","INFO","RPL");
      printf("creating hop-by-hop option\n");
    }
  }
  if ((int)uip_len + ((4 + 2) + 2) > 1280) {
    {
      int tmp_0;
      if (0 < curr_log_level_rpl) tmp_0 = 0; else tmp_0 = curr_log_level_rpl;
      if (1 <= tmp_0) {
        printf("[%-4s: %-10s] ","ERR","RPL");
        printf("packet too long: impossible to add hop-by-hop option\n");
      }
    }
    __retres = 0;
    goto return_label;
  }
  memmove((void *)(& uip_aligned_buf.u8[40] + ((4 + 2) + 2)),
          (void const *)(& uip_aligned_buf.u8[40] + 0),
          (unsigned long)((int)uip_len - 40));
  memset((void *)(& uip_aligned_buf.u8[40] + 0),0,
         (unsigned long)((4 + 2) + 2));
  hbh_hdr->next = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto;
  ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto = (unsigned char)0;
  hbh_hdr->len = (unsigned char)((((4 + 2) + 2) - 8) / 8);
  rpl_opt->opt_type = (unsigned char)0x63;
  rpl_opt->opt_len = (unsigned char)4;
  rpl_opt->flags = (unsigned char)0;
  rpl_opt->senderrank = (unsigned short)(((int)curr_instance.dag.rank << 8) | (
                                         (int)curr_instance.dag.rank >> 8));
  rpl_opt->instance = curr_instance.instance_id;
  uipbuf_add_ext_hdr((short)((4 + 2) + 2));
  uipbuf_set_len_field((struct uip_ip_hdr *)(uip_aligned_buf.u8),
                       (unsigned short)((int)uip_len - 40));
  tmp_1 = update_hbh_header();
  __retres = tmp_1;
  return_label: return __retres;
}

int rpl_ext_header_update(void)
{
  int __retres;
  int tmp_3;
  if (! curr_instance.used) goto _LOR;
  else 
    if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[0] == 0xfe) {
      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[1] == 0x80) 
        goto _LOR;
      else goto _LAND;
    }
    else {
      _LAND: ;
      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[0] == 0xFF) {
        _LOR: {
                __retres = 1;
                goto return_label;
              }
      }
    }
  tmp_3 = rpl_dag_root_is_root();
  if (tmp_3) {
    int tmp;
    rpl_ext_header_remove();
    tmp = insert_srh_header();
    __retres = tmp;
    goto return_label;
  }
  else {
    uip_ds6_addr_t *tmp_2;
    tmp_2 = uip_ds6_addr_lookup(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr);
    if (tmp_2 != (uip_ds6_addr_t *)0) {
      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->ttl == (int)uip_ds6_if.cur_hop_limit) {
        int tmp_0;
        tmp_0 = insert_hbh_header();
        __retres = tmp_0;
        goto return_label;
      }
      else goto _LAND_0;
    }
    else {
      _LAND_0:
      {
        int tmp_1;
        tmp_1 = update_hbh_header();
        __retres = tmp_1;
        goto return_label;
      }
    }
  }
  return_label: return __retres;
}

_Bool rpl_ext_header_remove(void)
{
  _Bool __retres;
  uint8_t *prev_proto_ptr;
  uint8_t protocol;
  uint16_t ext_len;
  uint8_t *next_header;
  struct uip_ext_hdr *ext_ptr;
  struct uip_ext_hdr_opt *opt_ptr;
  next_header = uipbuf_get_next_header(uip_aligned_buf.u8,uip_len,& protocol,
                                       (_Bool)1);
  if (next_header == (uint8_t *)0) {
    __retres = (_Bool)1;
    goto return_label;
  }
  ext_ptr = (struct uip_ext_hdr *)next_header;
  prev_proto_ptr = & ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->proto;
  while (1) {
    if ((int)protocol != 6) 
      if ((int)protocol != 17) {
        if (! ((int)protocol != 58)) break;
      }
      else break;
    else break;
    opt_ptr = (struct uip_ext_hdr_opt *)(next_header + 2);
    if ((int)protocol == 43) goto _LOR;
    else 
      if ((int)protocol == 0) {
        if ((int)opt_ptr->type == 0x63) {
          _LOR:
          {
            _Bool tmp;
            *prev_proto_ptr = ext_ptr->next;
            ext_len = (unsigned short)((int)ext_ptr->len * 8 + 8);
            tmp = uipbuf_add_ext_hdr((short)(- ((int)ext_len)));
            if ((int)tmp == 0) {
              __retres = (_Bool)0;
              goto return_label;
            }
            uipbuf_set_len_field((struct uip_ip_hdr *)(uip_aligned_buf.u8),
                                 (unsigned short)((int)uip_len - 40));
            if ((long)uip_len <= next_header - uip_aligned_buf.u8) {
              __retres = (_Bool)0;
              goto return_label;
            }
            memmove((void *)next_header,
                    (void const *)(next_header + (int)ext_len),
                    (unsigned long)((long)uip_len - (next_header - uip_aligned_buf.u8)));
            protocol = *prev_proto_ptr;
          }
        }
        else goto _LAND;
      }
      else {
        _LAND:
        {
          next_header = uipbuf_get_next_header(next_header,
                                               (unsigned short)((long)uip_len - (
                                                                next_header - uip_aligned_buf.u8)),
                                               & protocol,(_Bool)0);
          if (next_header == (uint8_t *)0) break;
          ext_ptr = (struct uip_ext_hdr *)next_header;
          prev_proto_ptr = & ext_ptr->next;
        }
      }
  }
  __retres = (_Bool)1;
  return_label: return __retres;
}

__inline static unsigned int __bswap_32_81(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_81(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

uip_ipaddr_t rpl_multicast_addr;
static uint8_t rpl_leaf_only = (unsigned char)0;
int rpl_lollipop_greater_than(int a, int b)
{
  int __retres;
  int tmp;
  if (a > 127) 
    if (b <= 127) {
      __retres = ((255 + 1) + b) - a > 16;
      goto return_label;
    }
  if (a > b) {
    if (a - b < 16) tmp = 1; else goto _LAND;
  }
  else {
    _LAND: ;
    if (a < b) 
      if (b - a > (127 + 1) - 16) tmp = 1; else tmp = 0;
    else tmp = 0;
  }
  __retres = tmp;
  return_label: return __retres;
}

uip_ipaddr_t const *rpl_get_global_address(void)
{
  uip_ipaddr_t const *__retres;
  int i;
  uint8_t state;
  uip_ipaddr_t *ipaddr = (uip_ipaddr_t *)0;
  uip_ipaddr_t *prefix = (uip_ipaddr_t *)0;
  uint8_t prefix_length = (unsigned char)0;
  if (curr_instance.used) 
    if ((int)curr_instance.dag.prefix_info.length != 0) {
      prefix = & curr_instance.dag.prefix_info.prefix;
      prefix_length = curr_instance.dag.prefix_info.length;
    }
  i = 0;
  while (i < 1 + 2) {
    state = uip_ds6_if.addr_list[i].state;
    if (uip_ds6_if.addr_list[i].isused) 
      if ((int)state == 1) 
        if ((int)uip_ds6_if.addr_list[i].ipaddr.u8[0] == 0xfe) {
          if (! ((int)uip_ds6_if.addr_list[i].ipaddr.u8[1] == 0x80)) 
            goto _LAND;
        }
        else {
          _LAND: ;
          if (prefix == (uip_ipaddr_t *)0) goto _LOR;
          else {
            int tmp;
            tmp = memcmp((void const *)prefix,
                         (void const *)(& uip_ds6_if.addr_list[i].ipaddr),
                         (unsigned long)((int)prefix_length >> 3));
            if (tmp == 0) _LOR: ipaddr = & uip_ds6_if.addr_list[i].ipaddr;
          }
        }
    i ++;
  }
  __retres = (uip_ipaddr_t const *)ipaddr;
  return __retres;
}

void rpl_link_callback(linkaddr_t const *addr_0, int status, int numtx)
{
  if ((int)curr_instance.used == 1) {
    rpl_nbr_t *nbr_0 = rpl_neighbor_get_from_lladdr((uip_lladdr_t *)addr_0);
    if (nbr_0 != (rpl_nbr_t *)0) {
      if (curr_instance.dag.urgent_probing_target == nbr_0) curr_instance.dag.urgent_probing_target = (rpl_nbr_t *)0;
      {
        int tmp_0;
        if (0 < curr_log_level_rpl) tmp_0 = 0;
        else tmp_0 = curr_log_level_rpl;
        if (3 <= tmp_0) {
          printf("[%-4s: %-10s] ","INFO","RPL");
          printf("packet sent to ");
        }
      }
      {
        int tmp_1;
        if (0 < curr_log_level_rpl) tmp_1 = 0;
        else tmp_1 = curr_log_level_rpl;
        if (3 <= tmp_1) log_lladdr(addr_0);
      }
      {
        int tmp_3;
        if (0 < curr_log_level_rpl) tmp_3 = 0;
        else tmp_3 = curr_log_level_rpl;
        if (3 <= tmp_3) {
          uint16_t tmp_2;
          tmp_2 = rpl_neighbor_get_link_metric(nbr_0);
          ;
          ;
          printf(", status %u, tx %u, new link metric %u\n",status,numtx,
                 (int)tmp_2);
        }
      }
      rpl_timers_schedule_state_update();
    }
  }
  return;
}

int rpl_has_joined(void)
{
  int tmp;
  if (curr_instance.used) 
    if (curr_instance.dag.state >= (unsigned int)DAG_JOINED) tmp = 1;
    else tmp = 0;
  else tmp = 0;
  return tmp;
}

int rpl_is_reachable(void)
{
  int tmp;
  if (curr_instance.used) 
    if (curr_instance.dag.state == (unsigned int)DAG_REACHABLE) tmp = 1;
    else tmp = 0;
  else tmp = 0;
  return tmp;
}

static void set_ip_from_prefix(uip_ipaddr_t *ipaddr, rpl_prefix_t *prefix)
{
  memset((void *)ipaddr,0,sizeof(uip_ipaddr_t));
  memcpy((void *)ipaddr,(void const *)(& prefix->prefix),
         (unsigned long)(((int)prefix->length + 7) / 8));
  uip_ds6_set_addr_iid(ipaddr,& uip_lladdr);
  return;
}

void rpl_reset_prefix(rpl_prefix_t *last_prefix)
{
  uip_ipaddr_t ipaddr;
  uip_ds6_addr_t *rep;
  set_ip_from_prefix(& ipaddr,last_prefix);
  rep = uip_ds6_addr_lookup(& ipaddr);
  if (rep != (uip_ds6_addr_t *)0) {
    {
      int tmp;
      if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
      if (3 <= tmp) {
        printf("[%-4s: %-10s] ","INFO","RPL");
        printf("removing global IP address ");
      }
    }
    {
      int tmp_0;
      if (0 < curr_log_level_rpl) tmp_0 = 0; else tmp_0 = curr_log_level_rpl;
      if (3 <= tmp_0) log_6addr((uip_ipaddr_t const *)(& ipaddr));
    }
    {
      int tmp_1;
      if (0 < curr_log_level_rpl) tmp_1 = 0; else tmp_1 = curr_log_level_rpl;
      if (3 <= tmp_1) printf("\n");
    }
    uip_ds6_addr_rm(rep);
  }
  curr_instance.dag.prefix_info.length = (unsigned char)0;
  return;
}

int rpl_set_prefix_from_addr(uip_ipaddr_t *addr_0, unsigned int len,
                             uint8_t flags)
{
  int __retres;
  uip_ipaddr_t ipaddr;
  uip_ds6_addr_t *tmp_3;
  if (addr_0 == (uip_ipaddr_t *)0) goto _LOR;
  else 
    if (len == (unsigned int)0) goto _LOR;
    else 
      if (len > (unsigned int)128) goto _LOR;
      else 
        if (! ((int)flags & 0x40)) {
          _LOR:
          {
            {
              int tmp;
              if (0 < curr_log_level_rpl) tmp = 0;
              else tmp = curr_log_level_rpl;
              if (2 <= tmp) {
                printf("[%-4s: %-10s] ","WARN","RPL");
                printf("prefix not included, not-supported or invalid\n");
              }
            }
            __retres = 0;
            goto return_label;
          }
        }
  memset((void *)(& curr_instance.dag.prefix_info.prefix),0,
         sizeof(rpl_prefix_t));
  memcpy((void *)(& curr_instance.dag.prefix_info.prefix),
         (void const *)addr_0,
         (unsigned long)((len + (unsigned int)7) / (unsigned int)8));
  curr_instance.dag.prefix_info.length = (unsigned char)len;
  curr_instance.dag.prefix_info.lifetime = 0xFFFFFFFF;
  curr_instance.dag.prefix_info.flags = flags;
  set_ip_from_prefix(& ipaddr,& curr_instance.dag.prefix_info);
  tmp_3 = uip_ds6_addr_lookup(& ipaddr);
  if (tmp_3 == (uip_ds6_addr_t *)0) {
    {
      int tmp_0;
      if (0 < curr_log_level_rpl) tmp_0 = 0; else tmp_0 = curr_log_level_rpl;
      if (3 <= tmp_0) {
        printf("[%-4s: %-10s] ","INFO","RPL");
        printf("adding global IP address ");
      }
    }
    {
      int tmp_1;
      if (0 < curr_log_level_rpl) tmp_1 = 0; else tmp_1 = curr_log_level_rpl;
      if (3 <= tmp_1) log_6addr((uip_ipaddr_t const *)(& ipaddr));
    }
    {
      int tmp_2;
      if (0 < curr_log_level_rpl) tmp_2 = 0; else tmp_2 = curr_log_level_rpl;
      if (3 <= tmp_2) printf("\n");
    }
    uip_ds6_addr_add(& ipaddr,(unsigned long)0,(unsigned char)1);
  }
  __retres = 1;
  return_label: return __retres;
}

int rpl_set_prefix(rpl_prefix_t *prefix)
{
  int __retres;
  if (prefix != (rpl_prefix_t *)0) {
    int tmp;
    tmp = rpl_set_prefix_from_addr(& prefix->prefix,
                                   (unsigned int)prefix->length,
                                   prefix->flags);
    if (tmp) {
      curr_instance.dag.prefix_info.lifetime = prefix->lifetime;
      __retres = 1;
      goto return_label;
    }
  }
  __retres = 0;
  return_label: return __retres;
}

static void init_3(void)
{
  {
    int tmp;
    if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
    if (3 <= tmp) {
      printf("[%-4s: %-10s] ","INFO","RPL");
      printf("initializing\n");
    }
  }
  rpl_multicast_addr.u16[0] = (unsigned short)(((int)((unsigned short)0xff02) << 8) | (
                                               (int)((unsigned short)0xff02) >> 8));
  rpl_multicast_addr.u16[1] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                               (int)((unsigned short)0) >> 8));
  rpl_multicast_addr.u16[2] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                               (int)((unsigned short)0) >> 8));
  rpl_multicast_addr.u16[3] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                               (int)((unsigned short)0) >> 8));
  rpl_multicast_addr.u16[4] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                               (int)((unsigned short)0) >> 8));
  rpl_multicast_addr.u16[5] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                               (int)((unsigned short)0) >> 8));
  rpl_multicast_addr.u16[6] = (unsigned short)(((int)((unsigned short)0) << 8) | (
                                               (int)((unsigned short)0) >> 8));
  rpl_multicast_addr.u16[7] = (unsigned short)(((int)((unsigned short)0x001a) << 8) | (
                                               (int)((unsigned short)0x001a) >> 8));
  uip_ds6_maddr_add((uip_ipaddr_t const *)(& rpl_multicast_addr));
  rpl_dag_init();
  rpl_neighbor_init();
  rpl_timers_init();
  rpl_icmp6_init();
  uip_sr_init();
  return;
}

static int get_sr_node_ipaddr(uip_ipaddr_t *addr_0, uip_sr_node_t const *node)
{
  int __retres;
  if (addr_0 != (uip_ipaddr_t *)0) {
    if (node != (uip_sr_node_t const *)0) {
      memcpy((void *)addr_0,(void const *)(& curr_instance.dag.dag_id),
             (unsigned long)8);
      memcpy((void *)((unsigned char *)addr_0 + 8),
             (void const *)(& node->link_identifier),(unsigned long)8);
      __retres = 1;
      goto return_label;
    }
    else goto _LAND;
  }
  else {
    _LAND: {
             __retres = 0;
             goto return_label;
           }
  }
  return_label: return __retres;
}

static void neighbor_state_changed(uip_ds6_nbr_t *nbr_0)
{
  return;
}

static void drop_route(uip_ds6_route_t *route)
{
  return;
}

void rpl_set_leaf_only(uint8_t value)
{
  rpl_leaf_only = value;
  return;
}

uint8_t rpl_get_leaf_only(void)
{
  return rpl_leaf_only;
}

struct routing_driver const rpl_lite_driver =
  {.name = (char *)"RPL Lite",
   .init = & init_3,
   .root_set_prefix = & rpl_dag_root_set_prefix,
   .root_start = & rpl_dag_root_start,
   .node_is_root = & rpl_dag_root_is_root,
   .get_root_ipaddr = & rpl_dag_get_root_ipaddr,
   .get_sr_node_ipaddr = & get_sr_node_ipaddr,
   .leave_network = & rpl_dag_poison_and_leave,
   .node_has_joined = & rpl_has_joined,
   .node_is_reachable = & rpl_is_reachable,
   .global_repair = & rpl_global_repair,
   .local_repair = & rpl_local_repair,
   .ext_header_remove = & rpl_ext_header_remove,
   .ext_header_update = & rpl_ext_header_update,
   .ext_header_hbh_update = & rpl_ext_header_hbh_update,
   .ext_header_srh_update = & rpl_ext_header_srh_update,
   .ext_header_srh_get_next_hop = & rpl_ext_header_srh_get_next_hop,
   .link_callback = & rpl_link_callback,
   .neighbor_state_changed = & neighbor_state_changed,
   .drop_route = & drop_route};
__inline static unsigned int __bswap_32_82(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_82(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static void reset_0(void)
{
  int tmp;
  if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
  if (3 <= tmp) {
    printf("[%-4s: %-10s] ","INFO","RPL");
    printf("reset MRHOF\n");
  }
  return;
}

static uint16_t nbr_link_metric_0(rpl_nbr_t *nbr_0)
{
  uint16_t __retres;
  int tmp_0;
  struct link_stats const *stats = rpl_neighbor_get_link_stats(nbr_0);
  if (stats != (struct link_stats const *)0) tmp_0 = (int)stats->etx;
  else tmp_0 = 0xffff;
  __retres = (unsigned short)tmp_0;
  return __retres;
}

static uint16_t link_metric_to_rank(uint16_t etx)
{
  return etx;
}

static uint16_t nbr_path_cost_0(rpl_nbr_t *nbr_0)
{
  uint16_t __retres;
  uint16_t base;
  unsigned int tmp_3;
  uint16_t tmp_0;
  uint16_t tmp;
  if (nbr_0 == (rpl_nbr_t *)0) {
    __retres = (unsigned short)0xffff;
    goto return_label;
  }
  base = nbr_0->rank;
  tmp = nbr_link_metric_0(nbr_0);
  tmp_0 = link_metric_to_rank(tmp);
  ;
  if ((unsigned int)base + (unsigned int)tmp_0 < (unsigned int)0xffff) {
    uint16_t tmp_2;
    uint16_t tmp_1;
    tmp_1 = nbr_link_metric_0(nbr_0);
    tmp_2 = link_metric_to_rank(tmp_1);
    tmp_3 = (unsigned int)base + (unsigned int)tmp_2;
  }
  else tmp_3 = (unsigned int)0xffff;
  __retres = (unsigned short)tmp_3;
  return_label: return __retres;
}

static rpl_rank_t rank_via_nbr_0(rpl_nbr_t *nbr_0)
{
  rpl_rank_t __retres;
  uint16_t min_hoprankinc;
  uint16_t path_cost;
  unsigned int tmp_1;
  unsigned int tmp;
  if (nbr_0 == (rpl_nbr_t *)0) {
    __retres = (unsigned short)0xFFFF;
    goto return_label;
  }
  min_hoprankinc = curr_instance.min_hoprankinc;
  path_cost = nbr_path_cost_0(nbr_0);
  if ((unsigned int)nbr_0->rank + (unsigned int)min_hoprankinc < (unsigned int)0xFFFF) 
    tmp = (unsigned int)nbr_0->rank + (unsigned int)min_hoprankinc;
  else tmp = (unsigned int)0xFFFF;
  ;
  if (tmp < (unsigned int)path_cost) tmp_1 = (unsigned int)path_cost;
  else {
    unsigned int tmp_0;
    if ((unsigned int)nbr_0->rank + (unsigned int)min_hoprankinc < (unsigned int)0xFFFF) 
      tmp_0 = (unsigned int)nbr_0->rank + (unsigned int)min_hoprankinc;
    else tmp_0 = (unsigned int)0xFFFF;
    tmp_1 = tmp_0;
  }
  __retres = (unsigned short)tmp_1;
  return_label: return __retres;
}

static int nbr_has_usable_link_0(rpl_nbr_t *nbr_0)
{
  int __retres;
  uint16_t link_metric = nbr_link_metric_0(nbr_0);
  __retres = (int)link_metric <= 512;
  return __retres;
}

static int nbr_is_acceptable_parent_0(rpl_nbr_t *nbr_0)
{
  int tmp_1;
  int tmp_0;
  uint16_t path_cost = nbr_path_cost_0(nbr_0);
  tmp_0 = nbr_has_usable_link_0(nbr_0);
  if (tmp_0) 
    if ((int)path_cost <= 32768) tmp_1 = 1; else tmp_1 = 0;
  else tmp_1 = 0;
  return tmp_1;
}

static int within_hysteresis(rpl_nbr_t *nbr_0)
{
  int tmp_2;
  int tmp_3;
  uint16_t path_cost = nbr_path_cost_0(nbr_0);
  uint16_t parent_path_cost =
    nbr_path_cost_0(curr_instance.dag.preferred_parent);
  int within_rank_hysteresis = (int)path_cost + 192 > (int)parent_path_cost;
  if (nbr_0->better_parent_since == (clock_time_t)0) tmp_2 = 1;
  else {
    clock_time_t tmp_1;
    tmp_1 = clock_time();
    ;
    if (tmp_1 - nbr_0->better_parent_since <= (clock_time_t)((10 * 60) * 1000)) 
      tmp_2 = 1;
    else tmp_2 = 0;
  }
  int within_time_hysteresis = tmp_2;
  if (within_rank_hysteresis) 
    if (within_time_hysteresis) tmp_3 = 1; else tmp_3 = 0;
  else tmp_3 = 0;
  return tmp_3;
}

static rpl_nbr_t *best_parent_1(rpl_nbr_t *nbr1, rpl_nbr_t *nbr2)
{
  rpl_nbr_t *__retres;
  int nbr1_is_acceptable;
  int nbr2_is_acceptable;
  int tmp_0;
  int tmp_2;
  rpl_nbr_t *tmp_9;
  uint16_t tmp_7;
  uint16_t tmp_8;
  if (nbr1 != (rpl_nbr_t *)0) {
    int tmp;
    tmp = nbr_is_acceptable_parent_0(nbr1);
    if (tmp) tmp_0 = 1; else tmp_0 = 0;
  }
  else tmp_0 = 0;
  nbr1_is_acceptable = tmp_0;
  if (nbr2 != (rpl_nbr_t *)0) {
    int tmp_1;
    tmp_1 = nbr_is_acceptable_parent_0(nbr2);
    if (tmp_1) tmp_2 = 1; else tmp_2 = 0;
  }
  else tmp_2 = 0;
  nbr2_is_acceptable = tmp_2;
  if (! nbr1_is_acceptable) {
    rpl_nbr_t *tmp_3;
    if (nbr2_is_acceptable) tmp_3 = nbr2; else tmp_3 = (rpl_nbr_t *)0;
    __retres = tmp_3;
    goto return_label;
  }
  if (! nbr2_is_acceptable) {
    rpl_nbr_t *tmp_4;
    if (nbr1_is_acceptable) tmp_4 = nbr1; else tmp_4 = (rpl_nbr_t *)0;
    __retres = tmp_4;
    goto return_label;
  }
  if (nbr1 == curr_instance.dag.preferred_parent) {
    int tmp_5;
    tmp_5 = within_hysteresis(nbr2);
    if (tmp_5) {
      __retres = nbr1;
      goto return_label;
    }
  }
  if (nbr2 == curr_instance.dag.preferred_parent) {
    int tmp_6;
    tmp_6 = within_hysteresis(nbr1);
    if (tmp_6) {
      __retres = nbr2;
      goto return_label;
    }
  }
  tmp_7 = nbr_path_cost_0(nbr1);
  tmp_8 = nbr_path_cost_0(nbr2);
  if ((int)tmp_7 < (int)tmp_8) tmp_9 = nbr1; else tmp_9 = nbr2;
  __retres = tmp_9;
  return_label: return __retres;
}

static void update_metric_container_0(void)
{
  curr_instance.mc.type = (unsigned char)0;
  return;
}

rpl_of_t rpl_mrhof =
  {.reset = & reset_0,
   .nbr_link_metric = & nbr_link_metric_0,
   .nbr_has_usable_link = & nbr_has_usable_link_0,
   .nbr_is_acceptable_parent = & nbr_is_acceptable_parent_0,
   .nbr_path_cost = & nbr_path_cost_0,
   .rank_via_nbr = & rank_via_nbr_0,
   .best_parent = & best_parent_1,
   .update_metric_container = & update_metric_container_0,
   .ocp = (unsigned short)1};
__inline static unsigned int __bswap_32_83(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_83(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static void dis_input(void);

static void dio_input(void);

static void dao_input(void);

static uip_icmp6_input_handler_t dis_handler =
  {.next = (struct uip_icmp6_input_handler *)0,
   .type = (unsigned char)155,
   .icode = (unsigned char)0x00,
   .handler = & dis_input};
static uip_icmp6_input_handler_t dio_handler =
  {.next = (struct uip_icmp6_input_handler *)0,
   .type = (unsigned char)155,
   .icode = (unsigned char)0x01,
   .handler = & dio_input};
static uip_icmp6_input_handler_t dao_handler =
  {.next = (struct uip_icmp6_input_handler *)0,
   .type = (unsigned char)155,
   .icode = (unsigned char)0x02,
   .handler = & dao_input};
static void dao_ack_input(void);

static uip_icmp6_input_handler_t dao_ack_handler =
  {.next = (struct uip_icmp6_input_handler *)0,
   .type = (unsigned char)155,
   .icode = (unsigned char)0x03,
   .handler = & dao_ack_input};
static uint32_t get32(uint8_t *buffer, int pos)
{
  uint32_t __retres;
  __retres = ((((unsigned int)*(buffer + pos) << 24) | ((unsigned int)*(
                                                        buffer + (pos + 1)) << 16)) | (
              (unsigned int)*(buffer + (pos + 2)) << 8)) | (unsigned int)*(
             buffer + (pos + 3));
  return __retres;
}

static void set32(uint8_t *buffer, int pos, uint32_t value)
{
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  tmp = pos;
  pos ++;
  *(buffer + tmp) = (unsigned char)(value >> 24);
  tmp_0 = pos;
  pos ++;
  *(buffer + tmp_0) = (unsigned char)((value >> 16) & (unsigned int)0xff);
  tmp_1 = pos;
  pos ++;
  *(buffer + tmp_1) = (unsigned char)((value >> 8) & (unsigned int)0xff);
  tmp_2 = pos;
  pos ++;
  *(buffer + tmp_2) = (unsigned char)(value & (unsigned int)0xff);
  return;
}

static uint16_t get16(uint8_t *buffer, int pos)
{
  uint16_t __retres;
  __retres = (unsigned short)(((int)((unsigned short)*(buffer + pos)) << 8) | (int)*(
                              buffer + (pos + 1)));
  return __retres;
}

static void set16(uint8_t *buffer, int pos, uint16_t value)
{
  int tmp;
  int tmp_0;
  tmp = pos;
  pos ++;
  *(buffer + tmp) = (unsigned char)((int)value >> 8);
  tmp_0 = pos;
  pos ++;
  *(buffer + tmp_0) = (unsigned char)((int)value & 0xff);
  return;
}

uip_ds6_nbr_t *rpl_icmp6_update_nbr_table(uip_ipaddr_t *from,
                                          nbr_table_reason_t reason,
                                          void *data)
{
  uip_ds6_nbr_t *nbr_0;
  nbr_0 = uip_ds6_nbr_lookup((uip_ipaddr_t const *)from);
  if (nbr_0 == (uip_ds6_nbr_t *)0) {
    linkaddr_t const *tmp_6;
    ;
    ;
    tmp_6 = packetbuf_addr((unsigned char)PACKETBUF_ADDR_SENDER);
    ;
    nbr_0 = uip_ds6_nbr_add((uip_ipaddr_t const *)from,
                            (uip_lladdr_t const *)tmp_6,(unsigned char)0,
                            (unsigned char)1,reason,data);
    if (nbr_0 == (uip_ds6_nbr_t *)0) {
      {
        int tmp;
        if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
        if (1 <= tmp) {
          printf("[%-4s: %-10s] ","ERR","RPL");
          printf("could not add neighbor to cache ");
        }
      }
      {
        int tmp_0;
        if (0 < curr_log_level_rpl) tmp_0 = 0;
        else tmp_0 = curr_log_level_rpl;
        if (1 <= tmp_0) log_6addr((uip_ipaddr_t const *)from);
      }
      {
        int tmp_1;
        if (0 < curr_log_level_rpl) tmp_1 = 0;
        else tmp_1 = curr_log_level_rpl;
        if (1 <= tmp_1) printf(", ");
      }
      {
        int tmp_4;
        if (0 < curr_log_level_rpl) tmp_4 = 0;
        else tmp_4 = curr_log_level_rpl;
        if (1 <= tmp_4) {
          linkaddr_t const *tmp_3;
          tmp_3 = packetbuf_addr((unsigned char)PACKETBUF_ADDR_SENDER);
          log_lladdr(tmp_3);
        }
      }
      {
        int tmp_5;
        if (0 < curr_log_level_rpl) tmp_5 = 0;
        else tmp_5 = curr_log_level_rpl;
        if (1 <= tmp_5) printf("\n");
      }
    }
  }
  return nbr_0;
}

static void dis_input(void)
{
  if (! curr_instance.used) {
    {
      int tmp;
      if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
      if (2 <= tmp) {
        printf("[%-4s: %-10s] ","WARN","RPL");
        printf("dis_input: not in an instance yet, discard\n");
      }
    }
    goto discard;
  }
  {
    int tmp_0;
    if (0 < curr_log_level_rpl) tmp_0 = 0; else tmp_0 = curr_log_level_rpl;
    if (3 <= tmp_0) {
      printf("[%-4s: %-10s] ","INFO","RPL");
      printf("received a DIS from ");
    }
  }
  {
    int tmp_1;
    if (0 < curr_log_level_rpl) tmp_1 = 0; else tmp_1 = curr_log_level_rpl;
    if (3 <= tmp_1) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr));
  }
  {
    int tmp_2;
    if (0 < curr_log_level_rpl) tmp_2 = 0; else tmp_2 = curr_log_level_rpl;
    if (3 <= tmp_2) printf("\n");
  }
  rpl_process_dis(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr,
                  (int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[0] == 0xFF);
  discard: uipbuf_clear();
  return;
}

void rpl_icmp6_dis_output(uip_ipaddr_t *addr_0)
{
  unsigned char *buffer;
  unsigned char tmp;
  rpl_dag_update_state();
  buffer = (& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4;
  tmp = (unsigned char)0;
  *(buffer + 1) = tmp;
  *(buffer + 0) = tmp;
  if (addr_0 == (uip_ipaddr_t *)0) addr_0 = & rpl_multicast_addr;
  {
    int tmp_0;
    if (0 < curr_log_level_rpl) tmp_0 = 0; else tmp_0 = curr_log_level_rpl;
    if (3 <= tmp_0) {
      printf("[%-4s: %-10s] ","INFO","RPL");
      printf("sending a DIS to ");
    }
  }
  {
    int tmp_1;
    if (0 < curr_log_level_rpl) tmp_1 = 0; else tmp_1 = curr_log_level_rpl;
    if (3 <= tmp_1) log_6addr((uip_ipaddr_t const *)addr_0);
  }
  {
    int tmp_2;
    if (0 < curr_log_level_rpl) tmp_2 = 0; else tmp_2 = curr_log_level_rpl;
    if (3 <= tmp_2) printf("\n");
  }
  uip_icmp6_send((uip_ipaddr_t const *)addr_0,155,0x00,2);
  return;
}

static void dio_input(void)
{
  unsigned char *buffer;
  uint8_t buffer_length;
  rpl_dio_t dio;
  uint8_t subopt_type;
  int i;
  int len;
  uip_ipaddr_t from;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  memset((void *)(& dio),0,sizeof(dio));
  dio.dag_intdoubl = (unsigned char)8;
  dio.dag_intmin = (unsigned char)12;
  dio.dag_redund = (unsigned char)0;
  dio.dag_min_hoprankinc = (unsigned short)128;
  dio.dag_max_rankinc = (unsigned short)(8 * 128);
  dio.ocp = (unsigned short)1;
  dio.default_lifetime = (unsigned char)30;
  dio.lifetime_unit = (unsigned short)60;
  from = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr;
  buffer_length = (unsigned char)((int)uip_len - ((40 + (int)uip_ext_len) + 4));
  i = 0;
  buffer = (& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4;
  tmp = i;
  i ++;
  dio.instance_id = *(buffer + tmp);
  tmp_0 = i;
  i ++;
  dio.version = *(buffer + tmp_0);
  dio.rank = get16(buffer,i);
  i += 2;
  dio.grounded = (unsigned char)((int)*(buffer + i) & 0x80);
  dio.mop = (unsigned char)(((int)*(buffer + i) & 0x38) >> 3);
  tmp_1 = i;
  i ++;
  dio.preference = (unsigned char)((int)*(buffer + tmp_1) & 0x07);
  tmp_2 = i;
  i ++;
  dio.dtsn = *(buffer + tmp_2);
  i += 2;
  memcpy((void *)(& dio.dag_id),(void const *)(buffer + i),
         sizeof(dio.dag_id));
  i = (int)((unsigned long)i + sizeof(dio.dag_id));
  while (i < (int)buffer_length) {
    subopt_type = *(buffer + i);
    if ((int)subopt_type == 0) len = 1;
    else len = 2 + (int)*(buffer + (i + 1));
    if (len + i > (int)buffer_length) {
      {
        int tmp_3;
        if (0 < curr_log_level_rpl) tmp_3 = 0;
        else tmp_3 = curr_log_level_rpl;
        if (1 <= tmp_3) {
          printf("[%-4s: %-10s] ","ERR","RPL");
          printf("dio_input: malformed packet, discard\n");
        }
      }
      goto discard;
    }
    switch ((int)subopt_type) {
      case 2: ;
      if (len < 6) {
        {
          int tmp_4;
          if (0 < curr_log_level_rpl) tmp_4 = 0;
          else tmp_4 = curr_log_level_rpl;
          if (2 <= tmp_4) {
            printf("[%-4s: %-10s] ","WARN","RPL");
            printf("dio_input: invalid DAG MC, len %u, discard\n",len);
          }
        }
        goto discard;
      }
      dio.mc.type = *(buffer + (i + 2));
      dio.mc.flags = (unsigned char)((int)*(buffer + (i + 3)) << 1);
      dio.mc.flags = (unsigned char)((int)dio.mc.flags | ((int)*(buffer + (
                                                                 i + 4)) >> 7));
      dio.mc.aggr = (unsigned char)(((int)*(buffer + (i + 4)) >> 4) & 0x3);
      dio.mc.prec = (unsigned char)((int)*(buffer + (i + 4)) & 0xf);
      dio.mc.length = *(buffer + (i + 5));
      if (! ((int)dio.mc.type == 0)) 
        if ((int)dio.mc.type == 7) dio.mc.obj.etx = get16(buffer,i + 6);
        else 
          if ((int)dio.mc.type == 2) {
            dio.mc.obj.energy.flags = *(buffer + (i + 6));
            dio.mc.obj.energy.energy_est = *(buffer + (i + 7));
          }
          else {
            {
              int tmp_5;
              if (0 < curr_log_level_rpl) tmp_5 = 0;
              else tmp_5 = curr_log_level_rpl;
              if (2 <= tmp_5) {
                printf("[%-4s: %-10s] ","WARN","RPL");
                printf("dio_input: unsupported DAG MC type %u, discard\n",
                       (unsigned int)dio.mc.type);
              }
            }
            goto discard;
          }
      break;
      case 3: ;
      if (len < 9) {
        {
          int tmp_6;
          if (0 < curr_log_level_rpl) tmp_6 = 0;
          else tmp_6 = curr_log_level_rpl;
          if (2 <= tmp_6) {
            printf("[%-4s: %-10s] ","WARN","RPL");
            printf("dio_input: invalid destination prefix option, len %u, discard\n",
                   len);
          }
        }
        goto discard;
      }
      dio.destination_prefix.length = *(buffer + (i + 2));
      dio.destination_prefix.flags = *(buffer + (i + 3));
      dio.destination_prefix.lifetime = get32(buffer,i + 4);
      if (((int)dio.destination_prefix.length + 7) / 8 + 8 <= len) {
        if ((int)dio.destination_prefix.length <= 128) memcpy((void *)(& dio.destination_prefix.prefix),
                                                              (void const *)(
                                                              buffer + (
                                                              i + 8)),
                                                              (unsigned long)(
                                                              ((int)dio.destination_prefix.length + 7) / 8));
        else goto _LAND;
      }
      else {
        _LAND:
        {
          {
            int tmp_7;
            if (0 < curr_log_level_rpl) tmp_7 = 0;
            else tmp_7 = curr_log_level_rpl;
            if (2 <= tmp_7) {
              printf("[%-4s: %-10s] ","WARN","RPL");
              printf("dio_input: invalid route info option, len %u, discard\n",
                     len);
            }
          }
          goto discard;
        }
      }
      break;
      case 4: ;
      if (len != 16) {
        {
          int tmp_8;
          if (0 < curr_log_level_rpl) tmp_8 = 0;
          else tmp_8 = curr_log_level_rpl;
          if (2 <= tmp_8) {
            printf("[%-4s: %-10s] ","WARN","RPL");
            printf("dio_input: invalid DAG configuration option, len %u, discard\n",
                   len);
          }
        }
        goto discard;
      }
      dio.dag_intdoubl = *(buffer + (i + 3));
      dio.dag_intmin = *(buffer + (i + 4));
      dio.dag_redund = *(buffer + (i + 5));
      dio.dag_max_rankinc = get16(buffer,i + 6);
      dio.dag_min_hoprankinc = get16(buffer,i + 8);
      dio.ocp = get16(buffer,i + 10);
      dio.default_lifetime = *(buffer + (i + 13));
      dio.lifetime_unit = get16(buffer,i + 14);
      break;
      case 8: ;
      if (len != 32) {
        {
          int tmp_9;
          if (0 < curr_log_level_rpl) tmp_9 = 0;
          else tmp_9 = curr_log_level_rpl;
          if (2 <= tmp_9) {
            printf("[%-4s: %-10s] ","WARN","RPL");
            printf("dio_input: invalid DAG prefix info, len %u, discard\n",
                   len);
          }
        }
        goto discard;
      }
      dio.prefix_info.length = *(buffer + (i + 2));
      dio.prefix_info.flags = *(buffer + (i + 3));
      dio.prefix_info.lifetime = get32(buffer,i + 8);
      memcpy((void *)(& dio.prefix_info.prefix),
             (void const *)(buffer + (i + 16)),(unsigned long)16);
      break;
      default:
      {
        int tmp_10;
        if (0 < curr_log_level_rpl) tmp_10 = 0;
        else tmp_10 = curr_log_level_rpl;
        if (2 <= tmp_10) {
          printf("[%-4s: %-10s] ","WARN","RPL");
          printf("dio_input: unsupported suboption type in DIO: %u, discard\n",
                 (unsigned int)subopt_type);
        }
      }
      goto discard;
    }
    i += len;
  }
  {
    int tmp_12;
    if (0 < curr_log_level_rpl) tmp_12 = 0; else tmp_12 = curr_log_level_rpl;
    if (3 <= tmp_12) {
      char const *tmp_11;
      printf("[%-4s: %-10s] ","INFO","RPL");
      if ((int)((struct uip_ip_hdr *)(uip_aligned_buf.u8))->destipaddr.u8[0] == 0xFF) 
        tmp_11 = "multicast";
      else tmp_11 = "unicast";
      printf("received a %s-DIO from ",tmp_11);
    }
  }
  {
    int tmp_13;
    if (0 < curr_log_level_rpl) tmp_13 = 0; else tmp_13 = curr_log_level_rpl;
    if (3 <= tmp_13) log_6addr((uip_ipaddr_t const *)(& from));
  }
  {
    int tmp_14;
    if (0 < curr_log_level_rpl) tmp_14 = 0; else tmp_14 = curr_log_level_rpl;
    if (3 <= tmp_14) printf(", instance_id %u, DAG ID ",
                            (unsigned int)dio.instance_id);
  }
  {
    int tmp_15;
    if (0 < curr_log_level_rpl) tmp_15 = 0; else tmp_15 = curr_log_level_rpl;
    if (3 <= tmp_15) log_6addr((uip_ipaddr_t const *)(& dio.dag_id));
  }
  {
    int tmp_16;
    if (0 < curr_log_level_rpl) tmp_16 = 0; else tmp_16 = curr_log_level_rpl;
    if (3 <= tmp_16) printf(", version %u, dtsn %u, rank %u\n",
                            (unsigned int)dio.version,(unsigned int)dio.dtsn,
                            (unsigned int)dio.rank);
  }
  rpl_process_dio(& from,& dio);
  discard: uipbuf_clear();
  return;
}

void rpl_icmp6_dio_output(uip_ipaddr_t *uc_addr)
{
  unsigned char *buffer;
  int pos;
  uint8_t tmp;
  int tmp_0;
  int tmp_1;
  uint8_t tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  uint8_t tmp_16;
  int tmp_17;
  int tmp_18;
  int tmp_19;
  int tmp_20;
  int tmp_21;
  int tmp_22;
  int tmp_23;
  int tmp_24;
  uint8_t tmp_29;
  uip_ipaddr_t *addr_0 = uc_addr;
  rpl_dag_update_state();
  tmp = rpl_get_leaf_only();
  if (tmp) 
    if (uc_addr == (uip_ipaddr_t *)0) goto return_label;
  pos = 0;
  buffer = (& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4;
  tmp_0 = pos;
  pos ++;
  *(buffer + tmp_0) = curr_instance.instance_id;
  tmp_1 = pos;
  pos ++;
  *(buffer + tmp_1) = curr_instance.dag.version;
  tmp_2 = rpl_get_leaf_only();
  if (tmp_2) set16(buffer,pos,(unsigned short)0xFFFF);
  else set16(buffer,pos,curr_instance.dag.rank);
  pos += 2;
  *(buffer + pos) = (unsigned char)0;
  if (curr_instance.dag.grounded) *(buffer + pos) = (unsigned char)((int)*(
                                                                    buffer + pos) | 0x80);
  *(buffer + pos) = (unsigned char)((int)*(buffer + pos) | ((int)curr_instance.mop << 3));
  *(buffer + pos) = (unsigned char)((int)*(buffer + pos) | ((int)curr_instance.dag.preference & 0x07));
  pos ++;
  tmp_3 = pos;
  pos ++;
  *(buffer + tmp_3) = curr_instance.dtsn_out;
  tmp_4 = pos;
  pos ++;
  *(buffer + tmp_4) = (unsigned char)0;
  tmp_5 = pos;
  pos ++;
  *(buffer + tmp_5) = (unsigned char)0;
  memcpy((void *)(buffer + pos),(void const *)(& curr_instance.dag.dag_id),
         sizeof(curr_instance.dag.dag_id));
  pos += 16;
  tmp_16 = rpl_get_leaf_only();
  if (! tmp_16) 
    if ((int)curr_instance.mc.type != 0) {
      int tmp_6;
      int tmp_7;
      int tmp_8;
      int tmp_9;
      int tmp_10;
      tmp_6 = pos;
      pos ++;
      *(buffer + tmp_6) = (unsigned char)2;
      tmp_7 = pos;
      pos ++;
      *(buffer + tmp_7) = (unsigned char)6;
      tmp_8 = pos;
      pos ++;
      *(buffer + tmp_8) = curr_instance.mc.type;
      tmp_9 = pos;
      pos ++;
      *(buffer + tmp_9) = (unsigned char)((int)curr_instance.mc.flags >> 1);
      *(buffer + pos) = (unsigned char)(((int)curr_instance.mc.flags & 1) << 7);
      tmp_10 = pos;
      pos ++;
      *(buffer + tmp_10) = (unsigned char)((int)*(buffer + tmp_10) | (
                                           ((int)curr_instance.mc.aggr << 4) | (int)curr_instance.mc.prec));
      if ((int)curr_instance.mc.type == 7) {
        int tmp_11;
        tmp_11 = pos;
        pos ++;
        *(buffer + tmp_11) = (unsigned char)2;
        set16(buffer,pos,curr_instance.mc.obj.etx);
        pos += 2;
      }
      else 
        if ((int)curr_instance.mc.type == 2) {
          int tmp_12;
          int tmp_13;
          int tmp_14;
          tmp_12 = pos;
          pos ++;
          *(buffer + tmp_12) = (unsigned char)2;
          tmp_13 = pos;
          pos ++;
          *(buffer + tmp_13) = curr_instance.mc.obj.energy.flags;
          tmp_14 = pos;
          pos ++;
          *(buffer + tmp_14) = curr_instance.mc.obj.energy.energy_est;
        }
        else {
          {
            int tmp_15;
            if (0 < curr_log_level_rpl) tmp_15 = 0;
            else tmp_15 = curr_log_level_rpl;
            if (1 <= tmp_15) {
              printf("[%-4s: %-10s] ","ERR","RPL");
              printf("unable to send DIO because of unsupported DAG MC type %u\n",
                     (unsigned int)curr_instance.mc.type);
            }
          }
          goto return_label;
        }
    }
  tmp_17 = pos;
  pos ++;
  *(buffer + tmp_17) = (unsigned char)4;
  tmp_18 = pos;
  pos ++;
  *(buffer + tmp_18) = (unsigned char)14;
  tmp_19 = pos;
  pos ++;
  *(buffer + tmp_19) = (unsigned char)0;
  tmp_20 = pos;
  pos ++;
  *(buffer + tmp_20) = curr_instance.dio_intdoubl;
  tmp_21 = pos;
  pos ++;
  *(buffer + tmp_21) = curr_instance.dio_intmin;
  tmp_22 = pos;
  pos ++;
  *(buffer + tmp_22) = curr_instance.dio_redundancy;
  set16(buffer,pos,curr_instance.max_rankinc);
  pos += 2;
  set16(buffer,pos,curr_instance.min_hoprankinc);
  pos += 2;
  set16(buffer,pos,(curr_instance.of)->ocp);
  pos += 2;
  tmp_23 = pos;
  pos ++;
  *(buffer + tmp_23) = (unsigned char)0;
  tmp_24 = pos;
  pos ++;
  *(buffer + tmp_24) = curr_instance.default_lifetime;
  set16(buffer,pos,curr_instance.lifetime_unit);
  pos += 2;
  if ((int)curr_instance.dag.prefix_info.length > 0) {
    int tmp_25;
    int tmp_26;
    int tmp_27;
    int tmp_28;
    tmp_25 = pos;
    pos ++;
    *(buffer + tmp_25) = (unsigned char)8;
    tmp_26 = pos;
    pos ++;
    *(buffer + tmp_26) = (unsigned char)30;
    tmp_27 = pos;
    pos ++;
    *(buffer + tmp_27) = curr_instance.dag.prefix_info.length;
    tmp_28 = pos;
    pos ++;
    *(buffer + tmp_28) = curr_instance.dag.prefix_info.flags;
    set32(buffer,pos,curr_instance.dag.prefix_info.lifetime);
    pos += 4;
    set32(buffer,pos,curr_instance.dag.prefix_info.lifetime);
    pos += 4;
    memset((void *)(buffer + pos),0,(unsigned long)4);
    pos += 4;
    memcpy((void *)(buffer + pos),
           (void const *)(& curr_instance.dag.prefix_info.prefix),
           (unsigned long)16);
    pos += 16;
  }
  tmp_29 = rpl_get_leaf_only();
  if (! tmp_29) 
    if (addr_0 != (uip_ipaddr_t *)0) addr_0 = addr_0;
    else addr_0 = & rpl_multicast_addr;
  {
    int tmp_31;
    if (0 < curr_log_level_rpl) tmp_31 = 0; else tmp_31 = curr_log_level_rpl;
    if (3 <= tmp_31) {
      char const *tmp_30;
      printf("[%-4s: %-10s] ","INFO","RPL");
      ;
      if (uc_addr != (uip_ipaddr_t *)0) tmp_30 = "unicast";
      else tmp_30 = "multicast";
      printf("sending a %s-DIO with rank %u to ",tmp_30,
             (unsigned int)curr_instance.dag.rank);
    }
  }
  {
    int tmp_32;
    if (0 < curr_log_level_rpl) tmp_32 = 0; else tmp_32 = curr_log_level_rpl;
    if (3 <= tmp_32) log_6addr((uip_ipaddr_t const *)addr_0);
  }
  {
    int tmp_33;
    if (0 < curr_log_level_rpl) tmp_33 = 0; else tmp_33 = curr_log_level_rpl;
    if (3 <= tmp_33) printf("\n");
  }
  uip_icmp6_send((uip_ipaddr_t const *)addr_0,155,0x01,pos);
  return_label: return;
}

static void dao_input(void)
{
  struct rpl_dao dao;
  uint8_t subopt_type;
  unsigned char *buffer;
  uint8_t buffer_length;
  int pos;
  int len;
  int i;
  uip_ipaddr_t from;
  int tmp_0;
  int tmp_1;
  memset((void *)(& dao),0,sizeof(dao));
  dao.instance_id = *(((& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4) + 0);
  if (! curr_instance.used) goto _LOR;
  else 
    if ((int)curr_instance.instance_id != (int)dao.instance_id) {
      _LOR:
      {
        {
          int tmp;
          if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
          if (1 <= tmp) {
            printf("[%-4s: %-10s] ","ERR","RPL");
            printf("dao_input: unknown RPL instance %u, discard\n",
                   (int)dao.instance_id);
          }
        }
        goto discard;
      }
    }
  from = ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr;
  memset((void *)(& dao.parent_addr),0,(unsigned long)16);
  buffer = (& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4;
  buffer_length = (unsigned char)((int)uip_len - ((40 + (int)uip_ext_len) + 4));
  pos = 0;
  pos ++;
  dao.lifetime = curr_instance.default_lifetime;
  tmp_0 = pos;
  pos ++;
  dao.flags = *(buffer + tmp_0);
  pos ++;
  tmp_1 = pos;
  pos ++;
  dao.sequence = (unsigned short)*(buffer + tmp_1);
  if ((int)dao.flags & 0x40) {
    int tmp_5;
    tmp_5 = memcmp((void const *)(& curr_instance.dag.dag_id),
                   (void const *)(buffer + pos),
                   sizeof(curr_instance.dag.dag_id));
    if (tmp_5) {
      {
        int tmp_2;
        if (0 < curr_log_level_rpl) tmp_2 = 0;
        else tmp_2 = curr_log_level_rpl;
        if (1 <= tmp_2) {
          printf("[%-4s: %-10s] ","ERR","RPL");
          printf("dao_input: different DAG ID ");
        }
      }
      {
        int tmp_3;
        if (0 < curr_log_level_rpl) tmp_3 = 0;
        else tmp_3 = curr_log_level_rpl;
        if (1 <= tmp_3) log_6addr((uip_ipaddr_t const *)(buffer + pos));
      }
      {
        int tmp_4;
        if (0 < curr_log_level_rpl) tmp_4 = 0;
        else tmp_4 = curr_log_level_rpl;
        if (1 <= tmp_4) printf(", discard\n");
      }
      goto discard;
    }
    pos += 16;
  }
  i = pos;
  while (i < (int)buffer_length) {
    subopt_type = *(buffer + i);
    if ((int)subopt_type == 0) len = 1;
    else len = 2 + (int)*(buffer + (i + 1));
    switch ((int)subopt_type) {
      case 5: dao.prefixlen = *(buffer + (i + 3));
      memset((void *)(& dao.prefix),0,sizeof(dao.prefix));
      memcpy((void *)(& dao.prefix),(void const *)((buffer + i) + 4),
             (unsigned long)(((int)dao.prefixlen + 7) / 8));
      break;
      case 6: dao.lifetime = *(buffer + (i + 5));
      if (len >= 20) memcpy((void *)(& dao.parent_addr),
                            (void const *)((buffer + i) + 6),
                            (unsigned long)16);
      break;
    }
    i += len;
  }
  {
    int tmp_7;
    if (0 < curr_log_level_rpl) tmp_7 = 0; else tmp_7 = curr_log_level_rpl;
    if (3 <= tmp_7) {
      char const *tmp_6;
      printf("[%-4s: %-10s] ","INFO","RPL");
      if ((int)dao.lifetime == 0) tmp_6 = "No-path "; else tmp_6 = "";
      printf("received a %sDAO from ",tmp_6);
    }
  }
  {
    int tmp_8;
    if (0 < curr_log_level_rpl) tmp_8 = 0; else tmp_8 = curr_log_level_rpl;
    if (3 <= tmp_8) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr));
  }
  {
    int tmp_9;
    if (0 < curr_log_level_rpl) tmp_9 = 0; else tmp_9 = curr_log_level_rpl;
    if (3 <= tmp_9) printf(", seqno %u, lifetime %u, prefix ",
                           (int)dao.sequence,(int)dao.lifetime);
  }
  {
    int tmp_10;
    if (0 < curr_log_level_rpl) tmp_10 = 0; else tmp_10 = curr_log_level_rpl;
    if (3 <= tmp_10) log_6addr((uip_ipaddr_t const *)(& dao.prefix));
  }
  {
    int tmp_11;
    if (0 < curr_log_level_rpl) tmp_11 = 0; else tmp_11 = curr_log_level_rpl;
    if (3 <= tmp_11) printf(", prefix length %u, parent ",(int)dao.prefixlen);
  }
  {
    int tmp_12;
    if (0 < curr_log_level_rpl) tmp_12 = 0; else tmp_12 = curr_log_level_rpl;
    if (3 <= tmp_12) log_6addr((uip_ipaddr_t const *)(& dao.parent_addr));
  }
  {
    int tmp_13;
    if (0 < curr_log_level_rpl) tmp_13 = 0; else tmp_13 = curr_log_level_rpl;
    if (3 <= tmp_13) printf(" \n");
  }
  rpl_process_dao(& from,& dao);
  discard: uipbuf_clear();
  return;
}

void rpl_icmp6_dao_output(uint8_t lifetime)
{
  unsigned char *buffer;
  uint8_t prefixlen;
  int pos;
  int tmp_4;
  int tmp_5;
  int tmp_6;
  int tmp_7;
  int tmp_8;
  int tmp_9;
  int tmp_10;
  int tmp_11;
  int tmp_12;
  int tmp_13;
  int tmp_14;
  int tmp_15;
  int tmp_16;
  uip_ipaddr_t const *prefix = rpl_get_global_address();
  uip_ipaddr_t *parent_ipaddr =
    rpl_neighbor_get_ipaddr(curr_instance.dag.preferred_parent);
  rpl_dag_update_state();
  if (! curr_instance.used) {
    {
      int tmp_1;
      if (0 < curr_log_level_rpl) tmp_1 = 0; else tmp_1 = curr_log_level_rpl;
      if (2 <= tmp_1) {
        printf("[%-4s: %-10s] ","WARN","RPL");
        printf("rpl_icmp6_dao_output: not in an instance, skip sending DAO\n");
      }
    }
    goto return_label;
  }
  if (curr_instance.dag.preferred_parent == (rpl_nbr_t *)0) {
    {
      int tmp_2;
      if (0 < curr_log_level_rpl) tmp_2 = 0; else tmp_2 = curr_log_level_rpl;
      if (2 <= tmp_2) {
        printf("[%-4s: %-10s] ","WARN","RPL");
        printf("rpl_icmp6_dao_output: no preferred parent, skip sending DAO\n");
      }
    }
    goto return_label;
  }
  if (prefix == (uip_ipaddr_t const *)0) goto _LOR;
  else 
    if (parent_ipaddr == (uip_ipaddr_t *)0) goto _LOR;
    else 
      if ((int)curr_instance.mop == 0) {
        _LOR:
        {
          {
            int tmp_3;
            if (0 < curr_log_level_rpl) tmp_3 = 0;
            else tmp_3 = curr_log_level_rpl;
            if (2 <= tmp_3) {
              printf("[%-4s: %-10s] ","WARN","RPL");
              printf("rpl_icmp6_dao_output: node not ready to send a DAO (prefix %p, parent addr %p, mop %u)\n",
                     prefix,parent_ipaddr,(int)curr_instance.mop);
            }
          }
          goto return_label;
        }
      }
  buffer = (& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4;
  pos = 0;
  tmp_4 = pos;
  pos ++;
  *(buffer + tmp_4) = curr_instance.instance_id;
  *(buffer + pos) = (unsigned char)0;
  if ((int)lifetime != 0) *(buffer + pos) = (unsigned char)((int)*(buffer + pos) | 0x80);
  pos ++;
  tmp_5 = pos;
  pos ++;
  *(buffer + tmp_5) = (unsigned char)0;
  tmp_6 = pos;
  pos ++;
  *(buffer + tmp_6) = curr_instance.dag.dao_last_seqno;
  prefixlen = (unsigned char)(sizeof(*prefix) * (unsigned long)8);
  tmp_7 = pos;
  pos ++;
  *(buffer + tmp_7) = (unsigned char)5;
  tmp_8 = pos;
  pos ++;
  *(buffer + tmp_8) = (unsigned char)(2 + ((int)prefixlen + 7) / 8);
  tmp_9 = pos;
  pos ++;
  *(buffer + tmp_9) = (unsigned char)0;
  tmp_10 = pos;
  pos ++;
  *(buffer + tmp_10) = prefixlen;
  memcpy((void *)(buffer + pos),(void const *)prefix,
         (unsigned long)(((int)prefixlen + 7) / 8));
  pos += ((int)prefixlen + 7) / 8;
  tmp_11 = pos;
  pos ++;
  *(buffer + tmp_11) = (unsigned char)6;
  tmp_12 = pos;
  pos ++;
  *(buffer + tmp_12) = (unsigned char)20;
  tmp_13 = pos;
  pos ++;
  *(buffer + tmp_13) = (unsigned char)0;
  tmp_14 = pos;
  pos ++;
  *(buffer + tmp_14) = (unsigned char)0;
  tmp_15 = pos;
  pos ++;
  *(buffer + tmp_15) = (unsigned char)0;
  tmp_16 = pos;
  pos ++;
  *(buffer + tmp_16) = lifetime;
  memcpy((void *)(buffer + pos),(void const *)(& curr_instance.dag.dag_id),
         (unsigned long)8);
  pos += 8;
  memcpy((void *)(buffer + pos),
         (void const *)((unsigned char const *)parent_ipaddr + 8),
         (unsigned long)8);
  pos += 8;
  {
    int tmp_18;
    if (0 < curr_log_level_rpl) tmp_18 = 0; else tmp_18 = curr_log_level_rpl;
    if (3 <= tmp_18) {
      char const *tmp_17;
      printf("[%-4s: %-10s] ","INFO","RPL");
      ;
      ;
      ;
      if ((int)lifetime == 0) tmp_17 = "No-path "; else tmp_17 = "";
      printf("sending a %sDAO seqno %u, tx count %u, lifetime %u, prefix ",
             tmp_17,(int)curr_instance.dag.dao_last_seqno,
             (int)curr_instance.dag.dao_transmissions,(int)lifetime);
    }
  }
  {
    int tmp_19;
    if (0 < curr_log_level_rpl) tmp_19 = 0; else tmp_19 = curr_log_level_rpl;
    if (3 <= tmp_19) log_6addr(prefix);
  }
  {
    int tmp_20;
    if (0 < curr_log_level_rpl) tmp_20 = 0; else tmp_20 = curr_log_level_rpl;
    if (3 <= tmp_20) printf(" to ");
  }
  {
    int tmp_21;
    if (0 < curr_log_level_rpl) tmp_21 = 0; else tmp_21 = curr_log_level_rpl;
    if (3 <= tmp_21) log_6addr((uip_ipaddr_t const *)(& curr_instance.dag.dag_id));
  }
  {
    int tmp_22;
    if (0 < curr_log_level_rpl) tmp_22 = 0; else tmp_22 = curr_log_level_rpl;
    if (3 <= tmp_22) printf(", parent ");
  }
  {
    int tmp_23;
    if (0 < curr_log_level_rpl) tmp_23 = 0; else tmp_23 = curr_log_level_rpl;
    if (3 <= tmp_23) log_6addr((uip_ipaddr_t const *)parent_ipaddr);
  }
  {
    int tmp_24;
    if (0 < curr_log_level_rpl) tmp_24 = 0; else tmp_24 = curr_log_level_rpl;
    if (3 <= tmp_24) printf("\n");
  }
  uip_icmp6_send((uip_ipaddr_t const *)(& curr_instance.dag.dag_id),155,0x02,
                 pos);
  return_label: return;
}

static void dao_ack_input(void)
{
  uint8_t *buffer;
  uint8_t instance_id;
  uint8_t sequence;
  uint8_t status;
  buffer = (& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4;
  instance_id = *(buffer + 0);
  sequence = *(buffer + 2);
  status = *(buffer + 3);
  if (! curr_instance.used) goto _LOR;
  else 
    if ((int)curr_instance.instance_id != (int)instance_id) {
      _LOR:
      {
        {
          int tmp;
          if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
          if (1 <= tmp) {
            printf("[%-4s: %-10s] ","ERR","RPL");
            printf("dao_ack_input: unknown instance, discard\n");
          }
        }
        goto discard;
      }
    }
  {
    int tmp_1;
    if (0 < curr_log_level_rpl) tmp_1 = 0; else tmp_1 = curr_log_level_rpl;
    if (3 <= tmp_1) {
      char const *tmp_0;
      printf("[%-4s: %-10s] ","INFO","RPL");
      ;
      ;
      ;
      ;
      if ((int)status < 128) tmp_0 = "ACK"; else tmp_0 = "NACK";
      printf("received a DAO-%s with seqno %d (%d %d) and status %d from ",
             tmp_0,(int)sequence,(int)curr_instance.dag.dao_last_seqno,
             (int)curr_instance.dag.dao_last_seqno,(int)status);
    }
  }
  {
    int tmp_2;
    if (0 < curr_log_level_rpl) tmp_2 = 0; else tmp_2 = curr_log_level_rpl;
    if (3 <= tmp_2) log_6addr((uip_ipaddr_t const *)(& ((struct uip_ip_hdr *)(uip_aligned_buf.u8))->srcipaddr));
  }
  {
    int tmp_3;
    if (0 < curr_log_level_rpl) tmp_3 = 0; else tmp_3 = curr_log_level_rpl;
    if (3 <= tmp_3) printf("\n");
  }
  rpl_process_dao_ack(sequence,status);
  discard: uipbuf_clear();
  return;
}

void rpl_icmp6_dao_ack_output(uip_ipaddr_t *dest, uint8_t sequence,
                              uint8_t status)
{
  unsigned char *buffer;
  rpl_dag_update_state();
  buffer = (& uip_aligned_buf.u8[40] + (int)uip_ext_len) + 4;
  *(buffer + 0) = curr_instance.instance_id;
  *(buffer + 1) = (unsigned char)0;
  *(buffer + 2) = sequence;
  *(buffer + 3) = status;
  {
    int tmp_0;
    if (0 < curr_log_level_rpl) tmp_0 = 0; else tmp_0 = curr_log_level_rpl;
    if (3 <= tmp_0) {
      char const *tmp;
      printf("[%-4s: %-10s] ","INFO","RPL");
      ;
      if ((int)status < 128) tmp = "ACK"; else tmp = "NACK";
      printf("sending a DAO-%s seqno %d to ",tmp,(int)sequence);
    }
  }
  {
    int tmp_1;
    if (0 < curr_log_level_rpl) tmp_1 = 0; else tmp_1 = curr_log_level_rpl;
    if (3 <= tmp_1) log_6addr((uip_ipaddr_t const *)dest);
  }
  {
    int tmp_2;
    if (0 < curr_log_level_rpl) tmp_2 = 0; else tmp_2 = curr_log_level_rpl;
    if (3 <= tmp_2) printf(" with status %d\n",(int)status);
  }
  uip_icmp6_send((uip_ipaddr_t const *)dest,155,0x03,4);
  return;
}

void rpl_icmp6_init(void)
{
  uip_icmp6_register_input_handler(& dis_handler);
  uip_icmp6_register_input_handler(& dio_handler);
  uip_icmp6_register_input_handler(& dao_handler);
  uip_icmp6_register_input_handler(& dao_ack_handler);
  return;
}

__inline static unsigned int __bswap_32_84(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_84(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

void rpl_dag_root_print_links(char const *str)
{
  int tmp_5;
  tmp_5 = rpl_dag_root_is_root();
  if (tmp_5) {
    int tmp_4;
    tmp_4 = uip_sr_num_nodes();
    if (tmp_4 > 0) {
      uip_sr_node_t *link_0;
      {
        int tmp_0;
        if (0 < curr_log_level_rpl) tmp_0 = 0;
        else tmp_0 = curr_log_level_rpl;
        if (3 <= tmp_0) {
          int tmp;
          printf("[%-4s: %-10s] ","INFO","RPL");
          ;
          tmp = uip_sr_num_nodes();
          printf("links: %u routing links in total (%s)\n",tmp,str);
        }
      }
      link_0 = uip_sr_node_head();
      while (link_0 != (uip_sr_node_t *)0) {
        char buf_0[100];
        uip_sr_link_snprint(buf_0,(int)sizeof(buf_0),link_0);
        {
          int tmp_1;
          if (0 < curr_log_level_rpl) tmp_1 = 0;
          else tmp_1 = curr_log_level_rpl;
          if (3 <= tmp_1) {
            printf("[%-4s: %-10s] ","INFO","RPL");
            printf("links: %s\n",buf_0);
          }
        }
        link_0 = uip_sr_node_next(link_0);
      }
      {
        int tmp_2;
        if (0 < curr_log_level_rpl) tmp_2 = 0;
        else tmp_2 = curr_log_level_rpl;
        if (3 <= tmp_2) {
          printf("[%-4s: %-10s] ","INFO","RPL");
          printf("links: end of list\n");
        }
      }
    }
    else {
      int tmp_3;
      if (0 < curr_log_level_rpl) tmp_3 = 0; else tmp_3 = curr_log_level_rpl;
      if (3 <= tmp_3) {
        printf("[%-4s: %-10s] ","INFO","RPL");
        printf("No routing links\n");
      }
    }
  }
  return;
}

static uip_ipaddr_t set_global_address_root_ipaddr;
static void set_global_address_0(uip_ipaddr_t *prefix, uip_ipaddr_t *iid)
{
  uip_ipaddr_t const *default_prefix_0;
  int i;
  uint8_t state;
  default_prefix_0 = uip_ds6_default_prefix();
  if (prefix == (uip_ipaddr_t *)0) set_global_address_root_ipaddr = *((uip_ip6addr_t *)default_prefix_0);
  else memcpy((void *)(& set_global_address_root_ipaddr),
              (void const *)prefix,(unsigned long)8);
  if (iid == (uip_ipaddr_t *)0) uip_ds6_set_addr_iid(& set_global_address_root_ipaddr,
                                                     & uip_lladdr);
  else memcpy((void *)((uint8_t *)(& set_global_address_root_ipaddr) + 8),
              (void const *)((uint8_t *)iid + 8),(unsigned long)8);
  uip_ds6_addr_add(& set_global_address_root_ipaddr,(unsigned long)0,
                   (unsigned char)1);
  {
    int tmp;
    if (0 < curr_log_level_rpl) tmp = 0; else tmp = curr_log_level_rpl;
    if (3 <= tmp) {
      printf("[%-4s: %-10s] ","INFO","RPL");
      printf("IPv6 addresses:\n");
    }
  }
  i = 0;
  while (i < 1 + 2) {
    state = uip_ds6_if.addr_list[i].state;
    if (uip_ds6_if.addr_list[i].isused) 
      if ((int)state == 0) goto _LOR;
      else 
        if ((int)state == 1) {
          _LOR:
          {
            {
              int tmp_0;
              if (0 < curr_log_level_rpl) tmp_0 = 0;
              else tmp_0 = curr_log_level_rpl;
              if (3 <= tmp_0) {
                printf("[%-4s: %-10s] ","INFO","RPL");
                printf("-- ");
              }
            }
            {
              int tmp_1;
              if (0 < curr_log_level_rpl) tmp_1 = 0;
              else tmp_1 = curr_log_level_rpl;
              if (3 <= tmp_1) log_6addr((uip_ipaddr_t const *)(& uip_ds6_if.addr_list[i].ipaddr));
            }
            {
              int tmp_2;
              if (0 < curr_log_level_rpl) tmp_2 = 0;
              else tmp_2 = curr_log_level_rpl;
              if (3 <= tmp_2) printf("\n");
            }
          }
        }
    i ++;
  }
  return;
}

static uint8_t rpl_dag_root_set_prefix_initialized = (unsigned char)0;
void rpl_dag_root_set_prefix(uip_ipaddr_t *prefix, uip_ipaddr_t *iid)
{
  if (! rpl_dag_root_set_prefix_initialized) {
    set_global_address_0(prefix,iid);
    rpl_dag_root_set_prefix_initialized = (unsigned char)1;
  }
  return;
}

int rpl_dag_root_start(void)
{
  int __retres;
  struct uip_ds6_addr *root_if;
  int i;
  uint8_t state;
  uip_ipaddr_t *ipaddr = (uip_ipaddr_t *)0;
  rpl_dag_root_set_prefix((uip_ipaddr_t *)0,(uip_ipaddr_t *)0);
  i = 0;
  while (i < 1 + 2) {
    state = uip_ds6_if.addr_list[i].state;
    if (uip_ds6_if.addr_list[i].isused) 
      if ((int)state == 1) 
        if ((int)uip_ds6_if.addr_list[i].ipaddr.u8[0] == 0xfe) {
          if (! ((int)uip_ds6_if.addr_list[i].ipaddr.u8[1] == 0x80)) 
            goto _LAND;
        }
        else _LAND: ipaddr = & uip_ds6_if.addr_list[i].ipaddr;
    i ++;
  }
  root_if = uip_ds6_addr_lookup(ipaddr);
  if (ipaddr != (uip_ipaddr_t *)0) goto _LOR;
  else 
    if (root_if != (struct uip_ds6_addr *)0) {
      _LOR:
      {
        uip_ipaddr_t const *tmp;
        tmp = rpl_get_global_address();
        ;
        rpl_dag_init_root((unsigned char)0,ipaddr,(uip_ipaddr_t *)tmp,
                          (unsigned int)64,(unsigned char)0x40);
        rpl_dag_update_state();
        {
          int tmp_0;
          if (0 < curr_log_level_rpl) tmp_0 = 0;
          else tmp_0 = curr_log_level_rpl;
          if (3 <= tmp_0) {
            printf("[%-4s: %-10s] ","INFO","RPL");
            printf("created a new RPL DAG\n");
          }
        }
        __retres = 0;
        goto return_label;
      }
    }
    else {
      {
        int tmp_1;
        if (0 < curr_log_level_rpl) tmp_1 = 0;
        else tmp_1 = curr_log_level_rpl;
        if (1 <= tmp_1) {
          printf("[%-4s: %-10s] ","ERR","RPL");
          printf("failed to create a new RPL DAG\n");
        }
      }
      __retres = -1;
      goto return_label;
    }
  return_label: return __retres;
}

int rpl_dag_root_is_root(void)
{
  int tmp;
  if (curr_instance.used) 
    if ((int)curr_instance.dag.rank == (int)curr_instance.min_hoprankinc) 
      tmp = 1;
    else tmp = 0;
  else tmp = 0;
  return tmp;
}

__inline static unsigned int __bswap_32_85(unsigned int __bsx)
{
  unsigned int tmp;
  tmp = __builtin_bswap32(__bsx);
  return tmp;
}

__inline static __uint64_t __bswap_64_85(__uint64_t __bsx)
{
  __uint64_t tmp;
  tmp = __builtin_bswap64(__bsx);
  return tmp;
}

static char process_thread_hello_world_process(struct pt *process_pt,
                                               process_event_t ev,
                                               process_data_t data);

struct process hello_world_process =
  {.next = (struct process *)0,
   .name = "Hello world process",
   .thread = & process_thread_hello_world_process,
   .pt = {.lc = (unsigned short)0},
   .state = (unsigned char)0,
   .needspoll = (unsigned char)0};
struct process * const autostart_processes[2] =
  {& hello_world_process, (struct process *)0};
static struct etimer process_thread_hello_world_process_timer;
static char process_thread_hello_world_process(struct pt *process_pt,
                                               process_event_t ev,
                                               process_data_t data)
{
  char __retres;
  {
    char PT_YIELD_FLAG = (char)1;
    if (PT_YIELD_FLAG) ;
    switch ((int)process_pt->lc) {
      case 0: ;
      etimer_set(& process_thread_hello_world_process_timer,
                 (unsigned long)(1000 * 10));
      while (1) {
        printf("Hello, world\n");
        PT_YIELD_FLAG = (char)0;
        process_pt->lc = (unsigned short)60;
        case 60: ;
        if ((int)PT_YIELD_FLAG == 0) goto _LOR;
        else {
          int tmp;
          tmp = etimer_expired(& process_thread_hello_world_process_timer);
          if (! tmp) {
            _LOR: {
                    __retres = (char)1;
                    goto return_label;
                  }
          }
        }
        etimer_reset(& process_thread_hello_world_process_timer);
      }
    }
    PT_YIELD_FLAG = (char)0;
    process_pt->lc = (unsigned short)0;
    __retres = (char)3;
    goto return_label;
  }
  return_label: return __retres;
}


